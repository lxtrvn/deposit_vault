{"version":3,"file":"859.bundle.js","mappings":"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","sources":["webpack://deposit_vault/webpack/runtime/async module","webpack://deposit_vault/wasm.js","webpack://deposit_vault/../js/index.js","webpack://deposit_vault/../src/worker.ts","webpack://deposit_vault/../src/utils.ts","webpack://deposit_vault/../src/network-client.ts","webpack://deposit_vault/../src/function-key-provider.ts","webpack://deposit_vault/../src/program-manager.ts","webpack://deposit_vault/../src/index.ts","webpack://deposit_vault/../node_modules/comlink/dist/esm/comlink.mjs","webpack://deposit_vault/webpack/bootstrap","webpack://deposit_vault/webpack/runtime/define property getters","webpack://deposit_vault/webpack/runtime/get javascript chunk filename","webpack://deposit_vault/webpack/runtime/global","webpack://deposit_vault/webpack/runtime/hasOwnProperty shorthand","webpack://deposit_vault/webpack/runtime/publicPath","webpack://deposit_vault/webpack/runtime/importScripts chunk loading","webpack://deposit_vault/webpack/startup"],"sourcesContent":["var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && queue.d < 1) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = -1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && queue.d < 0 && (queue.d = 0);\n};","function spawnWorker(url, module, memory, address) {\n        return new Promise((resolve) => {\n            const worker = new Worker(url, {\n                type: \"module\",\n            });\n\n            worker.addEventListener(\"message\", (event) => {\n                // When running in Node, this allows the process to exit\n                // even though the Worker is still running.\n                if (worker.unref) {\n                    worker.unref();\n                }\n\n                resolve(worker);\n            }, {\n                capture: true,\n                once: true,\n            });\n\n            worker.postMessage({\n                module,\n                memory,\n                address,\n            });\n        });\n    }\n\nlet wasm;\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); }\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().slice(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n};\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_3.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_34(arg0, arg1, arg2) {\n    wasm.wasm_bindgen__convert__closures__invoke1_mut__h53d50e21bb2d5c71(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* Verify an execution with a single function and a single transition. Executions with multiple\n* transitions or functions will fail to verify. Also, this does not verify that the state root of\n* the execution is included in the Aleo Network ledger.\n*\n* @param {Execution} execution The function execution to verify\n* @param {VerifyingKey} verifying_key The verifying key for the function\n* @param {Program} program The program that the function execution belongs to\n* @param {String} function_id The name of the function that was executed\n* @returns {boolean} True if the execution is valid, false otherwise\n* @param {Execution} execution\n* @param {VerifyingKey} verifying_key\n* @param {Program} program\n* @param {string} function_id\n* @returns {boolean}\n*/\nfunction verifyFunctionExecution(execution, verifying_key, program, function_id) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(execution, Execution);\n        _assertClass(verifying_key, VerifyingKey);\n        _assertClass(program, Program);\n        const ptr0 = passStringToWasm0(function_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.verifyFunctionExecution(retptr, execution.__wbg_ptr, verifying_key.__wbg_ptr, program.__wbg_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return r0 !== 0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nlet cachedBigInt64Memory0 = null;\n\nfunction getBigInt64Memory0() {\n    if (cachedBigInt64Memory0 === null || cachedBigInt64Memory0.buffer !== wasm.memory.buffer) {\n        cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);\n    }\n    return cachedBigInt64Memory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* @param {number} receiver\n*/\nfunction runRayonThread(receiver) {\n    wasm.runRayonThread(receiver);\n}\n\n/**\n* @param {URL} url\n* @param {number} num_threads\n* @returns {Promise<void>}\n*/\nfunction initThreadPool(url, num_threads) {\n    const ret = wasm.initThreadPool(addHeapObject(url), num_threads);\n    return takeObject(ret);\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\nfunction __wbg_adapter_251(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__he97f6a3b9df30e2b(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n* Public address of an Aleo account\n*/\nclass Address {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Address.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr);\n    }\n    /**\n    * Derive an Aleo address from a private key\n    *\n    * @param {PrivateKey} private_key The private key to derive the address from\n    * @returns {Address} Address corresponding to the private key\n    * @param {PrivateKey} private_key\n    * @returns {Address}\n    */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.address_from_private_key(private_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Derive an Aleo address from a view key\n    *\n    * @param {ViewKey} view_key The view key to derive the address from\n    * @returns {Address} Address corresponding to the view key\n    * @param {ViewKey} view_key\n    * @returns {Address}\n    */\n    static from_view_key(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.address_from_view_key(view_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Create an aleo address object from a string representation of an address\n    *\n    * @param {string} address String representation of an addressm\n    * @returns {Address} Address\n    * @param {string} address\n    * @returns {Address}\n    */\n    static from_string(address) {\n        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.address_from_string(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Get a string representation of an Aleo address object\n    *\n    * @param {Address} Address\n    * @returns {string} String representation of the address\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Verify a signature for a message signed by the address\n    *\n    * @param {Uint8Array} Byte array representing a message signed by the address\n    * @returns {boolean} Boolean representing whether or not the signature is valid\n    * @param {Uint8Array} message\n    * @param {Signature} signature\n    * @returns {boolean}\n    */\n    verify(message, signature) {\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(signature, Signature);\n        const ret = wasm.address_verify(this.__wbg_ptr, ptr0, len0, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n* Execution of an Aleo program.\n*/\nclass Execution {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Execution.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_execution_free(ptr);\n    }\n    /**\n    * Returns the string representation of the execution.\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.execution_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Creates an execution object from a string representation of an execution.\n    * @param {string} execution\n    * @returns {Execution}\n    */\n    static fromString(execution) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(execution, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.execution_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Execution.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Webassembly Representation of an Aleo function execution response\n*\n* This object is returned by the execution of an Aleo function off-chain. It provides methods for\n* retrieving the outputs of the function execution.\n*/\nclass ExecutionResponse {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ExecutionResponse.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_executionresponse_free(ptr);\n    }\n    /**\n    * Get the outputs of the executed function\n    *\n    * @returns {Array} Array of strings representing the outputs of the function\n    * @returns {Array<any>}\n    */\n    getOutputs() {\n        const ret = wasm.executionresponse_getOutputs(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns the execution object if present, null if otherwise.\n    *\n    * @returns {Execution | undefined} The execution object if present, null if otherwise\n    * @returns {Execution | undefined}\n    */\n    getExecution() {\n        const ret = wasm.executionresponse_getExecution(this.__wbg_ptr);\n        return ret === 0 ? undefined : Execution.__wrap(ret);\n    }\n    /**\n    * Returns the program keys if present\n    * @returns {KeyPair}\n    */\n    getKeys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.executionresponse_getKeys(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return KeyPair.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the proving_key if the proving key was cached in the Execution response.\n    * Note the proving key is removed from the response object after the first call to this\n    * function. Subsequent calls will return null.\n    *\n    * @returns {ProvingKey | undefined} The proving key\n    * @returns {ProvingKey | undefined}\n    */\n    getProvingKey() {\n        const ret = wasm.executionresponse_getProvingKey(this.__wbg_ptr);\n        return ret === 0 ? undefined : ProvingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying_key associated with the program\n    *\n    * @returns {VerifyingKey} The verifying key\n    * @returns {VerifyingKey}\n    */\n    getVerifyingKey() {\n        const ret = wasm.executionresponse_getVerifyingKey(this.__wbg_ptr);\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the function identifier\n    * @returns {string}\n    */\n    getFunctionId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.executionresponse_getFunctionId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Returns the program\n    * @returns {Program}\n    */\n    getProgram() {\n        const ret = wasm.executionresponse_getProgram(this.__wbg_ptr);\n        return Program.__wrap(ret);\n    }\n}\n/**\n*/\nclass Field {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Field.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_field_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.field_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} field\n    * @returns {Field}\n    */\n    static fromString(field) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(field, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.field_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Key pair object containing both the function proving and verifying keys\n*/\nclass KeyPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(KeyPair.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_keypair_free(ptr);\n    }\n    /**\n    * Create new key pair from proving and verifying keys\n    *\n    * @param {ProvingKey} proving_key Proving key corresponding to a function in an Aleo program\n    * @param {VerifyingKey} verifying_key Verifying key corresponding to a function in an Aleo program\n    * @returns {KeyPair} Key pair object containing both the function proving and verifying keys\n    * @param {ProvingKey} proving_key\n    * @param {VerifyingKey} verifying_key\n    */\n    constructor(proving_key, verifying_key) {\n        _assertClass(proving_key, ProvingKey);\n        var ptr0 = proving_key.__destroy_into_raw();\n        _assertClass(verifying_key, VerifyingKey);\n        var ptr1 = verifying_key.__destroy_into_raw();\n        const ret = wasm.keypair_new(ptr0, ptr1);\n        return KeyPair.__wrap(ret);\n    }\n    /**\n    * Get the proving key. This method will remove the proving key from the key pair\n    *\n    * @returns {ProvingKey | Error}\n    * @returns {ProvingKey}\n    */\n    provingKey() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.keypair_provingKey(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the verifying key. This method will remove the verifying key from the key pair\n    *\n    * @returns {VerifyingKey | Error}\n    * @returns {VerifyingKey}\n    */\n    verifyingKey() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.keypair_verifyingKey(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VerifyingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* An offline query object used to insert the global state root and state paths needed to create\n* a valid inclusion proof offline.\n*/\nclass OfflineQuery {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OfflineQuery.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_offlinequery_free(ptr);\n    }\n    /**\n    * Creates a new offline query object. The state root is required to be passed in as a string\n    * @param {string} state_root\n    */\n    constructor(state_root) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(state_root, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.offlinequery_new(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OfflineQuery.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Add a new state path to the offline query object.\n    *\n    * @param {string} commitment: The commitment corresponding to a record inpout\n    * @param {string} state_path: The state path corresponding to the commitment\n    * @param {string} commitment\n    * @param {string} state_path\n    */\n    addStatePath(commitment, state_path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(commitment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(state_path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.offlinequery_addStatePath(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a json string representation of the offline query object\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.offlinequery_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Create an offline query object from a json string representation\n    * @param {string} s\n    * @returns {OfflineQuery}\n    */\n    static fromString(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.offlinequery_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OfflineQuery.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Private key of an Aleo account\n*/\nclass PrivateKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PrivateKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekey_free(ptr);\n    }\n    /**\n    * Generate a new private key using a cryptographically secure random number generator\n    *\n    * @returns {PrivateKey}\n    */\n    constructor() {\n        const ret = wasm.privatekey_new();\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * Get a private key from a series of unchecked bytes\n    *\n    * @param {Uint8Array} seed Unchecked 32 byte long Uint8Array acting as the seed for the private key\n    * @returns {PrivateKey}\n    * @param {Uint8Array} seed\n    * @returns {PrivateKey}\n    */\n    static from_seed_unchecked(seed) {\n        const ptr0 = passArray8ToWasm0(seed, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_from_seed_unchecked(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * Get a private key from a string representation of a private key\n    *\n    * @param {string} seed String representation of a private key\n    * @returns {PrivateKey}\n    * @param {string} private_key\n    * @returns {PrivateKey}\n    */\n    static from_string(private_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(private_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_from_string(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a string representation of the private key. This function should be used very carefully\n    * as it exposes the private key plaintext\n    *\n    * @returns {string} String representation of a private key\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Get the view key corresponding to the private key\n    *\n    * @returns {ViewKey}\n    * @returns {ViewKey}\n    */\n    to_view_key() {\n        const ret = wasm.privatekey_to_view_key(this.__wbg_ptr);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n    * Get the address corresponding to the private key\n    *\n    * @returns {Address}\n    * @returns {Address}\n    */\n    to_address() {\n        const ret = wasm.address_from_private_key(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Sign a message with the private key\n    *\n    * @param {Uint8Array} Byte array representing a message signed by the address\n    * @returns {Signature} Signature generated by signing the message with the address\n    * @param {Uint8Array} message\n    * @returns {Signature}\n    */\n    sign(message) {\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_sign(this.__wbg_ptr, ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n    * Get a new randomly generated private key ciphertext using a secret. The secret is sensitive\n    * and will be needed to decrypt the private key later, so it should be stored securely\n    *\n    * @param {string} secret Secret used to encrypt the private key\n    * @returns {PrivateKeyCiphertext | Error} Ciphertext representation of the private key\n    * @param {string} secret\n    * @returns {PrivateKeyCiphertext}\n    */\n    static newEncrypted(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_newEncrypted(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encrypt an existing private key with a secret. The secret is sensitive and will be needed to\n    * decrypt the private key later, so it should be stored securely\n    *\n    * @param {string} secret Secret used to encrypt the private key\n    * @returns {PrivateKeyCiphertext | Error} Ciphertext representation of the private key\n    * @param {string} secret\n    * @returns {PrivateKeyCiphertext}\n    */\n    toCiphertext(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_toCiphertext(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get private key from a private key ciphertext and secret originally used to encrypt it\n    *\n    * @param {PrivateKeyCiphertext} ciphertext Ciphertext representation of the private key\n    * @param {string} secret Secret originally used to encrypt the private key\n    * @returns {PrivateKey | Error} Private key\n    * @param {PrivateKeyCiphertext} ciphertext\n    * @param {string} secret\n    * @returns {PrivateKey}\n    */\n    static fromPrivateKeyCiphertext(ciphertext, secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(ciphertext, PrivateKeyCiphertext);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_fromPrivateKeyCiphertext(retptr, ciphertext.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Private Key in ciphertext form\n*/\nclass PrivateKeyCiphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PrivateKeyCiphertext.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekeyciphertext_free(ptr);\n    }\n    /**\n    * Encrypt a private key using a secret string. The secret is sensitive and will be needed to\n    * decrypt the private key later, so it should be stored securely\n    *\n    * @param {PrivateKey} private_key Private key to encrypt\n    * @param {string} secret Secret to encrypt the private key with\n    * @returns {PrivateKeyCiphertext | Error} Private key ciphertext\n    * @param {PrivateKey} private_key\n    * @param {string} secret\n    * @returns {PrivateKeyCiphertext}\n    */\n    static encryptPrivateKey(private_key, secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(private_key, PrivateKey);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_toCiphertext(retptr, private_key.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decrypts a private ciphertext using a secret string. This must be the same secret used to\n    * encrypt the private key\n    *\n    * @param {string} secret Secret used to encrypt the private key\n    * @returns {PrivateKey | Error} Private key\n    * @param {string} secret\n    * @returns {PrivateKey}\n    */\n    decryptToPrivateKey(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_decryptToPrivateKey(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the ciphertext string\n    *\n    * @returns {string} Ciphertext string\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekeyciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Creates a PrivateKeyCiphertext from a string\n    *\n    * @param {string} ciphertext Ciphertext string\n    * @returns {PrivateKeyCiphertext | Error} Private key ciphertext\n    * @param {string} ciphertext\n    * @returns {PrivateKeyCiphertext}\n    */\n    static fromString(ciphertext) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Webassembly Representation of an Aleo program\n*/\nclass Program {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Program.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_program_free(ptr);\n    }\n    /**\n    * Create a program from a program string\n    *\n    * @param {string} program Aleo program source code\n    * @returns {Program | Error} Program object\n    * @param {string} program\n    * @returns {Program}\n    */\n    static fromString(program) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Program.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a string representation of the program\n    *\n    * @returns {string} String containing the program source code\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Determine if a function is present in the program\n    *\n    * @param {string} functionName Name of the function to check for\n    * @returns {boolean} True if the program is valid, false otherwise\n    * @param {string} function_name\n    * @returns {boolean}\n    */\n    hasFunction(function_name) {\n        const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.program_hasFunction(this.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * Get javascript array of functions names in the program\n    *\n    * @returns {Array} Array of all function names present in the program\n    *\n    * @example\n    * const expected_functions = [\n    *   \"mint\",\n    *   \"transfer_private\",\n    *   \"transfer_private_to_public\",\n    *   \"transfer_public\",\n    *   \"transfer_public_to_private\",\n    *   \"join\",\n    *   \"split\",\n    *   \"fee\"\n    * ]\n    *\n    * const credits_program = aleo_wasm.Program.getCreditsProgram();\n    * const credits_functions = credits_program.getFunctions();\n    * console.log(credits_functions === expected_functions); // Output should be \"true\"\n    * @returns {Array<any>}\n    */\n    getFunctions() {\n        const ret = wasm.program_getFunctions(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Get a javascript object representation of the function inputs and types. This can be used\n    * to generate a web form to capture user inputs for an execution of a function.\n    *\n    * @param {string} function_name Name of the function to get inputs for\n    * @returns {Array | Error} Array of function inputs\n    *\n    * @example\n    * const expected_inputs = [\n    *     {\n    *       type:\"record\",\n    *       visibility:\"private\",\n    *       record:\"credits\",\n    *       members:[\n    *         {\n    *           name:\"microcredits\",\n    *           type:\"u64\",\n    *           visibility:\"private\"\n    *         }\n    *       ],\n    *       register:\"r0\"\n    *     },\n    *     {\n    *       type:\"address\",\n    *       visibility:\"private\",\n    *       register:\"r1\"\n    *     },\n    *     {\n    *       type:\"u64\",\n    *       visibility:\"private\",\n    *       register:\"r2\"\n    *     }\n    * ];\n    *\n    * const credits_program = aleo_wasm.Program.getCreditsProgram();\n    * const transfer_function_inputs = credits_program.getFunctionInputs(\"transfer_private\");\n    * console.log(transfer_function_inputs === expected_inputs); // Output should be \"true\"\n    * @param {string} function_name\n    * @returns {Array<any>}\n    */\n    getFunctionInputs(function_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getFunctionInputs(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a the list of a program's mappings and the names/types of their keys and values.\n    *\n    * @returns {Array | Error} - An array of objects representing the mappings in the program\n    * @example\n    * const expected_mappings = [\n    *    {\n    *       name: \"account\",\n    *       key_name: \"owner\",\n    *       key_type: \"address\",\n    *       value_name: \"microcredits\",\n    *       value_type: \"u64\"\n    *    }\n    * ]\n    *\n    * const credits_program = aleo_wasm.Program.getCreditsProgram();\n    * const credits_mappings = credits_program.getMappings();\n    * console.log(credits_mappings === expected_mappings); // Output should be \"true\"\n    * @returns {Array<any>}\n    */\n    getMappings() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_getMappings(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a javascript object representation of a program record and its types\n    *\n    * @param {string} record_name Name of the record to get members for\n    * @returns {Object | Error} Object containing the record name, type, and members\n    *\n    * @example\n    *\n    * const expected_record = {\n    *     type: \"record\",\n    *     record: \"Credits\",\n    *     members: [\n    *       {\n    *         name: \"owner\",\n    *         type: \"address\",\n    *         visibility: \"private\"\n    *       },\n    *       {\n    *         name: \"microcredits\",\n    *         type: \"u64\",\n    *         visibility: \"private\"\n    *       }\n    *     ];\n    *  };\n    *\n    * const credits_program = aleo_wasm.Program.getCreditsProgram();\n    * const credits_record = credits_program.getRecordMembers(\"Credits\");\n    * console.log(credits_record === expected_record); // Output should be \"true\"\n    * @param {string} record_name\n    * @returns {object}\n    */\n    getRecordMembers(record_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getRecordMembers(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a javascript object representation of a program struct and its types\n    *\n    * @param {string} struct_name Name of the struct to get members for\n    * @returns {Array | Error} Array containing the struct members\n    *\n    * @example\n    *\n    * const STRUCT_PROGRAM = \"program token_issue.aleo;\n    *\n    * struct token_metadata:\n    *     network as u32;\n    *     version as u32;\n    *\n    * struct token:\n    *     token_id as u32;\n    *     metadata as token_metadata;\n    *\n    * function no_op:\n    *    input r0 as u64;\n    *    output r0 as u64;\"\n    *\n    * const expected_struct_members = [\n    *    {\n    *      name: \"token_id\",\n    *      type: \"u32\",\n    *    },\n    *    {\n    *      name: \"metadata\",\n    *      type: \"struct\",\n    *      struct_id: \"token_metadata\",\n    *      members: [\n    *       {\n    *         name: \"network\",\n    *         type: \"u32\",\n    *       }\n    *       {\n    *         name: \"version\",\n    *         type: \"u32\",\n    *       }\n    *     ]\n    *   }\n    * ];\n    *\n    * const program = aleo_wasm.Program.fromString(STRUCT_PROGRAM);\n    * const struct_members = program.getStructMembers(\"token\");\n    * console.log(struct_members === expected_struct_members); // Output should be \"true\"\n    * @param {string} struct_name\n    * @returns {Array<any>}\n    */\n    getStructMembers(struct_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(struct_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getStructMembers(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the credits.aleo program\n    *\n    * @returns {Program} The credits.aleo program\n    * @returns {Program}\n    */\n    static getCreditsProgram() {\n        const ret = wasm.program_getCreditsProgram();\n        return Program.__wrap(ret);\n    }\n    /**\n    * Get the id of the program\n    *\n    * @returns {string} The id of the program\n    * @returns {string}\n    */\n    id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_id(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Determine equality with another program\n    *\n    * @param {Program} other The other program to compare\n    * @returns {boolean} True if the programs are equal, false otherwise\n    * @param {Program} other\n    * @returns {boolean}\n    */\n    isEqual(other) {\n        _assertClass(other, Program);\n        const ret = wasm.program_isEqual(this.__wbg_ptr, other.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Get program_imports\n    *\n    * @returns {Array} The program imports\n    *\n    * @example\n    *\n    * const DOUBLE_TEST = \"import multiply_test.aleo;\n    *\n    * program double_test.aleo;\n    *\n    * function double_it:\n    *     input r0 as u32.private;\n    *     call multiply_test.aleo/multiply 2u32 r0 into r1;\n    *     output r1 as u32.private;\";\n    *\n    * const expected_imports = [\n    *    \"multiply_test.aleo\"\n    * ];\n    *\n    * const program = aleo_wasm.Program.fromString(DOUBLE_TEST_PROGRAM);\n    * const imports = program.getImports();\n    * console.log(imports === expected_imports); // Output should be \"true\"\n    * @returns {Array<any>}\n    */\n    getImports() {\n        const ret = wasm.program_getImports(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nclass ProgramManager {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_programmanager_free(ptr);\n    }\n    /**\n    * Deploy an Aleo program\n    *\n    * @param private_key The private key of the sender\n    * @param program The source code of the program being deployed\n    * @param imports A javascript object holding the source code of any imported programs in the\n    * form \\{\"program_name1\": \"program_source_code\", \"program_name2\": \"program_source_code\", ..\\}.\n    * Note that all imported programs must be deployed on chain before the main program in order\n    * for the deployment to succeed\n    * @param fee_credits The amount of credits to pay as a fee\n    * @param fee_record The record to spend the fee from\n    * @param url The url of the Aleo network node to send the transaction to\n    * @param imports (optional) Provide a list of imports to use for the program deployment in the\n    * form of a javascript object where the keys are a string of the program name and the values\n    * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n    * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n    * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n    * @returns {Transaction | Error}\n    * @param {PrivateKey} private_key\n    * @param {string} program\n    * @param {number} fee_credits\n    * @param {RecordPlaintext | undefined} fee_record\n    * @param {string | undefined} url\n    * @param {object | undefined} imports\n    * @param {ProvingKey | undefined} fee_proving_key\n    * @param {VerifyingKey | undefined} fee_verifying_key\n    * @param {OfflineQuery | undefined} offline_query\n    * @returns {Promise<Transaction>}\n    */\n    static buildDeploymentTransaction(private_key, program, fee_credits, fee_record, url, imports, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        let ptr1 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr1 = fee_record.__destroy_into_raw();\n        }\n        var ptr2 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        let ptr3 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr3 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr4 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr4 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr5 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildDeploymentTransaction(private_key.__wbg_ptr, ptr0, len0, fee_credits, ptr1, ptr2, len2, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr3, ptr4, ptr5);\n        return takeObject(ret);\n    }\n    /**\n    * Estimate the fee for a program deployment\n    *\n    * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n    *\n    * @param program The source code of the program being deployed\n    * @param imports (optional) Provide a list of imports to use for the deployment fee estimation\n    * in the form of a javascript object where the keys are a string of the program name and the values\n    * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n    * @returns {u64 | Error}\n    * @param {string} program\n    * @param {object | undefined} imports\n    * @returns {Promise<bigint>}\n    */\n    static estimateDeploymentFee(program, imports) {\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.programmanager_estimateDeploymentFee(ptr0, len0, isLikeNone(imports) ? 0 : addHeapObject(imports));\n        return takeObject(ret);\n    }\n    /**\n    * Estimate the component of the deployment cost which comes from the fee for the program name.\n    * Note that this cost does not represent the entire cost of deployment. It is additional to\n    * the cost of the size (in bytes) of the deployment.\n    *\n    * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n    *\n    * @param name The name of the program to be deployed\n    * @returns {u64 | Error}\n    * @param {string} name\n    * @returns {bigint}\n    */\n    static estimateProgramNameCost(name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.programmanager_estimateProgramNameCost(retptr, ptr0, len0);\n            var r0 = getBigInt64Memory0()[retptr / 8 + 0];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return BigInt.asUintN(64, r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Execute an arbitrary function locally\n    *\n    * @param {PrivateKey} private_key The private key of the sender\n    * @param {string} program The source code of the program being executed\n    * @param {string} function The name of the function to execute\n    * @param {Array} inputs A javascript array of inputs to the function\n    * @param {boolean} prove_execution If true, the execution will be proven and an execution object\n    * containing the proof and the encrypted inputs and outputs needed to verify the proof offline\n    * will be returned.\n    * @param {boolean} cache Cache the proving and verifying keys in the Execution response.\n    * If this is set to 'true' the keys synthesized will be stored in the Execution Response\n    * and the `ProvingKey` and `VerifyingKey` can be retrieved from the response via the `.getKeys()`\n    * method.\n    * @param {Object | undefined} imports (optional) Provide a list of imports to use for the function execution in the\n    * form of a javascript object where the keys are a string of the program name and the values\n    * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n    * @param {ProvingKey | undefined} proving_key (optional) Provide a verifying key to use for the function execution\n    * @param {VerifyingKey | undefined} verifying_key (optional) Provide a verifying key to use for the function execution\n    * @param {PrivateKey} private_key\n    * @param {string} program\n    * @param {string} _function\n    * @param {Array<any>} inputs\n    * @param {boolean} prove_execution\n    * @param {boolean} cache\n    * @param {object | undefined} imports\n    * @param {ProvingKey | undefined} proving_key\n    * @param {VerifyingKey | undefined} verifying_key\n    * @param {string | undefined} url\n    * @param {OfflineQuery | undefined} offline_query\n    * @returns {Promise<ExecutionResponse>}\n    */\n    static executeFunctionOffline(private_key, program, _function, inputs, prove_execution, cache, imports, proving_key, verifying_key, url, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(proving_key)) {\n            _assertClass(proving_key, ProvingKey);\n            ptr2 = proving_key.__destroy_into_raw();\n        }\n        let ptr3 = 0;\n        if (!isLikeNone(verifying_key)) {\n            _assertClass(verifying_key, VerifyingKey);\n            ptr3 = verifying_key.__destroy_into_raw();\n        }\n        var ptr4 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len4 = WASM_VECTOR_LEN;\n        let ptr5 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr5 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_executeFunctionOffline(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), prove_execution, cache, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr2, ptr3, ptr4, len4, ptr5);\n        return takeObject(ret);\n    }\n    /**\n    * Execute Aleo function and create an Aleo execution transaction\n    *\n    * @param private_key The private key of the sender\n    * @param program The source code of the program being executed\n    * @param function The name of the function to execute\n    * @param inputs A javascript array of inputs to the function\n    * @param fee_credits The amount of credits to pay as a fee\n    * @param fee_record The record to spend the fee from\n    * @param url The url of the Aleo network node to send the transaction to\n    * If this is set to 'true' the keys synthesized (or passed in as optional parameters via the\n    * `proving_key` and `verifying_key` arguments) will be stored in the ProgramManager's memory\n    * and used for subsequent transactions. If this is set to 'false' the proving and verifying\n    * keys will be deallocated from memory after the transaction is executed.\n    * @param imports (optional) Provide a list of imports to use for the function execution in the\n    * form of a javascript object where the keys are a string of the program name and the values\n    * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n    * @param proving_key (optional) Provide a verifying key to use for the function execution\n    * @param verifying_key (optional) Provide a verifying key to use for the function execution\n    * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n    * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n    * @returns {Transaction | Error}\n    * @param {PrivateKey} private_key\n    * @param {string} program\n    * @param {string} _function\n    * @param {Array<any>} inputs\n    * @param {number} fee_credits\n    * @param {RecordPlaintext | undefined} fee_record\n    * @param {string | undefined} url\n    * @param {object | undefined} imports\n    * @param {ProvingKey | undefined} proving_key\n    * @param {VerifyingKey | undefined} verifying_key\n    * @param {ProvingKey | undefined} fee_proving_key\n    * @param {VerifyingKey | undefined} fee_verifying_key\n    * @param {OfflineQuery | undefined} offline_query\n    * @returns {Promise<Transaction>}\n    */\n    static buildExecutionTransaction(private_key, program, _function, inputs, fee_credits, fee_record, url, imports, proving_key, verifying_key, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr2 = fee_record.__destroy_into_raw();\n        }\n        var ptr3 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        let ptr4 = 0;\n        if (!isLikeNone(proving_key)) {\n            _assertClass(proving_key, ProvingKey);\n            ptr4 = proving_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(verifying_key)) {\n            _assertClass(verifying_key, VerifyingKey);\n            ptr5 = verifying_key.__destroy_into_raw();\n        }\n        let ptr6 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr6 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr7 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr8 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildExecutionTransaction(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), fee_credits, ptr2, ptr3, len3, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr4, ptr5, ptr6, ptr7, ptr8);\n        return takeObject(ret);\n    }\n    /**\n    * Estimate Fee for Aleo function execution. Note if \"cache\" is set to true, the proving and\n    * verifying keys will be stored in the ProgramManager's memory and used for subsequent\n    * program executions.\n    *\n    * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n    *\n    * @param private_key The private key of the sender\n    * @param program The source code of the program to estimate the execution fee for\n    * @param function The name of the function to execute\n    * @param inputs A javascript array of inputs to the function\n    * @param url The url of the Aleo network node to send the transaction to\n    * @param imports (optional) Provide a list of imports to use for the fee estimation in the\n    * form of a javascript object where the keys are a string of the program name and the values\n    * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n    * @param proving_key (optional) Provide a verifying key to use for the fee estimation\n    * @param verifying_key (optional) Provide a verifying key to use for the fee estimation\n    * @returns {u64 | Error} Fee in microcredits\n    * @param {PrivateKey} private_key\n    * @param {string} program\n    * @param {string} _function\n    * @param {Array<any>} inputs\n    * @param {string | undefined} url\n    * @param {object | undefined} imports\n    * @param {ProvingKey | undefined} proving_key\n    * @param {VerifyingKey | undefined} verifying_key\n    * @param {OfflineQuery | undefined} offline_query\n    * @returns {Promise<bigint>}\n    */\n    static estimateExecutionFee(private_key, program, _function, inputs, url, imports, proving_key, verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        let ptr3 = 0;\n        if (!isLikeNone(proving_key)) {\n            _assertClass(proving_key, ProvingKey);\n            ptr3 = proving_key.__destroy_into_raw();\n        }\n        let ptr4 = 0;\n        if (!isLikeNone(verifying_key)) {\n            _assertClass(verifying_key, VerifyingKey);\n            ptr4 = verifying_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr5 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_estimateExecutionFee(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), ptr2, len2, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr3, ptr4, ptr5);\n        return takeObject(ret);\n    }\n    /**\n    * Estimate the finalize fee component for executing a function. This fee is additional to the\n    * size of the execution of the program in bytes. If the function does not have a finalize\n    * step, then the finalize fee is 0.\n    *\n    * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n    *\n    * @param program The program containing the function to estimate the finalize fee for\n    * @param function The function to estimate the finalize fee for\n    * @returns {u64 | Error} Fee in microcredits\n    * @param {string} program\n    * @param {string} _function\n    * @returns {bigint}\n    */\n    static estimateFinalizeFee(program, _function) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.programmanager_estimateFinalizeFee(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getBigInt64Memory0()[retptr / 8 + 0];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return BigInt.asUintN(64, r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Join two records together to create a new record with an amount of credits equal to the sum\n    * of the credits of the two original records\n    *\n    * @param private_key The private key of the sender\n    * @param record_1 The first record to combine\n    * @param record_2 The second record to combine\n    * @param fee_credits The amount of credits to pay as a fee\n    * @param fee_record The record to spend the fee from\n    * @param url The url of the Aleo network node to send the transaction to\n    * @param join_proving_key (optional) Provide a proving key to use for the join function\n    * @param join_verifying_key (optional) Provide a verifying key to use for the join function\n    * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n    * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n    * @returns {Transaction | Error} Transaction object\n    * @param {PrivateKey} private_key\n    * @param {RecordPlaintext} record_1\n    * @param {RecordPlaintext} record_2\n    * @param {number} fee_credits\n    * @param {RecordPlaintext | undefined} fee_record\n    * @param {string | undefined} url\n    * @param {ProvingKey | undefined} join_proving_key\n    * @param {VerifyingKey | undefined} join_verifying_key\n    * @param {ProvingKey | undefined} fee_proving_key\n    * @param {VerifyingKey | undefined} fee_verifying_key\n    * @param {OfflineQuery | undefined} offline_query\n    * @returns {Promise<Transaction>}\n    */\n    static buildJoinTransaction(private_key, record_1, record_2, fee_credits, fee_record, url, join_proving_key, join_verifying_key, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        _assertClass(record_1, RecordPlaintext);\n        var ptr0 = record_1.__destroy_into_raw();\n        _assertClass(record_2, RecordPlaintext);\n        var ptr1 = record_2.__destroy_into_raw();\n        let ptr2 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr2 = fee_record.__destroy_into_raw();\n        }\n        var ptr3 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        let ptr4 = 0;\n        if (!isLikeNone(join_proving_key)) {\n            _assertClass(join_proving_key, ProvingKey);\n            ptr4 = join_proving_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(join_verifying_key)) {\n            _assertClass(join_verifying_key, VerifyingKey);\n            ptr5 = join_verifying_key.__destroy_into_raw();\n        }\n        let ptr6 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr6 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr7 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr8 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildJoinTransaction(private_key.__wbg_ptr, ptr0, ptr1, fee_credits, ptr2, ptr3, len3, ptr4, ptr5, ptr6, ptr7, ptr8);\n        return takeObject(ret);\n    }\n    /**\n    * Split an Aleo credits record into two separate records. This function does not require a fee.\n    *\n    * @param private_key The private key of the sender\n    * @param split_amount The amount of the credit split. This amount will be subtracted from the\n    * value of the record and two new records will be created with the split amount and the remainder\n    * @param amount_record The record to split\n    * @param url The url of the Aleo network node to send the transaction to\n    * @param split_proving_key (optional) Provide a proving key to use for the split function\n    * @param split_verifying_key (optional) Provide a verifying key to use for the split function\n    * @returns {Transaction | Error} Transaction object\n    * @param {PrivateKey} private_key\n    * @param {number} split_amount\n    * @param {RecordPlaintext} amount_record\n    * @param {string | undefined} url\n    * @param {ProvingKey | undefined} split_proving_key\n    * @param {VerifyingKey | undefined} split_verifying_key\n    * @param {OfflineQuery | undefined} offline_query\n    * @returns {Promise<Transaction>}\n    */\n    static buildSplitTransaction(private_key, split_amount, amount_record, url, split_proving_key, split_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        _assertClass(amount_record, RecordPlaintext);\n        var ptr0 = amount_record.__destroy_into_raw();\n        var ptr1 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(split_proving_key)) {\n            _assertClass(split_proving_key, ProvingKey);\n            ptr2 = split_proving_key.__destroy_into_raw();\n        }\n        let ptr3 = 0;\n        if (!isLikeNone(split_verifying_key)) {\n            _assertClass(split_verifying_key, VerifyingKey);\n            ptr3 = split_verifying_key.__destroy_into_raw();\n        }\n        let ptr4 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr4 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildSplitTransaction(private_key.__wbg_ptr, split_amount, ptr0, ptr1, len1, ptr2, ptr3, ptr4);\n        return takeObject(ret);\n    }\n    /**\n    * Send credits from one Aleo account to another\n    *\n    * @param private_key The private key of the sender\n    * @param amount_credits The amount of credits to send\n    * @param recipient The recipient of the transaction\n    * @param transfer_type The type of the transfer (options: \"private\", \"public\", \"private_to_public\", \"public_to_private\")\n    * @param amount_record The record to fund the amount from\n    * @param fee_credits The amount of credits to pay as a fee\n    * @param fee_record The record to spend the fee from\n    * @param url The url of the Aleo network node to send the transaction to\n    * @param transfer_verifying_key (optional) Provide a verifying key to use for the transfer\n    * function\n    * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n    * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n    * @returns {Transaction | Error}\n    * @param {PrivateKey} private_key\n    * @param {number} amount_credits\n    * @param {string} recipient\n    * @param {string} transfer_type\n    * @param {RecordPlaintext | undefined} amount_record\n    * @param {number} fee_credits\n    * @param {RecordPlaintext | undefined} fee_record\n    * @param {string | undefined} url\n    * @param {ProvingKey | undefined} transfer_proving_key\n    * @param {VerifyingKey | undefined} transfer_verifying_key\n    * @param {ProvingKey | undefined} fee_proving_key\n    * @param {VerifyingKey | undefined} fee_verifying_key\n    * @param {OfflineQuery | undefined} offline_query\n    * @returns {Promise<Transaction>}\n    */\n    static buildTransferTransaction(private_key, amount_credits, recipient, transfer_type, amount_record, fee_credits, fee_record, url, transfer_proving_key, transfer_verifying_key, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(recipient, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(transfer_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(amount_record)) {\n            _assertClass(amount_record, RecordPlaintext);\n            ptr2 = amount_record.__destroy_into_raw();\n        }\n        let ptr3 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr3 = fee_record.__destroy_into_raw();\n        }\n        var ptr4 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len4 = WASM_VECTOR_LEN;\n        let ptr5 = 0;\n        if (!isLikeNone(transfer_proving_key)) {\n            _assertClass(transfer_proving_key, ProvingKey);\n            ptr5 = transfer_proving_key.__destroy_into_raw();\n        }\n        let ptr6 = 0;\n        if (!isLikeNone(transfer_verifying_key)) {\n            _assertClass(transfer_verifying_key, VerifyingKey);\n            ptr6 = transfer_verifying_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr7 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr8 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr9 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr9 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildTransferTransaction(private_key.__wbg_ptr, amount_credits, ptr0, len0, ptr1, len1, ptr2, fee_credits, ptr3, ptr4, len4, ptr5, ptr6, ptr7, ptr8, ptr9);\n        return takeObject(ret);\n    }\n    /**\n    * Synthesize proving and verifying keys for a program\n    *\n    * @param program {string} The program source code of the program to synthesize keys for\n    * @param function_id {string} The function to synthesize keys for\n    * @param inputs {Array} The inputs to the function\n    * @param imports {Object | undefined} The imports for the program\n    * @param {PrivateKey} private_key\n    * @param {string} program\n    * @param {string} function_id\n    * @param {Array<any>} inputs\n    * @param {object | undefined} imports\n    * @returns {Promise<KeyPair>}\n    */\n    static synthesizeKeyPair(private_key, program, function_id, inputs, imports) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(function_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.programmanager_synthesizeKeyPair(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), isLikeNone(imports) ? 0 : addHeapObject(imports));\n        return takeObject(ret);\n    }\n}\n/**\n* Proving key for a function within an Aleo program\n*/\nclass ProvingKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ProvingKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_provingkey_free(ptr);\n    }\n    /**\n    * Verify if the proving key is for the bond_public function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"bond_public_proving_key.bin\");\n    * provingKey.isBondPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the bond_public function, false if otherwise\n    * @returns {boolean}\n    */\n    isBondPublicProver() {\n        const ret = wasm.provingkey_isBondPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the claim_unbond function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"claim_unbond_proving_key.bin\");\n    * provingKey.isClaimUnbondProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the claim_unbond function, false if otherwise\n    * @returns {boolean}\n    */\n    isClaimUnbondPublicProver() {\n        const ret = wasm.provingkey_isClaimUnbondPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the fee_private function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"fee_private_proving_key.bin\");\n    * provingKey.isFeePrivateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the fee_private function, false if otherwise\n    * @returns {boolean}\n    */\n    isFeePrivateProver() {\n        const ret = wasm.provingkey_isFeePrivateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the fee_public function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"fee_public_proving_key.bin\");\n    * provingKey.isFeePublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the fee_public function, false if otherwise\n    * @returns {boolean}\n    */\n    isFeePublicProver() {\n        const ret = wasm.provingkey_isFeePublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the inclusion function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"inclusion_proving_key.bin\");\n    * provingKey.isInclusionProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the inclusion function, false if otherwise\n    * @returns {boolean}\n    */\n    isInclusionProver() {\n        const ret = wasm.provingkey_isInclusionProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the join function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"join_proving_key.bin\");\n    * provingKey.isJoinProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the join function, false if otherwise\n    * @returns {boolean}\n    */\n    isJoinProver() {\n        const ret = wasm.provingkey_isJoinProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the set_validator_state function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"set_validator_set_proving_key.bin\");\n    * provingKey.isSetValidatorStateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the set_validator_state function, false if otherwise\n    * @returns {boolean}\n    */\n    isSetValidatorStateProver() {\n        const ret = wasm.provingkey_isSetValidatorStateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the split function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"split_proving_key.bin\");\n    * provingKey.isSplitProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the split function, false if otherwise\n    * @returns {boolean}\n    */\n    isSplitProver() {\n        const ret = wasm.provingkey_isSplitProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the transfer_private function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"transfer_private_proving_key.bin\");\n    * provingKey.isTransferPrivateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the transfer_private function, false if otherwise\n    * @returns {boolean}\n    */\n    isTransferPrivateProver() {\n        const ret = wasm.provingkey_isTransferPrivateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the transfer_private_to_public function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"transfer_private_to_public_proving_key.bin\");\n    * provingKey.isTransferPrivateToPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the transfer_private_to_public function, false if otherwise\n    * @returns {boolean}\n    */\n    isTransferPrivateToPublicProver() {\n        const ret = wasm.provingkey_isTransferPrivateToPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the transfer_public function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"transfer_public_proving_key.bin\");\n    * provingKey.isTransferPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the transfer_public function, false if otherwise\n    * @returns {boolean}\n    */\n    isTransferPublicProver() {\n        const ret = wasm.provingkey_isTransferPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the transfer_public_to_private function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"transfer_public_to_private_proving_key.bin\");\n    * provingKey.isTransferPublicToPrivateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the transfer_public_to_private function, false if otherwise\n    * @returns {boolean}\n    */\n    isTransferPublicToPrivateProver() {\n        const ret = wasm.provingkey_isTransferPublicToPrivateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the unbond_delegator_as_validator function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"unbond_delegator_as_validator_proving_key.bin\");\n    * provingKey.isUnbondDelegatorAsValidatorProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the unbond_delegator_as_validator function, false if otherwise\n    * @returns {boolean}\n    */\n    isUnbondDelegatorAsValidatorProver() {\n        const ret = wasm.provingkey_isUnbondDelegatorAsValidatorProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verify if the proving key is for the unbond_delegator_as_delegator function\n    *\n    * @example\n    * const provingKey = ProvingKey.fromBytes(\"unbond_delegator_as_delegator_proving_key.bin\");\n    * provingKey.isUnbondDelegatorAsDelegatorProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n    *\n    * @returns {boolean} returns true if the proving key is for the unbond_delegator_as_delegator function, false if otherwise\n    * @returns {boolean}\n    */\n    isUnbondPublicProver() {\n        const ret = wasm.provingkey_isUnbondPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Return the checksum of the proving key\n    *\n    * @returns {string} Checksum of the proving key\n    * @returns {string}\n    */\n    checksum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.provingkey_checksum(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Create a copy of the proving key\n    *\n    * @returns {ProvingKey} A copy of the proving key\n    * @returns {ProvingKey}\n    */\n    copy() {\n        const ret = wasm.provingkey_copy(this.__wbg_ptr);\n        return ProvingKey.__wrap(ret);\n    }\n    /**\n    * Construct a new proving key from a byte array\n    *\n    * @param {Uint8Array} bytes Byte array representation of a proving key\n    * @returns {ProvingKey | Error}\n    * @param {Uint8Array} bytes\n    * @returns {ProvingKey}\n    */\n    static fromBytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.provingkey_fromBytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a proving key from string\n    *\n    * @param {string | Error} String representation of the proving key\n    * @param {string} string\n    * @returns {ProvingKey}\n    */\n    static fromString(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.provingkey_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Return the byte representation of a proving key\n    *\n    * @returns {Uint8Array | Error} Byte array representation of a proving key\n    * @returns {Uint8Array}\n    */\n    toBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.provingkey_toBytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a string representation of the proving key\n    *\n    * @returns {string} String representation of the proving key\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.provingkey_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n/**\n* Encrypted Aleo record\n*/\nclass RecordCiphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RecordCiphertext.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_recordciphertext_free(ptr);\n    }\n    /**\n    * Create a record ciphertext from a string\n    *\n    * @param {string} record String representation of a record ciphertext\n    * @returns {RecordCiphertext | Error} Record ciphertext\n    * @param {string} record\n    * @returns {RecordCiphertext}\n    */\n    static fromString(record) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Return the string reprensentation of the record ciphertext\n    *\n    * @returns {string} String representation of the record ciphertext\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Decrypt the record ciphertext into plaintext using the view key. The record will only\n    * decrypt if the record was encrypted by the account corresponding to the view key\n    *\n    * @param {ViewKey} view_key View key used to decrypt the ciphertext\n    * @returns {RecordPlaintext | Error} Record plaintext object\n    * @param {ViewKey} view_key\n    * @returns {RecordPlaintext}\n    */\n    decrypt(view_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(view_key, ViewKey);\n            wasm.recordciphertext_decrypt(retptr, this.__wbg_ptr, view_key.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordPlaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Determines if the account corresponding to the view key is the owner of the record\n    *\n    * @param {ViewKey} view_key View key used to decrypt the ciphertext\n    * @returns {boolean}\n    * @param {ViewKey} view_key\n    * @returns {boolean}\n    */\n    isOwner(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.recordciphertext_isOwner(this.__wbg_ptr, view_key.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n* Plaintext representation of an Aleo record\n*/\nclass RecordPlaintext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RecordPlaintext.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_recordplaintext_free(ptr);\n    }\n    /**\n    * @param {string} program_id\n    * @param {string} record_name\n    * @returns {Field}\n    */\n    commitment(program_id, record_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(record_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_commitment(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Return a record plaintext from a string.\n    *\n    * @param {string} record String representation of a plaintext representation of an Aleo record\n    * @returns {RecordPlaintext | Error} Record plaintext\n    * @param {string} record\n    * @returns {RecordPlaintext}\n    */\n    static fromString(record) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordPlaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the record plaintext string\n    *\n    * @returns {string} String representation of the record plaintext\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Returns the amount of microcredits in the record\n    *\n    * @returns {u64} Amount of microcredits in the record\n    * @returns {bigint}\n    */\n    microcredits() {\n        const ret = wasm.recordplaintext_microcredits(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n    * Returns the nonce of the record. This can be used to uniquely identify a record.\n    *\n    * @returns {string} Nonce of the record\n    * @returns {string}\n    */\n    nonce() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_nonce(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Attempt to get the serial number of a record to determine whether or not is has been spent\n    *\n    * @param {PrivateKey} private_key Private key of the account that owns the record\n    * @param {string} program_id Program ID of the program that the record is associated with\n    * @param {string} record_name Name of the record\n    * @returns {string | Error} Serial number of the record\n    * @param {PrivateKey} private_key\n    * @param {string} program_id\n    * @param {string} record_name\n    * @returns {string}\n    */\n    serialNumberString(private_key, program_id, record_name) {\n        let deferred4_0;\n        let deferred4_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(private_key, PrivateKey);\n            const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(record_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_serialNumberString(retptr, this.__wbg_ptr, private_key.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr3 = r0;\n            var len3 = r1;\n            if (r3) {\n                ptr3 = 0; len3 = 0;\n                throw takeObject(r2);\n            }\n            deferred4_0 = ptr3;\n            deferred4_1 = len3;\n            return getStringFromWasm0(ptr3, len3);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred4_0, deferred4_1, 1);\n        }\n    }\n}\n/**\n* Cryptographic signature of a message signed by an Aleo account\n*/\nclass Signature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Signature.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signature_free(ptr);\n    }\n    /**\n    * Sign a message with a private key\n    *\n    * @param {PrivateKey} private_key The private key to sign the message with\n    * @param {Uint8Array} message Byte representation of the message to sign\n    * @returns {Signature} Signature of the message\n    * @param {PrivateKey} private_key\n    * @param {Uint8Array} message\n    * @returns {Signature}\n    */\n    static sign(private_key, message) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_sign(private_key.__wbg_ptr, ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n    * Verify a signature of a message with an address\n    *\n    * @param {Address} address The address to verify the signature with\n    * @param {Uint8Array} message Byte representation of the message to verify\n    * @returns {boolean} True if the signature is valid, false otherwise\n    * @param {Address} address\n    * @param {Uint8Array} message\n    * @returns {boolean}\n    */\n    verify(address, message) {\n        _assertClass(address, Address);\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_verify(this.__wbg_ptr, address.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * Get a signature from a string representation of a signature\n    *\n    * @param {string} signature String representation of a signature\n    * @returns {Signature} Signature\n    * @param {string} signature\n    * @returns {Signature}\n    */\n    static from_string(signature) {\n        const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_from_string(ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n    * Get a string representation of a signature\n    *\n    * @returns {string} String representation of a signature\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n/**\n* Webassembly Representation of an Aleo transaction\n*\n* This object is created when generating an on-chain function deployment or execution and is the\n* object that should be submitted to the Aleo Network in order to deploy or execute a function.\n*/\nclass Transaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Transaction.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr);\n    }\n    /**\n    * Create a transaction from a string\n    *\n    * @param {string} transaction String representation of a transaction\n    * @returns {Transaction | Error}\n    * @param {string} transaction\n    * @returns {Transaction}\n    */\n    static fromString(transaction) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(transaction, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transaction_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the transaction as a string. If you want to submit this transaction to the Aleo Network\n    * this function will create the string that should be submitted in the `POST` data.\n    *\n    * @returns {string} String representation of the transaction\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Get the id of the transaction. This is the merkle root of the transaction's inclusion proof.\n    *\n    * This value can be used to query the status of the transaction on the Aleo Network to see\n    * if it was successful. If successful, the transaction will be included in a block and this\n    * value can be used to lookup the transaction data on-chain.\n    *\n    * @returns {string} Transaction id\n    * @returns {string}\n    */\n    transactionId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_transactionId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Get the type of the transaction (will return \"deploy\" or \"execute\")\n    *\n    * @returns {string} Transaction type\n    * @returns {string}\n    */\n    transactionType() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_transactionType(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n/**\n* Verifying key for a function within an Aleo program\n*/\nclass VerifyingKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VerifyingKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_verifyingkey_free(ptr);\n    }\n    /**\n    * Returns the verifying key for the bond_public function\n    *\n    * @returns {VerifyingKey} Verifying key for the bond_public function\n    * @returns {VerifyingKey}\n    */\n    static bondPublicVerifier() {\n        const ret = wasm.verifyingkey_bondPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the claim_delegator function\n    *\n    * @returns {VerifyingKey} Verifying key for the claim_unbond_public function\n    * @returns {VerifyingKey}\n    */\n    static claimUnbondPublicVerifier() {\n        const ret = wasm.verifyingkey_claimUnbondPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the fee_private function\n    *\n    * @returns {VerifyingKey} Verifying key for the fee_private function\n    * @returns {VerifyingKey}\n    */\n    static feePrivateVerifier() {\n        const ret = wasm.verifyingkey_feePrivateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the fee_public function\n    *\n    * @returns {VerifyingKey} Verifying key for the fee_public function\n    * @returns {VerifyingKey}\n    */\n    static feePublicVerifier() {\n        const ret = wasm.verifyingkey_feePublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the inclusion function\n    *\n    * @returns {VerifyingKey} Verifying key for the inclusion function\n    * @returns {VerifyingKey}\n    */\n    static inclusionVerifier() {\n        const ret = wasm.verifyingkey_inclusionVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the join function\n    *\n    * @returns {VerifyingKey} Verifying key for the join function\n    * @returns {VerifyingKey}\n    */\n    static joinVerifier() {\n        const ret = wasm.verifyingkey_joinVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the set_validator_state function\n    *\n    * @returns {VerifyingKey} Verifying key for the set_validator_state function\n    * @returns {VerifyingKey}\n    */\n    static setValidatorStateVerifier() {\n        const ret = wasm.verifyingkey_setValidatorStateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the split function\n    *\n    * @returns {VerifyingKey} Verifying key for the split function\n    * @returns {VerifyingKey}\n    */\n    static splitVerifier() {\n        const ret = wasm.verifyingkey_splitVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the transfer_private function\n    *\n    * @returns {VerifyingKey} Verifying key for the transfer_private function\n    * @returns {VerifyingKey}\n    */\n    static transferPrivateVerifier() {\n        const ret = wasm.verifyingkey_transferPrivateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the transfer_private_to_public function\n    *\n    * @returns {VerifyingKey} Verifying key for the transfer_private_to_public function\n    * @returns {VerifyingKey}\n    */\n    static transferPrivateToPublicVerifier() {\n        const ret = wasm.verifyingkey_transferPrivateToPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the transfer_public function\n    *\n    * @returns {VerifyingKey} Verifying key for the transfer_public function\n    * @returns {VerifyingKey}\n    */\n    static transferPublicVerifier() {\n        const ret = wasm.verifyingkey_transferPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the transfer_public_to_private function\n    *\n    * @returns {VerifyingKey} Verifying key for the transfer_public_to_private function\n    * @returns {VerifyingKey}\n    */\n    static transferPublicToPrivateVerifier() {\n        const ret = wasm.verifyingkey_transferPublicToPrivateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the unbond_delegator_as_delegator function\n    *\n    * @returns {VerifyingKey} Verifying key for the unbond_delegator_as_delegator function\n    * @returns {VerifyingKey}\n    */\n    static unbondDelegatorAsValidatorVerifier() {\n        const ret = wasm.verifyingkey_unbondDelegatorAsValidatorVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the unbond_delegator_as_delegator function\n    *\n    * @returns {VerifyingKey} Verifying key for the unbond_delegator_as_delegator function\n    * @returns {VerifyingKey}\n    */\n    static unbondPublicVerifier() {\n        const ret = wasm.verifyingkey_unbondPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Returns the verifying key for the bond_public function\n    *\n    * @returns {VerifyingKey} Verifying key for the bond_public function\n    * @returns {boolean}\n    */\n    isBondPublicVerifier() {\n        const ret = wasm.verifyingkey_isBondPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the claim_delegator function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isClaimUnbondPublicVerifier() {\n        const ret = wasm.verifyingkey_isClaimUnbondPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the fee_private function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isFeePrivateVerifier() {\n        const ret = wasm.verifyingkey_isFeePrivateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the fee_public function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isFeePublicVerifier() {\n        const ret = wasm.verifyingkey_isFeePublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the inclusion function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isInclusionVerifier() {\n        const ret = wasm.verifyingkey_isInclusionVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the join function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isJoinVerifier() {\n        const ret = wasm.verifyingkey_isJoinVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the set_validator_state function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isSetValidatorStateVerifier() {\n        const ret = wasm.verifyingkey_isSetValidatorStateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the split function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isSplitVerifier() {\n        const ret = wasm.verifyingkey_isSplitVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the transfer_private function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isTransferPrivateVerifier() {\n        const ret = wasm.verifyingkey_isTransferPrivateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the transfer_private_to_public function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isTransferPrivateToPublicVerifier() {\n        const ret = wasm.verifyingkey_isTransferPrivateToPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the transfer_public function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isTransferPublicVerifier() {\n        const ret = wasm.verifyingkey_isTransferPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the transfer_public_to_private function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isTransferPublicToPrivateVerifier() {\n        const ret = wasm.verifyingkey_isTransferPublicToPrivateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the unbond_delegator_as_delegator function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isUnbondDelegatorAsValidatorVerifier() {\n        const ret = wasm.verifyingkey_isUnbondDelegatorAsValidatorVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Verifies the verifying key is for the unbond_public function\n    *\n    * @returns {bool}\n    * @returns {boolean}\n    */\n    isUnbondPublicVerifier() {\n        const ret = wasm.verifyingkey_isUnbondPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Get the checksum of the verifying key\n    *\n    * @returns {string} Checksum of the verifying key\n    * @returns {string}\n    */\n    checksum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.verifyingkey_checksum(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Create a copy of the verifying key\n    *\n    * @returns {VerifyingKey} A copy of the verifying key\n    * @returns {VerifyingKey}\n    */\n    copy() {\n        const ret = wasm.provingkey_copy(this.__wbg_ptr);\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n    * Construct a new verifying key from a byte array\n    *\n    * @param {Uint8Array} bytes Byte representation of a verifying key\n    * @returns {VerifyingKey | Error}\n    * @param {Uint8Array} bytes\n    * @returns {VerifyingKey}\n    */\n    static fromBytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.verifyingkey_fromBytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VerifyingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a verifying key from string\n    *\n    * @param {String} string String representation of a verifying key\n    * @returns {VerifyingKey | Error}\n    * @param {string} string\n    * @returns {VerifyingKey}\n    */\n    static fromString(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.verifyingkey_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VerifyingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a byte array from a verifying key\n    *\n    * @returns {Uint8Array | Error} Byte representation of a verifying key\n    * @returns {Uint8Array}\n    */\n    toBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.verifyingkey_toBytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a string representation of the verifying key\n    *\n    * @returns {String} String representation of the verifying key\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.verifyingkey_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n/**\n*/\nclass ViewKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ViewKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_viewkey_free(ptr);\n    }\n    /**\n    * Create a new view key from a private key\n    *\n    * @param {PrivateKey} private_key Private key\n    * @returns {ViewKey} View key\n    * @param {PrivateKey} private_key\n    * @returns {ViewKey}\n    */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.privatekey_to_view_key(private_key.__wbg_ptr);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n    * Create a new view key from a string representation of a view key\n    *\n    * @param {string} view_key String representation of a view key\n    * @returns {ViewKey} View key\n    * @param {string} view_key\n    * @returns {ViewKey}\n    */\n    static from_string(view_key) {\n        const ptr0 = passStringToWasm0(view_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.viewkey_from_string(ptr0, len0);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n    * Get a string representation of a view key\n    *\n    * @returns {string} String representation of a view key\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.viewkey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Get the address corresponding to a view key\n    *\n    * @returns {Address} Address\n    * @returns {Address}\n    */\n    to_address() {\n        const ret = wasm.address_from_view_key(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Decrypt a record ciphertext with a view key\n    *\n    * @param {string} ciphertext String representation of a record ciphertext\n    * @returns {string} String representation of a record plaintext\n    * @param {string} ciphertext\n    * @returns {string}\n    */\n    decrypt(ciphertext) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.viewkey_decrypt(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbg_new_daafff584c71593b = function() { return handleError(function () {\n        const ret = new XMLHttpRequest();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_overrideMimeType_1a661d17da5f8baf = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).overrideMimeType(getStringFromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_open_56fa1eb95989f6a5 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5) {\n        getObject(arg0).open(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4), arg5 !== 0);\n    }, arguments) };\n    imports.wbg.__wbg_send_9f5007eae908c72e = function() { return handleError(function (arg0) {\n        getObject(arg0).send();\n    }, arguments) };\n    imports.wbg.__wbg_response_f2acf2ecbe021710 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).response;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_b51585de1b234aff = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_092e06b0f9d71865 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_new_1eead62f64ca15ce = function() { return handleError(function () {\n        const ret = new Headers();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_append_fda9e3432e3e88da = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_new_55c9955722952374 = function() { return handleError(function () {\n        const ret = new AbortController();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_signal_4bd18fb489af2d4c = function(arg0) {\n        const ret = getObject(arg0).signal;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_Response_fc4327dbfcdf5ced = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Response;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_status_ac85a3142a84caa2 = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_url_8503de97f69da463 = function(arg0, arg1) {\n        const ret = getObject(arg1).url;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_headers_b70de86b8e989bc0 = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_iterator_97f0c81209c6c35a = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_97b561fb56f034b5 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg_call_cb65541d95d71282 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_next_526fc47e980da008 = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_next_ddb3312ca1c4e32a = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_done_5c1f01fb660d73b5 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_value_1695675138684bd5 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_abort_654b796176d117aa = function(arg0) {\n        getObject(arg0).abort();\n    };\n    imports.wbg.__wbg_stringify_e25465938f3f611f = function() { return handleError(function (arg0) {\n        const ret = JSON.stringify(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_call_01734de55d61e11d = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_keypair_new = function(arg0) {\n        const ret = KeyPair.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_log_0159ca40cddf5b15 = function(arg0, arg1) {\n        console.log(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_transaction_new = function(arg0) {\n        const ret = Transaction.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_module = function() {\n        const ret = __wbg_init.__wbindgen_wasm_module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_spawnWorker_f6acaddb2e29dc4a = function(arg0, arg1, arg2, arg3) {\n        const ret = spawnWorker(getObject(arg0), getObject(arg1), getObject(arg2), arg3);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_executionresponse_new = function(arg0) {\n        const ret = ExecutionResponse.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_3ec098a360da1909 = function(arg0) {\n        const ret = new Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_502d29070ea18557 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbg_arrayBuffer_288fb3538806e85c = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).arrayBuffer();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_8125e318e6245eed = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_72e2208bbc0efc61 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_new_43f1b47c28813cbd = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wbg_adapter_251(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            const ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbg_new_898a68150f225f2e = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_push_ca1c26067ef907ac = function(arg0, arg1) {\n        const ret = getObject(arg0).push(getObject(arg1));\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_abda76e883ba8a5f = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_subarray_13db269f57aa838d = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_37fa2ca9e4e07fab = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_buffer_085ec1f694018c4f = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_5cf90238115182c3 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_6da8e527659b86aa = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_randomFillSync_dc1e9a60c158336d = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).randomFillSync(takeObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_crypto_c48a774b022d20ac = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_process_298734cf255a885d = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_e2e78e134e3e5d01 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_1cd7a5d853dbea79 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbg_msCrypto_bcb970640f50a1e8 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_e5d69174d6984cd7 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_8f08ceecec0f4fee = function() { return handleError(function () {\n        const ret = module.require;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_length_fff51ee6522a1a18 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_get_44be0491f933a435 = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_1ff1d729e9aae938 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_5f4faef6c12b79ec = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_1d39714405582d3c = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_651f05c6a0944d1c = function() { return handleError(function () {\n        const ret = global.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg_newnoargs_581967eacc0e2604 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_has_c5fcd020291e56b8 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.has(getObject(arg0), getObject(arg1));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_fetch_8eaf01857a5bb21f = function(arg0, arg1) {\n        const ret = getObject(arg0).fetch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetch_b5d6bebed1e6c2d2 = function(arg0) {\n        const ret = fetch(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_rethrow = function(arg0) {\n        throw takeObject(arg0);\n    };\n    imports.wbg.__wbg_then_b2267541e2a73865 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_f7e06ee3c11698eb = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_resolve_53698b95aaf7fcf8 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_waitAsync_60fb5e2e86467e31 = function() {\n        const ret = Atomics.waitAsync;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_a0af68041688e8fd = function(arg0) {\n        const ret = new Int32Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_waitAsync_73fd6eb3bace0a8d = function(arg0, arg1, arg2) {\n        const ret = Atomics.waitAsync(getObject(arg0), arg1, arg2);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_async_e1a2a669aacf35ff = function(arg0) {\n        const ret = getObject(arg0).async;\n        return ret;\n    };\n    imports.wbg.__wbg_value_555e4f564193db05 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_link_22046963fe0b707a = function(arg0) {\n        const ret = \"data:application/javascript,\" + encodeURIComponent(`onmessage = function (ev) {\n            let [ia, index, value] = ev.data;\n            ia = new Int32Array(ia.buffer);\n            let result = Atomics.wait(ia, index, value);\n            postMessage(result);\n        };\n        `);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_new_8e7322f46d5d019c = function() { return handleError(function (arg0, arg1) {\n        const ret = new Worker(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setonmessage_f0bd0280573b7084 = function(arg0, arg1) {\n        getObject(arg0).onmessage = getObject(arg1);\n    };\n    imports.wbg.__wbg_of_3f69007bb4eeae65 = function(arg0, arg1, arg2) {\n        const ret = Array.of(getObject(arg0), getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_postMessage_8c609e2bde333d9c = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).postMessage(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_data_ab99ae4a2e1e8bc9 = function(arg0) {\n        const ret = getObject(arg0).data;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithstrandinit_cad5cd6038c7ff5d = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_status_114ef6fe27fb8b00 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_responseText_da275667251fd153 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg1).responseText;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    }, arguments) };\n    imports.wbg.__wbindgen_closure_wrapper5654 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 543, __wbg_adapter_34);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper5677 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 543, __wbg_adapter_34);\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, maybe_memory) {\n    imports.wbg.memory = maybe_memory || new WebAssembly.Memory({initial:169,maximum:65536,shared:true});\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedBigInt64Memory0 = null;\n    cachedInt32Memory0 = null;\n    cachedUint8Memory0 = null;\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module, maybe_memory) {\n    if (wasm !== undefined) return wasm;\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports, maybe_memory);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(input, maybe_memory) {\n    if (wasm !== undefined) return wasm;\n\n\n    const imports = __wbg_get_imports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    __wbg_init_memory(imports, maybe_memory);\n\n    const { instance, module } = await __wbg_load(await input, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nvar exports = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Address: Address,\n    Execution: Execution,\n    ExecutionResponse: ExecutionResponse,\n    Field: Field,\n    KeyPair: KeyPair,\n    OfflineQuery: OfflineQuery,\n    PrivateKey: PrivateKey,\n    PrivateKeyCiphertext: PrivateKeyCiphertext,\n    Program: Program,\n    ProgramManager: ProgramManager,\n    ProvingKey: ProvingKey,\n    RecordCiphertext: RecordCiphertext,\n    RecordPlaintext: RecordPlaintext,\n    Signature: Signature,\n    Transaction: Transaction,\n    VerifyingKey: VerifyingKey,\n    ViewKey: ViewKey,\n    default: __wbg_init,\n    initSync: initSync,\n    initThreadPool: initThreadPool,\n    runRayonThread: runRayonThread,\n    verifyFunctionExecution: verifyFunctionExecution\n});\n\nconst wasm_path = \"assets/aleo_wasm.wasm\";\n\n            \n            var Cargo = async (opt = {}) => {\n                let {importHook, serverPath, initializeHook} = opt;\n\n                let final_path = wasm_path;\n\n                if (serverPath != null) {\n                    final_path = serverPath + /[^\\/\\\\]*$/.exec(final_path)[0];\n                }\n\n                if (importHook != null) {\n                    final_path = importHook(final_path);\n                }\n\n                if (initializeHook != null) {\n                    await initializeHook(__wbg_init, final_path);\n\n                } else {\n                    await __wbg_init(final_path);\n                }\n\n                return exports;\n            };\n\nexport { Cargo as default };\n//# sourceMappingURL=wasm.js.map\n","import wasm from \"../dist/wasm.js\";\n\nconst {\n    initThreadPool: wasmInitThreadPool,\n    Address,\n    Execution,\n    ExecutionResponse,\n    Field,\n    OfflineQuery,\n    Private,\n    PrivateKey,\n    PrivateKeyCiphertext,\n    Program,\n    ProvingKey,\n    RecordCiphertext,\n    RecordPlaintext,\n    ProgramManager,\n    Signature,\n    Transaction,\n    ViewKey,\n    VerifyingKey,\n    verifyFunctionExecution,\n} = await wasm({\n    importHook: () => {\n        return new URL(\"assets/aleo_wasm.wasm\", import.meta.url);\n    },\n});\n\nasync function initThreadPool(threads) {\n    if (threads == null) {\n        threads = navigator.hardwareConcurrency;\n    }\n\n    console.info(`Spawning ${threads} threads`);\n\n    await wasmInitThreadPool(new URL(\"worker.js\", import.meta.url), threads);\n}\n\nexport {\n    initThreadPool,\n    Address,\n    Execution,\n    ExecutionResponse,\n    Field,\n    OfflineQuery,\n    PrivateKey,\n    PrivateKeyCiphertext,\n    Program,\n    ProvingKey,\n    RecordCiphertext,\n    RecordPlaintext,\n    ProgramManager,\n    Signature,\n    Transaction,\n    ViewKey,\n    VerifyingKey,\n    verifyFunctionExecution,\n};\n","import {initThreadPool, ProgramManager, PrivateKey, verifyFunctionExecution, FunctionKeyPair} from \"./index\";\nimport { AleoKeyProvider, AleoKeyProviderParams} from \"./function-key-provider\";\nimport { expose } from \"comlink\";\n\nawait initThreadPool();\n\nconst defaultHost = \"https://api.explorer.aleo.org/v1\";\nconst keyProvider = new AleoKeyProvider();\nconst programManager = new ProgramManager(\n    defaultHost,\n    keyProvider,\n    undefined\n);\n\nkeyProvider.useCache(true);\n\nlet lastLocalProgram: string = \"\";\n\nexport interface WorkerAPI {\n    executeOffline: (\n        localProgram: string,\n        aleoFunction: string,\n        inputs: string[],\n        privateKey: string\n    ) => Promise<{ outputs: any; execution: string } | string>;\n\n    getPrivateKey: () => Promise<PrivateKey>;\n}\nasync function executeOffline(\n    localProgram: string,\n    aleoFunction: string,\n    inputs: string[],\n    privateKey: string,\n    proveExecution = false\n) {\n    console.log(\"Web worker: Executing function locally...\");\n    const startTime = performance.now();\n\n    try {\n        // Ensure the program is valid and that it contains the function specified\n        const program = programManager.createProgramFromSource(localProgram);\n        if (program instanceof Error) {\n            throw \"Error creating program from source\";\n        }\n        const program_id = program.id();\n        if (!program.hasFunction(aleoFunction)) {\n            throw `Program ${program_id} does not contain function ${aleoFunction}`;\n        }\n        const cacheKey = `${program_id}:${aleoFunction}`;\n\n        // Get the program imports\n        const imports = await programManager.networkClient.getProgramImports(\n            localProgram\n        );\n\n        if (imports instanceof Error) {\n            throw \"Error getting program imports\";\n        }\n        // Get the proving and verifying keys for the function\n        if (lastLocalProgram !== localProgram) {\n            const keys = <FunctionKeyPair>await programManager.synthesizeKeys(\n                localProgram,\n                aleoFunction,\n                inputs,\n                PrivateKey.from_string(privateKey)\n            );\n            programManager.keyProvider.cacheKeys(cacheKey, keys);\n            lastLocalProgram = localProgram;\n        }\n\n        // Pass the cache key to the execute function\n        const keyParams = new AleoKeyProviderParams({\n            cacheKey: cacheKey,\n        });\n\n        // Execute the function locally\n        const response = await programManager.run(\n            localProgram,\n            aleoFunction,\n            inputs,\n            proveExecution,\n            imports,\n            keyParams,\n            undefined,\n            undefined,\n            PrivateKey.from_string(privateKey),\n        );\n\n        // Return the outputs to the main thread\n        console.log(\n            `Web worker: Local execution completed in ${\n                performance.now() - startTime\n            } ms`\n        );\n        const outputs = response.getOutputs();\n        const execution = response.getExecution();\n        let executionString = \"\";\n\n        const keys = keyProvider.getKeys(cacheKey);\n\n        if (keys instanceof Error) {\n            throw \"Could not get verifying key\";\n        }\n\n        const verifyingKey = keys[1];\n\n        if (execution) {\n            verifyFunctionExecution(\n                execution,\n                verifyingKey,\n                program,\n                \"hello\"\n            );\n            executionString = execution.toString();\n            console.log(\"Execution verified successfully: \" + execution);\n        } else {\n            executionString = \"\";\n        }\n\n        console.log(`Function execution response: ${outputs}`);\n\n        return { outputs: outputs, execution: executionString };\n    } catch (error) {\n        console.error(error);\n        return error ? error.toString() : \"Unknown error\";\n    }\n}\n\nasync function getPrivateKey() {\n    const privateKey = new PrivateKey();\n    return privateKey.to_string();\n}\n\nconst workerAPI = { executeOffline, getPrivateKey };\nexpose(workerAPI);\n","export async function get(url: URL | string) {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n        throw new Error(response.status + \" could not get URL \" + url);\n    }\n\n    return response;\n}\n\n\nexport async function post(url: URL | string, options: RequestInit) {\n    options.method = \"POST\";\n\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n        throw new Error(response.status + \" could not post URL \" + url);\n    }\n\n    return response;\n}\n","import { get, post } from \"./utils\";\nimport {\n  Account,\n  Block,\n  RecordCiphertext,\n  Program,\n  RecordPlaintext,\n  PrivateKey,\n  Transaction,\n  TransactionModel,\n  logAndThrow\n} from \"./index\";\n\ntype ProgramImports = { [key: string]: string | Program };\n\n/**\n * Client library that encapsulates REST calls to publicly exposed endpoints of Aleo nodes. The methods provided in this\n * allow users to query public information from the Aleo blockchain and submit transactions to the network.\n *\n * @param {string} host\n * @example\n * // Connection to a local node\n * const localNetworkClient = new AleoNetworkClient(\"http://localhost:3030\");\n *\n * // Connection to a public beacon node\n * const publicnetworkClient = new AleoNetworkClient(\"https://api.explorer.aleo.org/v1\");\n */\nclass AleoNetworkClient {\n  host: string;\n  account: Account | undefined;\n\n  constructor(host: string) {\n    this.host = host + \"/testnet3\";\n  }\n\n  /**\n   * Set an account to use in networkClient calls\n   *\n   * @param {Account} account\n   * @example\n   * const account = new Account();\n   * networkClient.setAccount(account);\n   */\n  setAccount(account: Account) {\n    this.account = account;\n  }\n\n  /**\n   * Return the Aleo account used in the networkClient\n   *\n   * @example\n   * const account = networkClient.getAccount();\n   */\n  getAccount(): Account | undefined {\n    return this.account;\n  }\n\n  /**\n   * Set a new host for the networkClient\n   *\n   * @param {string} host The address of a node hosting the Aleo API\n   * @param host\n   */\n  setHost(host: string) {\n    this.host = host + \"/testnet3\";\n  }\n\n  async fetchData<Type>(\n      url = \"/\",\n  ): Promise<Type> {\n    try {\n      const response = await get(this.host + url);\n      return await response.json();\n    } catch (error) {\n      throw new Error(\"Error fetching data.\");\n    }\n  }\n\n  /**\n   * Attempts to find unspent records in the Aleo blockchain for a specified private key\n   * @param {number} startHeight - The height at which to start searching for unspent records\n   * @param {number} endHeight - The height at which to stop searching for unspent records\n   * @param {string | PrivateKey} privateKey - The private key to use to find unspent records\n   * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])\n   * @param {number} maxMicrocredits - The maximum number of microcredits to search for\n   * @param {string[]} nonces - The nonces of already found records to exclude from the search\n   *\n   * @example\n   * // Find all unspent records\n   * const privateKey = \"[PRIVATE_KEY]\";\n   * const records = networkClient.findUnspentRecords(0, undefined, privateKey);\n   *\n   * // Find specific amounts\n   * const startHeight = 500000;\n   * const amounts = [600000, 1000000];\n   * const records = networkClient.findUnspentRecords(startHeight, undefined, privateKey, amounts);\n   *\n   * // Find specific amounts with a maximum number of cumulative microcredits\n   * const maxMicrocredits = 100000;\n   * const records = networkClient.findUnspentRecords(startHeight, undefined, privateKey, undefined, maxMicrocredits);\n   */\n  async findUnspentRecords(\n      startHeight: number,\n      endHeight: number | undefined,\n      privateKey: string | PrivateKey | undefined,\n      amounts: number[] | undefined,\n      maxMicrocredits?: number | undefined,\n      nonces?: string[] | undefined,\n  ): Promise<Array<RecordPlaintext> | Error> {\n    nonces = nonces || [];\n    // Ensure start height is not negative\n    if (startHeight < 0) {\n      throw new Error(\"Start height must be greater than or equal to 0\");\n    }\n\n    // Initialize search parameters\n    const records = new Array<RecordPlaintext>();\n    let start;\n    let end;\n    let resolvedPrivateKey: PrivateKey;\n    let failures = 0;\n    let totalRecordValue = BigInt(0);\n    let latestHeight: number;\n\n    // Ensure a private key is present to find owned records\n    if (typeof privateKey === \"undefined\") {\n      if (typeof this.account === \"undefined\") {\n        throw new Error(\"Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient\");\n      } else {\n        resolvedPrivateKey = this.account._privateKey;\n      }\n    } else {\n      try {\n        resolvedPrivateKey = privateKey instanceof PrivateKey ? privateKey : PrivateKey.from_string(privateKey);\n      } catch (error) {\n        throw new Error(\"Error parsing private key provided.\");\n      }\n    }\n    const viewKey = resolvedPrivateKey.to_view_key();\n\n    // Get the latest height to ensure the range being searched is valid\n    try {\n      const blockHeight = await this.getLatestHeight();\n      if (typeof blockHeight === \"number\") {\n        latestHeight = blockHeight;\n      } else {\n        throw new Error(\"Error fetching latest block height.\");\n      }\n    } catch (error) {\n      throw new Error(\"Error fetching latest block height.\");\n    }\n\n    // If no end height is specified or is greater than the latest height, set the end height to the latest height\n    if (typeof endHeight === \"number\" && endHeight <= latestHeight) {\n      end = endHeight\n    } else {\n      end = latestHeight;\n    }\n\n    // If the starting is greater than the ending height, return an error\n    if (startHeight > end) {\n      throw new Error(\"Start height must be less than or equal to end height.\");\n    }\n\n    // Iterate through blocks in reverse order in chunks of 50\n    while (end > startHeight) {\n      start = end - 50;\n      if (start < startHeight) {\n        start = startHeight;\n      }\n      try {\n        // Get 50 blocks (or the difference between the start and end if less than 50)\n        const blocks = await this.getBlockRange(start, end);\n        end = start;\n        if (!(blocks instanceof Error)) {\n          // Iterate through blocks to find unspent records\n          for (let i = 0; i < blocks.length; i++) {\n            const block = blocks[i];\n            const transactions = block.transactions;\n            if (!(typeof transactions === \"undefined\")) {\n              for (let j = 0; j < transactions.length; j++) {\n                const confirmedTransaction = transactions[j];\n                // Search for unspent records in execute transactions of credits.aleo\n                if (confirmedTransaction.type == \"execute\") {\n                  const transaction = confirmedTransaction.transaction;\n                  if (transaction.execution && !(typeof transaction.execution.transitions == \"undefined\")) {\n                    for (let k = 0; k < transaction.execution.transitions.length; k++) {\n                      const transition = transaction.execution.transitions[k];\n                      // Only search for unspent records in credits.aleo (for now)\n                      if (transition.program !== \"credits.aleo\") {\n                        continue;\n                      }\n                      if (!(typeof transition.outputs == \"undefined\")) {\n                        for (let l = 0; l < transition.outputs.length; l++) {\n                          const output = transition.outputs[l];\n                          if (output.type === \"record\") {\n                            try {\n                              // Create a wasm record ciphertext object from the found output\n                              const record = RecordCiphertext.fromString(output.value);\n                              // Determine if the record is owned by the specified view key\n                              if (record.isOwner(viewKey)) {\n                                // Decrypt the record and get the serial number\n                                const recordPlaintext = record.decrypt(viewKey);\n\n                                // If the record has already been found, skip it\n                                const nonce = recordPlaintext.nonce();\n                                if (nonces.includes(nonce)) {\n                                  continue;\n                                }\n\n                                // Otherwise record the nonce that has been found\n                                const serialNumber = recordPlaintext.serialNumberString(resolvedPrivateKey, \"credits.aleo\", \"credits\");\n                                // Attempt to see if the serial number is spent\n                                try {\n                                  await this.getTransitionId(serialNumber);\n                                } catch (error) {\n                                  // If it's not found, add it to the list of unspent records\n                                  if (!amounts) {\n                                    records.push(recordPlaintext);\n                                    // If the user specified a maximum number of microcredits, check if the search has found enough\n                                    if (typeof maxMicrocredits === \"number\") {\n                                      totalRecordValue += recordPlaintext.microcredits();\n                                      // Exit if the search has found the amount specified\n                                      if (totalRecordValue >= BigInt(maxMicrocredits)) {\n                                        return records;\n                                      }\n                                    }\n                                  }\n                                  // If the user specified a list of amounts, check if the search has found them\n                                  if (!(typeof amounts === \"undefined\") && amounts.length > 0) {\n                                    let amounts_found = 0;\n                                    if (recordPlaintext.microcredits() > amounts[amounts_found]) {\n                                        amounts_found += 1;\n                                        records.push(recordPlaintext);\n                                        // If the user specified a maximum number of microcredits, check if the search has found enough\n                                        if (typeof maxMicrocredits === \"number\") {\n                                          totalRecordValue += recordPlaintext.microcredits();\n                                          // Exit if the search has found the amount specified\n                                          if (totalRecordValue >= BigInt(maxMicrocredits)) {\n                                            return records;\n                                          }\n                                        }\n                                        if (records.length >= amounts.length) {\n                                          return records;\n                                        }\n                                    }\n                                  }\n                                }\n                              }\n                            } catch (error) {\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (error) {\n        // If there is an error fetching blocks, log it and keep searching\n        console.warn(\"Error fetching blocks in range: \" + start.toString() + \"-\" + end.toString());\n        console.warn(\"Error: \", error);\n        failures += 1;\n        if (failures > 10) {\n          console.warn(\"10 failures fetching records reached. Returning records fetched so far\");\n          return records;\n        }\n      }\n    }\n    return records;\n  }\n\n  /**\n   * Returns the contents of the block at the specified block height\n   *\n   * @param {number} height\n   * @example\n   * const block = networkClient.getBlock(1234);\n   */\n  async getBlock(height: number): Promise<Block | Error> {\n    try {\n      const block = await this.fetchData<Block>(\"/block/\" + height);\n      return block;\n    } catch (error) {\n      throw new Error(\"Error fetching block.\");\n    }\n  }\n\n  /**\n   * Returns a range of blocks between the specified block heights\n   *\n   * @param {number} start\n   * @param {number} end\n   * @example\n   * const blockRange = networkClient.getBlockRange(2050, 2100);\n   */\n  async getBlockRange(start: number, end: number): Promise<Array<Block> | Error> {\n    try {\n      return await this.fetchData<Array<Block>>(\"/blocks?start=\" + start + \"&end=\" + end);\n    } catch (error) {\n      const errorMessage = \"Error fetching blocks between \" + start + \" and \" + end + \".\"\n      throw new Error(errorMessage);\n    }\n  }\n\n  /**\n   * Returns the deployment transaction id associated with the specified program\n   *\n   * @param {Program | string} program\n   * @returns {TransactionModel | Error}\n   */\n  async getDeploymentTransactionIDForProgram(program: Program | string): Promise<string | Error> {\n    if (program instanceof Program) {\n      program = program.toString();\n    }\n    try {\n      const id = await this.fetchData<string>(\"/find/transactionID/deployment/\" + program);\n      return id.replace(\"\\\"\", \"\")\n    } catch (error) {\n      throw new Error(\"Error fetching deployment transaction for program.\");\n    }\n  }\n\n  /**\n   * Returns the deployment transaction associated with a specified program\n   *\n   * @param {Program | string} program\n   * @returns {TransactionModel | Error}\n   */\n  async getDeploymentTransactionForProgram(program: Program | string): Promise<TransactionModel | Error> {\n    try {\n      const transaction_id = <string>await this.getDeploymentTransactionIDForProgram(program);\n      return <TransactionModel>await this.getTransaction(transaction_id);\n    } catch (error) {\n      throw new Error(\"Error fetching deployment transaction for program.\");\n    }\n  }\n\n  /**\n   * Returns the contents of the latest block\n   *\n   * @example\n   * const latestHeight = networkClient.getLatestBlock();\n   */\n  async getLatestBlock(): Promise<Block | Error> {\n    try {\n      return await this.fetchData<Block>(\"/latest/block\") as Block;\n    } catch (error) {\n      throw new Error(\"Error fetching latest block.\");\n    }\n  }\n\n  /**\n   * Returns the latest committee\n   *\n   * @returns {Promise<object>} A javascript object containing the latest committee\n   */\n  async getLatestCommittee(): Promise<object | Error> {\n    try {\n      return await this.fetchData<object>(\"/committee/latest\");\n    } catch (error) {\n      throw new Error(\"Error fetching latest block.\");\n    }\n  }\n\n  /**\n   * Returns the latest block height\n   *\n   * @example\n   * const latestHeight = networkClient.getLatestHeight();\n   */\n  async getLatestHeight(): Promise<number | Error> {\n    try {\n      return await this.fetchData<number>(\"/latest/height\");\n    } catch (error) {\n      throw new Error(\"Error fetching latest height.\");\n    }\n  }\n\n  /**\n   * Returns the source code of a program given a program ID\n   *\n   * @param {string} programId The program ID of a program deployed to the Aleo Network\n   * @return {Promise<string>} Source code of the program\n   *\n   * @example\n   * const program = networkClient.getProgram(\"hello_hello.aleo\");\n   * const expectedSource = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n   * assert.equal(program, expectedSource);\n   */\n  async getProgram(programId: string): Promise<string | Error> {\n    try {\n      return await this.fetchData<string>(\"/program/\" + programId)\n    } catch (error) {\n      throw new Error(\"Error fetching program\");\n    }\n  }\n\n  /**\n   * Returns a program object from a program ID or program source code\n   *\n   * @param {string} inputProgram The program ID or program source code of a program deployed to the Aleo Network\n   * @return {Promise<Program | Error>} Source code of the program\n   *\n   * @example\n   * const programID = \"hello_hello.aleo\";\n   * const programSource = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n   *\n   * // Get program object from program ID or program source code\n   * const programObjectFromID = await networkClient.getProgramObject(programID);\n   * const programObjectFromSource = await networkClient.getProgramObject(programSource);\n   *\n   * // Both program objects should be equal\n   * assert.equal(programObjectFromID.to_string(), programObjectFromSource.to_string());\n   */\n  async getProgramObject(inputProgram: string): Promise<Program | Error> {\n    try {\n      return Program.fromString(inputProgram);\n    } catch (error) {\n      try {\n        return Program.fromString(<string>(await this.getProgram(inputProgram)));\n      } catch (error) {\n        throw new Error(`${inputProgram} is neither a program name or a valid program`);\n      }\n    }\n  }\n\n  /**\n   *  Returns an object containing the source code of a program and the source code of all programs it imports\n   *\n   * @param {Program | string} inputProgram The program ID or program source code of a program deployed to the Aleo Network\n   * @returns {Promise<ProgramImports>} Object of the form { \"program_id\": \"program_source\", .. } containing program id & source code for all program imports\n   *\n   * @example\n   * const double_test_source = \"import multiply_test.aleo;\\n\\nprogram double_test.aleo;\\n\\nfunction double_it:\\n    input r0 as u32.private;\\n    call multiply_test.aleo/multiply 2u32 r0 into r1;\\n    output r1 as u32.private;\\n\"\n   * const double_test = Program.fromString(double_test_source);\n   * const expectedImports = {\n   *     \"multiply_test.aleo\": \"program multiply_test.aleo;\\n\\nfunction multiply:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    mul r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n   * }\n   *\n   * // Imports can be fetched using the program ID, source code, or program object\n   * let programImports = await networkClient.getProgramImports(\"double_test.aleo\");\n   * assert.deepStrictEqual(programImports, expectedImports);\n   *\n   * // Using the program source code\n   * programImports = await networkClient.getProgramImports(double_test_source);\n   * assert.deepStrictEqual(programImports, expectedImports);\n   *\n   * // Using the program object\n   * programImports = await networkClient.getProgramImports(double_test);\n   * assert.deepStrictEqual(programImports, expectedImports);\n   */\n  async getProgramImports(inputProgram: Program | string): Promise<ProgramImports | Error> {\n    try {\n      const imports: ProgramImports = {};\n\n      // Get the program object or fail if the program is not valid or does not exist\n      const program = inputProgram instanceof Program ? inputProgram : <Program>(await this.getProgramObject(inputProgram));\n\n      // Get the list of programs that the program imports\n      const importList = program.getImports();\n\n      // Recursively get any imports that the imported programs have in a depth first search order\n      for (let i = 0; i < importList.length; i++) {\n        const import_id = importList[i];\n        if (!imports.hasOwnProperty(import_id)) {\n          const programSource = <string>await this.getProgram(import_id);\n          const nestedImports = <ProgramImports>await this.getProgramImports(import_id);\n          for (const key in nestedImports) {\n            if (!imports.hasOwnProperty(key)) {\n              imports[key] = nestedImports[key];\n            }\n          }\n          imports[import_id] = programSource;\n        }\n      }\n      return imports;\n    } catch (error) {\n      throw logAndThrow(\"Error fetching program imports: \" + error)\n    }\n  }\n\n  /**\n   * Get a list of the program names that a program imports\n   *\n   * @param {Program | string} inputProgram - The program id or program source code to get the imports of\n   * @returns {string[]} - The list of program names that the program imports\n   *\n   * @example\n   * const programImportsNames = networkClient.getProgramImports(\"double_test.aleo\");\n   * const expectedImportsNames = [\"multiply_test.aleo\"];\n   * assert.deepStrictEqual(programImportsNames, expectedImportsNames);\n   */\n  async getProgramImportNames(inputProgram: Program | string): Promise<string[] | Error> {\n    try {\n      const program = inputProgram instanceof Program ? inputProgram : <Program>(await this.getProgramObject(inputProgram));\n      return program.getImports();\n    } catch (error) {\n      throw new Error(\"Error fetching program imports with error: \" + error);\n    }\n  }\n\n  /**\n   * Returns the names of the mappings of a program\n   *\n   * @param {string} programId - The program ID to get the mappings of (e.g. \"credits.aleo\")\n   * @example\n   * const mappings = networkClient.getProgramMappingNames(\"credits.aleo\");\n   * const expectedMappings = [\"account\"];\n   * assert.deepStrictEqual(mappings, expectedMappings);\n   */\n  async getProgramMappingNames(programId: string): Promise<Array<string> | Error> {\n    try {\n      return await this.fetchData<Array<string>>(\"/program/\" + programId + \"/mappings\")\n    } catch (error) {\n      throw new Error(\"Error fetching program mappings - ensure the program exists on chain before trying again\");\n    }\n  }\n\n  /**\n   * Returns the value of a program's mapping for a specific key\n   *\n   * @param {string} programId - The program ID to get the mapping value of (e.g. \"credits.aleo\")\n   * @param {string} mappingName - The name of the mapping to get the value of (e.g. \"account\")\n   * @param {string} key - The key of the mapping to get the value of (e.g. \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\")\n   * @return {Promise<string>} String representation of the value of the mapping\n   *\n   * @example\n   * // Get public balance of an account\n   * const mappingValue = networkClient.getMappingValue(\"credits.aleo\", \"account\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\");\n   * const expectedValue = \"0u64\";\n   * assert.equal(mappingValue, expectedValue);\n   */\n  async getProgramMappingValue(programId: string, mappingName: string, key: string): Promise<string | Error> {\n    try {\n      return await this.fetchData<string>(\"/program/\" + programId + \"/mapping/\" + mappingName + \"/\" + key)\n    } catch (error) {\n      throw new Error(\"Error fetching mapping value - ensure the mapping exists and the key is correct\");\n    }\n  }\n\n  /**\n   * Returns the latest state/merkle root of the Aleo blockchain\n   *\n   * @example\n   * const stateRoot = networkClient.getStateRoot();\n   */\n  async getStateRoot(): Promise<string | Error> {\n    try {\n      return await this.fetchData<string>(\"/latest/stateRoot\");\n    } catch (error) {\n      throw new Error(\"Error fetching Aleo state root\");\n    }\n  }\n\n  /**\n   * Returns a transaction by its unique identifier\n   *\n   * @param {string} id\n   * @example\n   * const transaction = networkClient.getTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n   */\n  async getTransaction(id: string): Promise<TransactionModel | Error> {\n    try {\n      return await this.fetchData<TransactionModel>(\"/transaction/\" + id);\n    } catch (error) {\n      throw new Error(\"Error fetching transaction.\");\n    }\n\n  }\n\n  /**\n   * Returns the transactions present at the specified block height\n   *\n   * @param {number} height\n   * @example\n   * const transactions = networkClient.getTransactions(654);\n   */\n  async getTransactions(height: number): Promise<Array<TransactionModel> | Error> {\n    try {\n      return await this.fetchData<Array<TransactionModel>>(\"/block/\" + height.toString() + \"/transactions\");\n    } catch (error) {\n      throw new Error(\"Error fetching transactions.\");\n    }\n  }\n\n  /**\n   * Returns the transactions in the memory pool.\n   *\n   * @example\n   * const transactions = networkClient.getTransactionsInMempool();\n   */\n  async getTransactionsInMempool(): Promise<Array<TransactionModel> | Error> {\n    try {\n      return await this.fetchData<Array<TransactionModel>>(\"/memoryPool/transactions\");\n    } catch (error) {\n      throw new Error(\"Error fetching transactions from mempool.\");\n    }\n  }\n\n  /**\n   * Returns the transition ID of the transition corresponding to the ID of the input or output.\n   * @param {string} inputOrOutputID - ID of the input or output.\n   *\n   * @example\n   * const transitionId = networkClient.getTransitionId(\"2429232855236830926144356377868449890830704336664550203176918782554219952323field\");\n   */\n  async getTransitionId(inputOrOutputID: string): Promise<string | Error> {\n    try {\n      return await this.fetchData<string>(\"/find/transitionID/\" + inputOrOutputID);\n    } catch (error) {\n      throw new Error(\"Error fetching transition ID.\");\n    }\n  }\n\n  /**\n   * Submit an execute or deployment transaction to the Aleo network\n   *\n   * @param {Transaction | string} transaction  - The transaction to submit to the network\n   * @returns {string | Error} - The transaction id of the submitted transaction or the resulting error\n   */\n  async submitTransaction(transaction: Transaction | string): Promise<string | Error> {\n    const transaction_string = transaction instanceof Transaction ? transaction.toString() : transaction;\n    try {\n      const response = await post(this.host + \"/transaction/broadcast\", {\n        body: transaction_string,\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      });\n\n      try {\n        return await response.json();\n\n      } catch (error) {\n        throw new Error(`Error posting transaction. Aleo network response: ${(error as Error).message}`);\n      }\n    } catch (error) {\n      throw new Error(`Error posting transaction: No response received: ${(error as Error).message}`);\n    }\n  }\n}\n\nexport { AleoNetworkClient, ProgramImports }\n","import { ProvingKey, VerifyingKey, CREDITS_PROGRAM_KEYS, KEY_STORE, PRIVATE_TRANSFER, PRIVATE_TO_PUBLIC_TRANSFER, PUBLIC_TRANSFER, PUBLIC_TO_PRIVATE_TRANSFER} from \"./index\";\nimport { get } from \"./utils\";\n\ntype FunctionKeyPair = [ProvingKey, VerifyingKey];\ntype CachedKeyPair = [Uint8Array, Uint8Array];\ntype AleoKeyProviderInitParams = {\n    proverUri?: string;\n    verifierUri?: string;\n    cacheKey?: string;\n};\n\n/**\n * Interface for record search parameters. This allows for arbitrary search parameters to be passed to record provider\n * implementations.\n */\ninterface KeySearchParams {\n    [key: string]: any; // This allows for arbitrary keys with any type values\n}\n\n/**\n * AleoKeyProviderParams search parameter for the AleoKeyProvider. It allows for the specification of a proverUri and\n * verifierUri to fetch keys via HTTP from a remote resource as well as a unique cacheKey to store the keys in memory.\n */\nclass AleoKeyProviderParams implements KeySearchParams {\n    proverUri: string | undefined;\n    verifierUri: string | undefined;\n    cacheKey: string | undefined;\n\n    /**\n     * Create a new AleoKeyProviderParams object which implements the KeySearchParams interface. Users can optionally\n     * specify a url for the proverUri & verifierUri to fetch keys via HTTP from a remote resource as well as a unique\n     * cacheKey to store the keys in memory for future use. If no proverUri or verifierUri is specified, a cachekey must\n     * be provided.\n     *\n     * @param { AleoKeyProviderInitParams } params - Optional search parameters\n     */\n    constructor(params: {proverUri?: string, verifierUri?: string, cacheKey?: string}) {\n        this.proverUri = params.proverUri;\n        this.verifierUri = params.verifierUri;\n        this.cacheKey = params.cacheKey;\n    }\n}\n\n/**\n * KeyProvider interface. Enables the retrieval of public proving and verifying keys for Aleo Programs.\n */\ninterface FunctionKeyProvider {\n    /**\n     * Get bond_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the bond_public function\n     */\n    bondPublicKeys(): Promise<FunctionKeyPair | Error>;\n\n\n    /**\n     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId\n     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.\n     *\n     * @param {string} keyId access key for the cache\n     * @param {FunctionKeyPair} keys keys to cache\n     */\n    cacheKeys(keyId: string, keys: FunctionKeyPair): void;\n\n    /**\n     * Get unbond_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the unbond_public function\n     */\n    claimUnbondPublicKeys(): Promise<FunctionKeyPair | Error>;\n\n    /**\n     * Get arbitrary function keys from a provider\n     *\n     * @param {KeySearchParams | undefined} params - Optional search parameters for the key provider\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * // Create a search object which implements the KeySearchParams interface\n     * class IndexDbSearch implements KeySearchParams {\n     *     db: string\n     *     keyId: string\n     *     constructor(params: {db: string, keyId: string}) {\n     *         this.db = params.db;\n     *         this.keyId = params.keyId;\n     *     }\n     * }\n     *\n     * // Create a new object which implements the KeyProvider interface\n     * class IndexDbKeyProvider implements FunctionKeyProvider {\n     *     async functionKeys(params: KeySearchParams): Promise<FunctionKeyPair | Error> {\n     *         return new Promise((resolve, reject) => {\n     *             const request = indexedDB.open(params.db, 1);\n     *\n     *             request.onupgradeneeded = function(e) {\n     *                 const db = e.target.result;\n     *                 if (!db.objectStoreNames.contains('keys')) {\n     *                     db.createObjectStore('keys', { keyPath: 'id' });\n     *                 }\n     *             };\n     *\n     *             request.onsuccess = function(e) {\n     *                 const db = e.target.result;\n     *                 const transaction = db.transaction([\"keys\"], \"readonly\");\n     *                 const store = transaction.objectStore(\"keys\");\n     *                 const request = store.get(params.keyId);\n     *                 request.onsuccess = function(e) {\n     *                     if (request.result) {\n     *                         resolve(request.result as FunctionKeyPair);\n     *                     } else {\n     *                         reject(new Error(\"Key not found\"));\n     *                     }\n     *                 };\n     *                 request.onerror = function(e) { reject(new Error(\"Error fetching key\")); };\n     *             };\n     *\n     *             request.onerror = function(e) { reject(new Error(\"Error opening database\")); };\n     *         });\n     *     }\n     *\n     *     // implement the other methods...\n     * }\n     *\n     *\n     * const keyProvider = new AleoKeyProvider();\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.aleo.org/v1\");\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.aleo.org/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const searchParams = new IndexDbSearch({db: \"keys\", keyId: \"credits.aleo:transferPrivate\"});\n     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.functionKeys(searchParams);\n     */\n    functionKeys(params?: KeySearchParams): Promise<FunctionKeyPair | Error>;\n\n    /**\n     * Get fee_private function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the join function\n     */\n    feePrivateKeys(): Promise<FunctionKeyPair | Error>;\n\n    /**\n     * Get fee_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the join function\n     */\n    feePublicKeys(): Promise<FunctionKeyPair | Error>;\n\n    /**\n     * Get join function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the join function\n     */\n    joinKeys(): Promise<FunctionKeyPair | Error>;\n\n    /**\n     * Get split function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the join function\n     */\n    splitKeys(): Promise<FunctionKeyPair | Error>;\n\n    /**\n     * Get keys for a variant of the transfer function from the credits.aleo program\n     *\n     * @param {string} visibility Visibility of the transfer function (private, public, privateToPublic, publicToPrivate)\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the specified transfer function\n     *\n     * @example\n     * // Create a new object which implements the KeyProvider interface\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.aleo.org/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.aleo.org/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys(\"public\");\n     */\n    transferKeys(visibility: string): Promise<FunctionKeyPair | Error>;\n\n    /**\n     * Get unbond_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the join function\n     */\n    unBondPublicKeys(): Promise<FunctionKeyPair | Error>;\n\n}\n\n\n/**\n * AleoKeyProvider class. Implements the KeyProvider interface. Enables the retrieval of Aleo program proving and\n * verifying keys for the credits.aleo program over http from official Aleo sources and storing and retrieving function\n * keys from a local memory cache.\n */\nclass AleoKeyProvider implements FunctionKeyProvider {\n    cache: Map<string, CachedKeyPair>;\n    cacheOption: boolean;\n    keyUris: string;\n\n    async fetchBytes(\n        url = \"/\",\n    ): Promise<Uint8Array> {\n        try {\n            const response = await get(url);\n            const data = await response.arrayBuffer();\n            return new Uint8Array(data);\n        } catch (error) {\n            throw new Error(\"Error fetching data.\" + error);\n        }\n    }\n\n    constructor() {\n        this.keyUris = KEY_STORE;\n        this.cache = new Map<string, CachedKeyPair>();\n        this.cacheOption = false;\n    }\n\n    /**\n     * Use local memory to store keys\n     *\n     * @param {boolean} useCache whether to store keys in local memory\n     */\n    useCache(useCache: boolean) {\n        this.cacheOption = useCache;\n    }\n\n    /**\n     * Clear the key cache\n     */\n    clearCache() {\n        this.cache.clear();\n    }\n\n    /**\n     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId\n     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.\n     *\n     * @param {string} keyId access key for the cache\n     * @param {FunctionKeyPair} keys keys to cache\n     */\n    cacheKeys(keyId: string, keys: FunctionKeyPair) {\n        const [provingKey, verifyingKey] = keys;\n        this.cache.set(keyId, [provingKey.toBytes(), verifyingKey.toBytes()]);\n    }\n\n    /**\n     * Determine if a keyId exists in the cache\n     *\n     * @param {string} keyId keyId of a proving and verifying key pair\n     * @returns {boolean} true if the keyId exists in the cache, false otherwise\n     */\n    containsKeys(keyId: string): boolean {\n        return this.cache.has(keyId)\n    }\n\n    /**\n     * Delete a set of keys from the cache\n     *\n     * @param {string} keyId keyId of a proving and verifying key pair to delete from memory\n     * @returns {boolean} true if the keyId exists in the cache and was deleted, false if the key did not exist\n     */\n    deleteKeys(keyId: string): boolean {\n        return this.cache.delete(keyId)\n    }\n\n    /**\n     * Get a set of keys from the cache\n     * @param keyId keyId of a proving and verifying key pair\n     *\n     * @returns {FunctionKeyPair | Error} Proving and verifying keys for the specified program\n     */\n    getKeys(keyId: string): FunctionKeyPair | Error {\n        console.debug(`Checking if key exists in cache. KeyId: ${keyId}`)\n        if (this.cache.has(keyId)) {\n            const [provingKeyBytes, verifyingKeyBytes] = <CachedKeyPair>this.cache.get(keyId);\n            return [ProvingKey.fromBytes(provingKeyBytes), VerifyingKey.fromBytes(verifyingKeyBytes)];\n        } else {\n            return new Error(\"Key not found in cache.\");\n        }\n    }\n\n    /**\n     * Get arbitrary function keys from a provider\n     *\n     * @param {KeySearchParams} params parameters for the key search in form of: {proverUri: string, verifierUri: string, cacheKey: string}\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * // Create a new object which implements the KeyProvider interface\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.aleo.org/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * const AleoProviderParams = new AleoProviderParams(\"https://testnet3.parameters.aleo.org/transfer_private.\");\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.aleo.org/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually using the key provider\n     * const keySearchParams = { \"cacheKey\": \"myProgram:myFunction\" };\n     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.functionKeys(keySearchParams);\n     */\n    async functionKeys(params?: KeySearchParams): Promise<FunctionKeyPair | Error> {\n        if (params) {\n            let proverUrl;\n            let verifierUrl;\n            let cacheKey;\n            if (\"proverUri\" in params && typeof params[\"proverUri\"] == \"string\") {\n                proverUrl = params[\"proverUri\"];\n            }\n\n            if (\"verifierUri\" in params && typeof params[\"verifierUri\"] == \"string\") {\n                verifierUrl = params[\"verifierUri\"];\n            }\n\n            if (\"cacheKey\" in params && typeof params[\"cacheKey\"] == \"string\") {\n                cacheKey = params[\"cacheKey\"];\n            }\n\n            if (proverUrl && verifierUrl) {\n                return await this.fetchKeys(proverUrl, verifierUrl, cacheKey);\n            }\n\n            if (cacheKey) {\n                return this.getKeys(cacheKey);\n            }\n        }\n        throw Error(\"Invalid parameters provided, must provide either a cacheKey and/or a proverUrl and a verifierUrl\");\n    }\n\n    /**\n     * Returns the proving and verifying keys for a specified program from a specified url.\n     *\n     * @param {string} verifierUrl Url of the proving key\n     * @param {string} proverUrl Url the verifying key\n     * @param {string} cacheKey Key to store the keys in the cache\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * // Create a new AleoKeyProvider object\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.aleo.org/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://vm.aleo.org/api\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.fetchKeys(\"https://testnet3.parameters.aleo.org/transfer_private.prover.2a9a6f2\", \"https://testnet3.parameters.aleo.org/transfer_private.verifier.3a59762\");\n     */\n    async fetchKeys(proverUrl: string, verifierUrl: string, cacheKey?: string): Promise<FunctionKeyPair | Error> {\n        try {\n            // If cache is enabled, check if the keys have already been fetched and return them if they have\n            if (this.cacheOption) {\n                if (!cacheKey) {\n                    cacheKey = proverUrl;\n                }\n                const value = this.cache.get(cacheKey);\n                if (typeof value !== \"undefined\") {\n                    return [ProvingKey.fromBytes(value[0]), VerifyingKey.fromBytes(value[1])];\n                } else {\n                    console.debug(\"Fetching proving keys from url \" + proverUrl);\n                    const provingKey = <ProvingKey>ProvingKey.fromBytes(await this.fetchBytes(proverUrl))\n                    console.debug(\"Fetching verifying keys \" + verifierUrl);\n                    const verifyingKey = <VerifyingKey>(await this.getVerifyingKey(verifierUrl));\n                    this.cache.set(cacheKey, [provingKey.toBytes(), verifyingKey.toBytes()]);\n                    return [provingKey, verifyingKey];\n                }\n            }\n            else {\n                // If cache is disabled, fetch the keys and return them\n                const provingKey = <ProvingKey>ProvingKey.fromBytes(await this.fetchBytes(proverUrl))\n                const verifyingKey = <VerifyingKey>(await this.getVerifyingKey(verifierUrl));\n                return [provingKey, verifyingKey];\n            }\n        } catch (error) {\n            throw new Error(`Error: ${error} fetching fee proving and verifying keys from ${proverUrl} and ${verifierUrl}.`);\n        }\n    }\n\n    bondPublicKeys(): Promise<FunctionKeyPair | Error> {\n        return this.fetchKeys(CREDITS_PROGRAM_KEYS.bond_public.prover, CREDITS_PROGRAM_KEYS.bond_public.verifier, CREDITS_PROGRAM_KEYS.bond_public.locator)\n    }\n\n    claimUnbondPublicKeys(): Promise<FunctionKeyPair | Error> {\n        return this.fetchKeys(CREDITS_PROGRAM_KEYS.claim_unbond_public.prover, CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier, CREDITS_PROGRAM_KEYS.claim_unbond_public.locator)\n    }\n\n    /**\n     * Returns the proving and verifying keys for the transfer functions in the credits.aleo program\n     * @param {string} visibility Visibility of the transfer function\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the transfer functions\n     *\n     * @example\n     * // Create a new AleoKeyProvider\n     * const networkClient = new AleoNetworkClient(\"https://vm.aleo.org/api\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://vm.aleo.org/api\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys(\"public\");\n     */\n    async transferKeys(visibility: string): Promise<FunctionKeyPair | Error> {\n        if (PRIVATE_TRANSFER.has(visibility)) {\n            return await this.fetchKeys(CREDITS_PROGRAM_KEYS.transfer_private.prover, CREDITS_PROGRAM_KEYS.transfer_private.verifier, CREDITS_PROGRAM_KEYS.transfer_private.locator);\n        } else if (PRIVATE_TO_PUBLIC_TRANSFER.has(visibility)) {\n            return await this.fetchKeys(CREDITS_PROGRAM_KEYS.transfer_private_to_public.prover, CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifier, CREDITS_PROGRAM_KEYS.transfer_private_to_public.locator);\n        } else if (PUBLIC_TRANSFER.has(visibility)) {\n            return await this.fetchKeys(CREDITS_PROGRAM_KEYS.transfer_public.prover, CREDITS_PROGRAM_KEYS.transfer_public.verifier, CREDITS_PROGRAM_KEYS.transfer_public.locator);\n        } else if (PUBLIC_TO_PRIVATE_TRANSFER.has(visibility)) {\n            return await this.fetchKeys(CREDITS_PROGRAM_KEYS.transfer_public_to_private.prover, CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifier, CREDITS_PROGRAM_KEYS.transfer_public_to_private.locator);\n        } else {\n            throw new Error(\"Invalid visibility type\");\n        }\n    }\n\n    /**\n     * Returns the proving and verifying keys for the join function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the join function\n     */\n    async joinKeys(): Promise<FunctionKeyPair | Error> {\n        return await this.fetchKeys(CREDITS_PROGRAM_KEYS.join.prover, CREDITS_PROGRAM_KEYS.join.verifier, CREDITS_PROGRAM_KEYS.join.locator);\n    }\n\n    /**\n     * Returns the proving and verifying keys for the split function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the split function\n     * */\n    async splitKeys(): Promise<FunctionKeyPair | Error> {\n        return await this.fetchKeys(CREDITS_PROGRAM_KEYS.split.prover, CREDITS_PROGRAM_KEYS.split.verifier, CREDITS_PROGRAM_KEYS.split.locator);\n    }\n\n    /**\n     * Returns the proving and verifying keys for the fee_private function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the fee function\n     */\n    async feePrivateKeys(): Promise<FunctionKeyPair | Error> {\n        return await this.fetchKeys(CREDITS_PROGRAM_KEYS.fee_private.prover, CREDITS_PROGRAM_KEYS.fee_private.verifier, CREDITS_PROGRAM_KEYS.fee_private.locator);\n    }\n\n    /**\n     * Returns the proving and verifying keys for the fee_public function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the fee function\n     */\n    async feePublicKeys(): Promise<FunctionKeyPair | Error> {\n        return await this.fetchKeys(CREDITS_PROGRAM_KEYS.fee_public.prover, CREDITS_PROGRAM_KEYS.fee_public.verifier, CREDITS_PROGRAM_KEYS.fee_public.locator);\n    }\n\n    /**\n     * Gets a verifying key. If the verifying key is for a credits.aleo function, get it from the wasm cache otherwise\n     *\n     * @returns {Promise<VerifyingKey | Error>} Verifying key for the function\n     */\n    // attempt to fetch it from the network\n    async getVerifyingKey(verifierUri: string): Promise<VerifyingKey | Error> {\n        switch (verifierUri) {\n            case CREDITS_PROGRAM_KEYS.bond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.bond_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.claim_unbond_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.fee_private.verifier:\n                return CREDITS_PROGRAM_KEYS.fee_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.fee_public.verifier:\n                return CREDITS_PROGRAM_KEYS.fee_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.inclusion.verifier:\n                return CREDITS_PROGRAM_KEYS.inclusion.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.join.verifier:\n                return CREDITS_PROGRAM_KEYS.join.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.set_validator_state.verifier:\n                return CREDITS_PROGRAM_KEYS.set_validator_state.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.split.verifier:\n                return CREDITS_PROGRAM_KEYS.split.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_private.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_public.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.unbond_delegator_as_validator.verifier:\n                return CREDITS_PROGRAM_KEYS.unbond_delegator_as_validator.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.unbond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.unbond_public.verifyingKey();\n            default:\n                try {\n                    /// Try to fetch the verifying key from the network as a string\n                    const response = await get(verifierUri);\n                    const text = await response.text();\n                    return <VerifyingKey>VerifyingKey.fromString(text);\n                } catch (e) {\n                    /// If that fails, try to fetch the verifying key from the network as bytes\n                    try {\n                        return <VerifyingKey>VerifyingKey.fromBytes(await this.fetchBytes(verifierUri));\n                    } catch (inner) {\n                        return new Error(\"Invalid verifying key. Error: \" + inner);\n                    }\n                }\n        }\n    }\n\n    unBondPublicKeys(): Promise<FunctionKeyPair | Error> {\n        return this.fetchKeys(CREDITS_PROGRAM_KEYS.unbond_public.prover, CREDITS_PROGRAM_KEYS.unbond_public.verifier, CREDITS_PROGRAM_KEYS.unbond_public.locator);\n    }\n}\n\nexport {AleoKeyProvider, AleoKeyProviderParams, AleoKeyProviderInitParams, CachedKeyPair, FunctionKeyPair, FunctionKeyProvider, KeySearchParams}\n","import {\n    Account,\n    AleoKeyProvider,\n    AleoNetworkClient,\n    ExecutionResponse,\n    FunctionKeyProvider,\n    FunctionKeyPair,\n    OfflineQuery,\n    KeySearchParams,\n    RecordPlaintext,\n    RecordProvider,\n    RecordSearchParams,\n    PrivateKey,\n    Program,\n    ProgramImports,\n    ProvingKey,\n    VerifyingKey,\n    Transaction,\n    PRIVATE_TRANSFER_TYPES,\n    VALID_TRANSFER_TYPES,\n    logAndThrow,\n    ProgramManagerBase as WasmProgramManager, verifyFunctionExecution, AleoKeyProviderParams, CREDITS_PROGRAM_KEYS,\n} from \"./index\";\nimport {Execution} from \"@aleohq/wasm/dist/crates/aleo_wasm\";\n\n// TODO put this somewhere where it makes more sense\ninterface ExecutionParams {\n    programName?: string;\n    functionName?: string;\n    fee?: number;\n    privateFee?: boolean;\n    recordSearchParams?: any;\n    keySearchParams?: any;\n    feeRecord?: any;\n    provingKey?: any;\n    verifyingKey?: any;\n    privateKey?: any;\n}\ninterface OfflineParams {\n    offlineQuery?: OfflineQuery\n}\ninterface Options {\n    offlineParams?: OfflineParams;\n    executionParams?: ExecutionParams;\n}\n\n/**\n * The ProgramManager class is used to execute and deploy programs on the Aleo network and create value transfers.\n */\nclass ProgramManager {\n    account: Account | undefined;\n    keyProvider: FunctionKeyProvider;\n    host: string;\n    networkClient: AleoNetworkClient;\n    recordProvider: RecordProvider | undefined;\n\n    /** Create a new instance of the ProgramManager\n     *\n     * @param { string | undefined } host A host uri running the official Aleo API\n     * @param { FunctionKeyProvider | undefined } keyProvider A key provider that implements {@link FunctionKeyProvider} interface\n     * @param { RecordProvider | undefined } recordProvider A record provider that implements {@link RecordProvider} interface\n     */\n    constructor(host?: string | undefined, keyProvider?: FunctionKeyProvider | undefined, recordProvider?: RecordProvider | undefined) {\n        if (!host) {\n            this.host = \"https://api.explorer.aleo.org/v1\";\n            this.networkClient = new AleoNetworkClient(this.host);\n        } else {\n            this.host = host;\n            this.networkClient = new AleoNetworkClient(host);\n        }\n\n        if (!keyProvider) {\n            this.keyProvider = new AleoKeyProvider();\n        } else {\n            this.keyProvider = keyProvider;\n        }\n\n        this.recordProvider = recordProvider;\n    }\n\n    /**\n     * Set the account to use for transaction submission to the Aleo network\n     *\n     * @param {Account} account Account to use for transaction submission\n     */\n    setAccount(account: Account) {\n        this.account = account;\n    }\n\n    /**\n     * Set the key provider that provides the proving and verifying keys for programs\n     *\n     * @param {FunctionKeyProvider} keyProvider\n     */\n    setKeyProvider(keyProvider: FunctionKeyProvider) {\n        this.keyProvider = keyProvider;\n    }\n\n    /**\n     * Set the host peer to use for transaction submission to the Aleo network\n     *\n     * @param host {string} Peer url to use for transaction submission\n     */\n    setHost(host: string) {\n        this.host = host;\n        this.networkClient.setHost(host);\n    }\n\n    /**\n     * Set the record provider that provides records for transactions\n     *\n     * @param {RecordProvider} recordProvider\n     */\n    setRecordProvider(recordProvider: RecordProvider) {\n        this.recordProvider = recordProvider;\n    }\n\n    /**\n     * Deploy an Aleo program to the Aleo network\n     *\n     * @param {string} program Program source code\n     * @param {number} fee Fee to pay for the transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to use\n     * pay the deployment fee\n     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @returns {string | Error} The transaction id of the deployed program or a failure message from the network\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.aleo.org/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for deployments\n     * const program = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\";\n     * const programManager = new ProgramManager(\"https://api.explorer.aleo.org/v1\", keyProvider, recordProvider);\n     *\n     * // Define a fee in credits\n     * const fee = 1.2;\n     *\n     * // Deploy the program\n     * const tx_id = await programManager.deploy(program, fee);\n     *\n     * // Verify the transaction was successful\n     * const transaction = await programManager.networkClient.getTransaction(tx_id);\n     */\n    async deploy(\n        program: string,\n        fee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams,\n        feeRecord?: string | RecordPlaintext,\n        privateKey?: PrivateKey,\n    ): Promise<string | Error> {\n        // Ensure the program is valid and does not exist on the network\n        try {\n            const programObject = Program.fromString(program);\n            let programSource;\n            try {\n                programSource = await this.networkClient.getProgram(programObject.id());\n            } catch (e) {\n                // Program does not exist on the network, deployment can proceed\n                console.log(`Program ${programObject.id()} does not exist on the network, deploying...`);\n            }\n            if (typeof programSource == \"string\") {\n                throw (`Program ${programObject.id()} already exists on the network, please rename your program`);\n            }\n        } catch (e) {\n            throw logAndThrow(`Error validating program: ${e}`);\n        }\n\n        // Get the private key from the account if it is not provided in the parameters\n        let deploymentPrivateKey = privateKey;\n        if (typeof privateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            deploymentPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof deploymentPrivateKey === \"undefined\") {\n            throw(\"No private key provided and no private key set in the ProgramManager\");\n        }\n\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee ? <RecordPlaintext>await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams) : undefined;\n        } catch (e) {\n            throw logAndThrow(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);\n        }\n\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        try {\n            feeKeys = privateFee ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys() : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n        } catch (e) {\n            throw logAndThrow(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`);\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n\n        // Resolve the program imports if they exist\n        let imports;\n        try {\n            imports = await this.networkClient.getProgramImports(program);\n        } catch (e) {\n            throw logAndThrow(`Error finding program imports. Network response: '${e}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);\n        }\n\n        // Build a deployment transaction and submit it to the network\n        const tx = await WasmProgramManager.buildDeploymentTransaction(deploymentPrivateKey, program, fee, feeRecord, this.host, imports, feeProvingKey, feeVerifyingKey);\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build an execution transaction for later submission to the Aleo network.\n     *\n     * @param {string} programName Program name containing the function to be executed\n     * @param {string} functionName Function name to execute\n     * @param {number} fee Fee to pay for the transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {string[]} inputs Inputs to the function\n     * @param {RecordSearchParams} recordSearchParams Optional parameters for searching for a record to pay the fee for\n     * the execution transaction\n     * @param {KeySearchParams} keySearchParams Optional parameters for finding the matching proving & verifying keys\n     * for the function\n     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction\n     * @param {ProvingKey | undefined} provingKey Optional proving key to use for the transaction\n     * @param {VerifyingKey | undefined} verifyingKey Optional verifying key to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @param {string | Program | undefined} program Optional program source code to use for the transaction\n     * @param {ProgramImports} imports Programs that the program being executed imports\n     * @returns {Promise<string | Error>}\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers\n     * const networkClient = new AleoNetworkClient(\"https://vm.aleo.org/api\");\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programName = \"hello_hello.aleo\";\n     * const programManager = new ProgramManager(\"https://vm.aleo.org/api\", keyProvider, recordProvider);\n     * const keySearchParams = { \"cacheKey\": \"hello_hello:hello\" };\n     * const transaction = await programManager.execute(programName, \"hello_hello\", 0.020, [\"5u32\", \"5u32\"], undefined, undefined, undefined, keySearchParams);\n     * const result = await programManager.networkClient.submitTransaction(transaction);\n     */\n    async buildExecutionTransaction(\n        programName: string,\n        functionName: string,\n        fee: number,\n        privateFee: boolean,\n        inputs: string[],\n        recordSearchParams?: RecordSearchParams,\n        keySearchParams?: KeySearchParams,\n        feeRecord?: string | RecordPlaintext,\n        provingKey?: ProvingKey,\n        verifyingKey?: VerifyingKey,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n        program?: string | Program,\n        imports?: ProgramImports\n    ): Promise<Transaction | Error> {\n        // Ensure the function exists on the network\n        if (program === undefined) {\n            try {\n                program = <string>(await this.networkClient.getProgram(programName));\n            } catch (e) {\n                throw logAndThrow(`Error finding ${programName}. Network response: '${e}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`);\n            }\n        } else if (program instanceof Program) {\n            program = program.toString();\n        }\n\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (typeof privateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            executionPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw(\"No private key provided and no private key set in the ProgramManager\");\n        }\n\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee ? <RecordPlaintext>await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams) : undefined;\n        } catch (e) {\n            throw logAndThrow(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);\n        }\n\n        // Get the fee proving and verifying keys from the key provider\n        let feeKeys;\n        try {\n            feeKeys = privateFee ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys() : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n        } catch (e) {\n            throw logAndThrow(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`);\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n\n        // If the function proving and verifying keys are not provided, attempt to find them using the key provider\n        if (!provingKey || !verifyingKey) {\n            try {\n                [provingKey, verifyingKey] = <FunctionKeyPair>await this.keyProvider.functionKeys(keySearchParams);\n            } catch (e) {\n                console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`)\n            }\n        }\n\n        // Resolve the program imports if they exist\n        const numberOfImports = Program.fromString(program).getImports().length;\n        if (numberOfImports > 0 && !imports) {\n            try {\n                imports = <ProgramImports>await this.networkClient.getProgramImports(programName);\n            } catch (e) {\n                throw logAndThrow(`Error finding program imports. Network response: '${e}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);\n            }\n        }\n\n        // Build an execution transaction and submit it to the network\n        return await WasmProgramManager.buildExecutionTransaction(executionPrivateKey, program, functionName, inputs, fee, feeRecord, this.host, imports, provingKey, verifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);\n    }\n\n    /**\n     * Execute an Aleo program on the Aleo network\n     *\n     * @param {string} programName Program name containing the function to be executed\n     * @param {string} functionName Function name to execute\n     * @param {number} fee Fee to pay for the transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {string[]} inputs Inputs to the function\n     * @param {RecordSearchParams} recordSearchParams Optional parameters for searching for a record to pay the fee for\n     * the execution transaction\n     * @param {KeySearchParams} keySearchParams Optional parameters for finding the matching proving & verifying keys\n     * for the function\n     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction\n     * @param {ProvingKey | undefined} provingKey Optional proving key to use for the transaction\n     * @param {VerifyingKey | undefined} verifyingKey Optional verifying key to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string | Error>}\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers\n     * const networkClient = new AleoNetworkClient(\"https://vm.aleo.org/api\");\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programName = \"hello_hello.aleo\";\n     * const programManager = new ProgramManager(\"https://vm.aleo.org/api\", keyProvider, recordProvider);\n     * const keySearchParams = { \"cacheKey\": \"hello_hello:hello\" };\n     * const tx_id = await programManager.execute(programName, \"hello_hello\", 0.020, [\"5u32\", \"5u32\"], undefined, undefined, undefined, keySearchParams);\n     * const transaction = await programManager.networkClient.getTransaction(tx_id);\n     */\n    async execute(\n        programName: string,\n        functionName: string,\n        fee: number,\n        privateFee: boolean,\n        inputs: string[],\n        recordSearchParams?: RecordSearchParams,\n        keySearchParams?: KeySearchParams,\n        feeRecord?: string | RecordPlaintext,\n        provingKey?: ProvingKey,\n        verifyingKey?: VerifyingKey,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n        program?: string | Program\n    ): Promise<string | Error> {\n        const tx = <Transaction>await this.buildExecutionTransaction(programName, functionName, fee, privateFee, inputs, recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery, program);\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Run an Aleo program in offline mode\n     *\n     * @param {string} program Program source code containing the function to be executed\n     * @param {string} function_name Function name to execute\n     * @param {string[]} inputs Inputs to the function\n     * @param {number} proveExecution Whether to prove the execution of the function and return an execution transcript\n     * that contains the proof.\n     * @param {string[] | undefined} imports Optional imports to the program\n     * @param {KeySearchParams | undefined} keySearchParams Optional parameters for finding the matching proving &\n     * verifying keys for the function\n     * @param {ProvingKey | undefined} provingKey Optional proving key to use for the transaction\n     * @param {VerifyingKey | undefined} verifyingKey Optional verifying key to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string | Error>}\n     *\n     * @example\n     * import { Account, Program } from '@aleohq/sdk';\n     *\n     * /// Create the source for the \"helloworld\" program\n     * const program = \"program helloworld.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\";\n     * const programManager = new ProgramManager();\n     *\n     * /// Create a temporary account for the execution of the program\n     * const account = new Account();\n     * programManager.setAccount(account);\n     *\n     * /// Get the response and ensure that the program executed correctly\n     * const executionResponse = await programManager.executeOffline(program, \"hello\", [\"5u32\", \"5u32\"]);\n     * const result = executionResponse.getOutputs();\n     * assert(result === [\"10u32\"]);\n     */\n    async run(\n        program: string,\n        function_name: string,\n        inputs: string[],\n        proveExecution: boolean,\n        imports?: ProgramImports,\n        keySearchParams?: KeySearchParams,\n        provingKey?: ProvingKey,\n        verifyingKey?: VerifyingKey,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<ExecutionResponse> {\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (typeof privateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            executionPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw(\"No private key provided and no private key set in the ProgramManager\");\n        }\n\n        // If the function proving and verifying keys are not provided, attempt to find them using the key provider\n        if (!provingKey || !verifyingKey) {\n            try {\n                [provingKey, verifyingKey] = <FunctionKeyPair>await this.keyProvider.functionKeys(keySearchParams);\n            } catch (e) {\n                console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`)\n            }\n        }\n\n        // Run the program offline and return the result\n        console.log(\"Running program offline\")\n        console.log(\"Proving key: \", provingKey);\n        console.log(\"Verifying key: \", verifyingKey);\n        return WasmProgramManager.executeFunctionOffline(executionPrivateKey, program, function_name, inputs, proveExecution, false, imports, provingKey, verifyingKey, this.host, offlineQuery);\n    }\n\n    /**\n     * Join two credits records into a single credits record\n     *\n     * @param {RecordPlaintext | string} recordOne First credits record to join\n     * @param {RecordPlaintext | string} recordTwo Second credits record to join\n     * @param {number} fee Fee in credits pay for the join transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the fee record to use\n     * to pay the fee for the join transaction\n     * @param {RecordPlaintext | string | undefined} feeRecord Fee record to use for the join transaction\n     * @param {PrivateKey | undefined} privateKey Private key to use for the join transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string | Error>}\n     */\n    async join(\n        recordOne: RecordPlaintext | string,\n        recordTwo: RecordPlaintext | string,\n        fee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams | undefined,\n        feeRecord?: RecordPlaintext | string | undefined,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<string | Error> {\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (typeof privateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            executionPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw(\"No private key provided and no private key set in the ProgramManager\");\n        }\n\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        let joinKeys\n        try {\n            feeKeys = privateFee ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys() : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n            joinKeys = <FunctionKeyPair>await this.keyProvider.joinKeys();\n        } catch (e) {\n            throw logAndThrow(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`);\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n        const [joinProvingKey, joinVerifyingKey] = joinKeys;\n\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee ? <RecordPlaintext>await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams) : undefined;\n        } catch (e) {\n            throw logAndThrow(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);\n        }\n\n        // Validate the records provided are valid plaintext records\n        try {\n            recordOne = recordOne instanceof RecordPlaintext ? recordOne : RecordPlaintext.fromString(recordOne);\n            recordTwo = recordTwo instanceof RecordPlaintext ? recordTwo : RecordPlaintext.fromString(recordTwo);\n        } catch (e) {\n            throw logAndThrow('Records provided are not valid. Please ensure they are valid plaintext records.')\n        }\n\n        // Build an execution transaction and submit it to the network\n        const tx = await WasmProgramManager.buildJoinTransaction(executionPrivateKey, recordOne, recordTwo, fee, feeRecord, this.host, joinProvingKey, joinVerifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Split credits into two new credits records\n     *\n     * @param {number} splitAmount Amount in microcredits to split from the original credits record\n     * @param {RecordPlaintext | string} amountRecord Amount record to use for the split transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the split transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string | Error>}\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://vm.aleo.org/api\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programName = \"hello_hello.aleo\";\n     * const programManager = new ProgramManager(\"https://vm.aleo.org/api\", keyProvider, recordProvider);\n     * const record = \"{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 4106205762862305308495708971985748592380064201230396559307556388725936304984group.public}\"\n     * const tx_id = await programManager.split(25000000, record);\n     * const transaction = await programManager.networkClient.getTransaction(tx_id);\n     */\n    async split(splitAmount: number, amountRecord: RecordPlaintext | string, privateKey?: PrivateKey, offlineQuery?: OfflineQuery): Promise<string | Error> {\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (typeof executionPrivateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            executionPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw(\"No private key provided and no private key set in the ProgramManager\");\n        }\n\n        // Get the split keys from the key provider\n        let splitKeys;\n        try {\n            splitKeys = <FunctionKeyPair>await this.keyProvider.splitKeys();\n        } catch (e) {\n            throw logAndThrow(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`);\n        }\n        const [splitProvingKey, splitVerifyingKey] = splitKeys;\n\n        // Validate the record to be split\n        try {\n            amountRecord = amountRecord instanceof RecordPlaintext ? amountRecord : RecordPlaintext.fromString(amountRecord);\n        } catch (e) {\n            throw logAndThrow(\"Record provided is not valid. Please ensure it is a valid plaintext record.\");\n        }\n\n        // Build an execution transaction and submit it to the network\n        const tx = await WasmProgramManager.buildSplitTransaction(executionPrivateKey, splitAmount, amountRecord, this.host, splitProvingKey, splitVerifyingKey, offlineQuery);\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Pre-synthesize proving and verifying keys for a program\n     *\n     * @param program {string} The program source code to synthesize keys for\n     * @param function_id {string} The function id to synthesize keys for\n     * @param inputs {Array<string>}  Sample inputs to the function\n     * @param privateKey {PrivateKey | undefined} Optional private key to use for the key synthesis\n     *\n     * @returns {Promise<FunctionKeyPair | Error>}\n     */\n    async synthesizeKeys(\n        program: string,\n        function_id: string,\n        inputs: Array<string>,\n        privateKey?: PrivateKey,\n    ): Promise<FunctionKeyPair | Error> {\n        // Resolve the program imports if they exist\n        let imports;\n\n        let executionPrivateKey = privateKey;\n        if (typeof executionPrivateKey === \"undefined\") {\n            if (typeof this.account !== \"undefined\") {\n                executionPrivateKey = this.account.privateKey();\n            } else {\n                executionPrivateKey = new PrivateKey();\n            }\n        }\n\n        // Attempt to run an offline execution of the program and extract the proving and verifying keys\n        try {\n            imports = await this.networkClient.getProgramImports(program);\n            const keyPair = await WasmProgramManager.synthesizeKeyPair(\n                executionPrivateKey,\n                program,\n                function_id,\n                inputs,\n                imports\n            );\n            return [<ProvingKey>keyPair.provingKey(), <VerifyingKey>keyPair.verifyingKey()];\n        } catch (e) {\n            throw logAndThrow(`Could not synthesize keys - error ${e}. Please ensure the program is valid and the inputs are correct.`);\n        }\n    }\n\n    /**\n     * Build a transaction to transfer credits to another account for later submission to the Aleo network\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'\n     * @param {number} fee The fee to pay for the transfer\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee\n     * records for the transfer transaction\n     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer\n     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string | Error>} The transaction id of the transfer transaction\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://vm.aleo.org/api\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programName = \"hello_hello.aleo\";\n     * const programManager = new ProgramManager(\"https://vm.aleo.org/api\", keyProvider, recordProvider);\n     * await programManager.initialize();\n     * const tx_id = await programManager.transfer(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"private\", 0.2)\n     * const transaction = await programManager.networkClient.getTransaction(tx_id);\n     */\n    async buildTransferTransaction(\n        amount: number,\n        recipient: string,\n        transferType: string,\n        fee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams,\n        amountRecord?: RecordPlaintext | string,\n        feeRecord?: RecordPlaintext | string,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery\n    ): Promise<Transaction | Error> {\n        // Validate the transfer type\n        transferType = <string>validateTransferType(transferType);\n\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (typeof executionPrivateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            executionPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw(\"No private key provided and no private key set in the ProgramManager\");\n        }\n\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        let transferKeys\n        try {\n            feeKeys = privateFee ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys() : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n            transferKeys = <FunctionKeyPair>await this.keyProvider.transferKeys(transferType);\n        } catch (e) {\n            throw logAndThrow(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`);\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n        const [transferProvingKey, transferVerifyingKey] = transferKeys;\n\n        // Get the amount and fee record from the account if it is not provided in the parameters\n        try {\n            // Track the nonces of the records found so no duplicate records are used\n            const nonces: string[] = [];\n            if (requiresAmountRecord(transferType)) {\n                // If the transfer type is private and requires an amount record, get it from the record provider\n                amountRecord = <RecordPlaintext>await this.getCreditsRecord(fee, [], amountRecord, recordSearchParams);\n                nonces.push(amountRecord.nonce());\n            } else {\n                amountRecord = undefined;\n            }\n            feeRecord = privateFee ? <RecordPlaintext>await this.getCreditsRecord(fee, nonces, feeRecord, recordSearchParams) : undefined;\n        } catch (e) {\n            throw logAndThrow(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);\n        }\n\n        // Build an execution transaction and submit it to the network\n        return await WasmProgramManager.buildTransferTransaction(executionPrivateKey, amount, recipient, transferType, amountRecord, fee, feeRecord, this.host, transferProvingKey, transferVerifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);\n    }\n\n    /**\n     * Build a transfer_public transaction to transfer credits to another account for later submission to the Aleo network\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'\n     * @param {number} fee The fee to pay for the transfer\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee\n     * records for the transfer transaction\n     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer\n     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string | Error>} The transaction id of the transfer transaction\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://vm.aleo.org/api\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programName = \"hello_hello.aleo\";\n     * const programManager = new ProgramManager(\"https://vm.aleo.org/api\", keyProvider, recordProvider);\n     * await programManager.initialize();\n     * const tx_id = await programManager.transfer(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"private\", 0.2)\n     * const transaction = await programManager.networkClient.getTransaction(tx_id);\n     */\n    async buildTransferPublicTransaction(\n        amount: number,\n        recipient: string,\n        fee: number,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery\n    ): Promise<Transaction | Error> {\n        return this.buildTransferTransaction(amount, recipient, \"public\", fee, false, undefined, undefined, undefined, privateKey, offlineQuery);\n    }\n\n    /**\n     * Transfer credits to another account\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'\n     * @param {number} fee The fee to pay for the transfer\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee\n     * records for the transfer transaction\n     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer\n     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string | Error>} The transaction id of the transfer transaction\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://vm.aleo.org/api\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programName = \"hello_hello.aleo\";\n     * const programManager = new ProgramManager(\"https://vm.aleo.org/api\", keyProvider, recordProvider);\n     * await programManager.initialize();\n     * const tx_id = await programManager.transfer(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"private\", 0.2)\n     * const transaction = await programManager.networkClient.getTransaction(tx_id);\n     */\n    async transfer(\n        amount: number,\n        recipient: string,\n        transferType: string,\n        fee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams,\n        amountRecord?: RecordPlaintext | string,\n        feeRecord?: RecordPlaintext | string,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery\n    ): Promise<string | Error> {\n        const tx = <Transaction>await this.buildTransferTransaction(amount, recipient, transferType, fee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery);\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build transaction to bond credits to a staking committee for later submission to the Aleo Network\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.aleo.org/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.bondPublic(\"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", 2000000);\n     *\n     * @returns string\n     * @param {string} address Address of the validator to bond to, if this address is the same as the signer (i.e. the\n     * executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently\n     * requires a minimum of 1,000,000 credits to bond (subject to change). If the address is specified is an existing\n     * validator and is different from the address of the executor of this function, it will bond the credits to that\n     * validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {number} amount The amount of credits to bond\n     * @param {Options} options Options for the execution\n     */\n    async buildBondPublicTransaction(address: string, amount: number, options: Options = {}) {\n        amount = Math.trunc(amount*1000000);\n\n        const {\n            offlineParams = {},\n            executionParams = {}\n        } = options || {};\n\n        let {\n            programName = \"credits.aleo\",\n            functionName = \"bond_public\",\n            fee = executionParams?.fee || 0.86,\n            privateFee = false,\n            recordSearchParams,\n            keySearchParams,\n            feeRecord,\n            provingKey,\n            verifyingKey,\n            privateKey\n        } = executionParams;\n\n        if (keySearchParams === undefined) {\n            keySearchParams = new AleoKeyProviderParams(\n                {\n                    proverUri: CREDITS_PROGRAM_KEYS.bond_public.prover,\n                    verifierUri: CREDITS_PROGRAM_KEYS.bond_public.verifier,\n                    cacheKey: \"credits.aleo/bond_public\"\n                });\n        }\n\n        const {\n            offlineQuery,\n        } = offlineParams;\n\n        return await this.buildExecutionTransaction(programName, functionName, fee, privateFee, [address, `${amount.toString()}u64`], recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery, this.creditsProgram());\n    }\n\n    /**\n     * Bond credits to a staking committee\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.aleo.org/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.bondPublic(\"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", 2000000);\n     *\n     * @returns string\n     * @param {string} address Address of the validator to bond to, if this address is the same as the signer (i.e. the\n     * executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently\n     * requires a minimum of 1,000,000 credits to bond (subject to change). If the address is specified is an existing\n     * validator and is different from the address of the executor of this function, it will bond the credits to that\n     * validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {number} amount The amount of credits to bond\n     * @param {Options} options Options for the execution\n     */\n    async bondPublic(address: string, amount: number, options: Options = {}) {\n        const tx = <Transaction>await this.buildBondPublicTransaction(address, amount, options);\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build a transaction to unbond a specified amount of staked credits to be used later\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.aleo.org/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.unbondPublic(10);\n     *\n     * @returns string\n     * @param {number} amount Amount of credits to unbond. If the address of the executor of this function is an\n     * existing validator, it will subtract this amount of credits from the validator's staked credits. If there are\n     * less than 1,000,000 credits staked pool after the unbond, the validator will be removed from the validator set.\n     * If the address of the executor of this function is not a validator and has credits bonded as a delegator, it will\n     * subtract this amount of credits from the delegator's staked credits. If there are less than 10 credits bonded\n     * after the unbond operation, the delegator will be removed from the validator's staking pool.\n     * @param {Options} options Options for the execution\n     */\n    async buildUnbondPublicTransaction(amount: number, options: Options = {}): Promise<Transaction | Error> {\n        amount = Math.trunc(amount*1000000);\n\n        const {\n            offlineParams = {},\n            executionParams = {}\n        } = options || {};\n\n        let {\n            programName = \"credits.aleo\",\n            functionName = \"unbond_public\",\n            fee = executionParams?.fee || 1.3,\n            privateFee = false,\n            recordSearchParams,\n            keySearchParams,\n            feeRecord,\n            provingKey,\n            verifyingKey,\n            privateKey\n        } = executionParams;\n\n        if (keySearchParams === undefined) {\n            keySearchParams = new AleoKeyProviderParams(\n                {\n                    proverUri: CREDITS_PROGRAM_KEYS.unbond_public.prover,\n                    verifierUri: CREDITS_PROGRAM_KEYS.unbond_public.verifier,\n                    cacheKey: \"credits.aleo/unbond_public\"\n                });\n        }\n\n        const {\n            offlineQuery,\n        } = offlineParams;\n\n        return this.buildExecutionTransaction(programName, functionName, fee, privateFee, [`${amount.toString()}u64`], recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery, this.creditsProgram());\n    }\n\n    /**\n     * Unbond a specified amount of staked credits to be used later\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.aleo.org/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.unbondPublic(10);\n     *\n     * @returns string\n     * @param {number} amount Amount of credits to unbond. If the address of the executor of this function is an\n     * existing validator, it will subtract this amount of credits from the validator's staked credits. If there are\n     * less than 1,000,000 credits staked pool after the unbond, the validator will be removed from the validator set.\n     * If the address of the executor of this function is not a validator and has credits bonded as a delegator, it will\n     * subtract this amount of credits from the delegator's staked credits. If there are less than 10 credits bonded\n     * after the unbond operation, the delegator will be removed from the validator's staking pool.\n     * @param {Options} options Options for the execution\n     */\n    async unbondPublic(amount: number, options: Options = {}): Promise<string | Error> {\n        const tx = <Transaction>await this.buildUnbondPublicTransaction(amount, options);\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build a transaction to Claim unbonded credits for later submission. If credits have been unbonded by the account\n     * executing this function, this method will claim them and add them to the public balance of the account.\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.aleo.org/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.claimUnbondPublic();\n     *\n     * @returns string\n     * @param {Options} options\n     */\n    async buildClaimUnbondPublicTransaction(options: Options = {}): Promise<Transaction | Error> {\n        const {\n            offlineParams = {},\n            executionParams = {}\n        } = options || {};\n\n        let {\n            programName = \"credits.aleo\",\n            functionName = \"claim_unbond_public\",\n            fee = executionParams?.fee || 2,\n            privateFee = false,\n            recordSearchParams,\n            keySearchParams,\n            feeRecord,\n            provingKey,\n            verifyingKey,\n            privateKey\n        } = executionParams;\n\n        if (keySearchParams === undefined) {\n            keySearchParams = new AleoKeyProviderParams(\n                {\n                    proverUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.prover,\n                    verifierUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier,\n                    cacheKey: \"credits.aleo/claim_unbond_public\"\n                });\n        }\n\n        const {\n            offlineQuery,\n        } = offlineParams;\n\n        return await this.buildExecutionTransaction(programName, functionName, fee, privateFee, [], recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery, this.creditsProgram());\n    }\n\n    /**\n     * Claim unbonded credits. If credits have been unbonded by the account executing this function, this method will\n     * claim them and add them to the public balance of the account.\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.aleo.org/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.claimUnbondPublic();\n     *\n     * @returns string\n     * @param {Options} options\n     */\n    async claimUnbondPublic(options: Options = {}): Promise<string | Error> {\n        const tx = <Transaction>await this.buildClaimUnbondPublicTransaction(options);\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Set Validator State\n     * @returns string\n     * @param {boolean} validator_state\n     * @param options\n     */\n    async setValidatorState(validator_state: boolean, options: Options = {}) {\n        const {\n            offlineParams = {},\n            executionParams = {}\n        } = options || {};\n\n        let {\n            programName = \"credits.aleo\",\n            functionName = \"set_validator_state\",\n            fee = 1,\n            privateFee = false,\n            recordSearchParams,\n            keySearchParams,\n            feeRecord,\n            provingKey,\n            verifyingKey,\n            privateKey\n        } = executionParams;\n\n        if (keySearchParams === undefined) {\n            keySearchParams = new AleoKeyProviderParams(\n                {\n                    proverUri: CREDITS_PROGRAM_KEYS.set_validator_state.prover,\n                    verifierUri: CREDITS_PROGRAM_KEYS.set_validator_state.verifier,\n                    cacheKey: \"credits.aleo/set_validator_state\"\n                });\n        }\n\n        const {\n            offlineQuery,\n        } = offlineParams;\n\n        return await this.execute(programName, functionName, fee, privateFee, [validator_state.toString()], recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery);\n    }\n\n    /**\n     * Unbond Delegator As Validator\n     * @returns string\n     * @param {string} address\n     * @param options\n     */\n    async unbondDelegatorAsValidator(address:string, options: Options = {}) {\n        const {\n            offlineParams = {},\n            executionParams = {}\n        } = options || {};\n\n        let {\n            programName = \"credits.aleo\",\n            functionName = \"unbond_delegator_as_validator\",\n            fee = 1,\n            privateFee = false,\n            recordSearchParams,\n            keySearchParams,\n            feeRecord,\n            provingKey,\n            verifyingKey,\n            privateKey\n        } = executionParams;\n\n        if (keySearchParams === undefined) {\n            keySearchParams = new AleoKeyProviderParams(\n                {\n                    proverUri: CREDITS_PROGRAM_KEYS.unbond_delegator_as_validator.prover,\n                    verifierUri: CREDITS_PROGRAM_KEYS.unbond_delegator_as_validator.verifier,\n                    cacheKey: \"credits.aleo/unbond_delegator_as_validator\"\n                });\n        }\n\n        const {\n            offlineQuery,\n        } = offlineParams;\n\n        return await this.execute(programName, functionName, fee, privateFee, [address], recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery);\n    }\n\n\n    /**\n     * Verify a proof of execution from an offline execution\n     *\n     * @param {executionResponse} executionResponse\n     * @returns {boolean} True if the proof is valid, false otherwise\n     */\n    verifyExecution(executionResponse: ExecutionResponse): boolean {\n        try {\n            const execution = <Execution>executionResponse.getExecution();\n            const function_id = executionResponse.getFunctionId();\n            const program = executionResponse.getProgram();\n            const verifyingKey = executionResponse.getVerifyingKey();\n            return verifyFunctionExecution(execution, verifyingKey, program, function_id);\n        } catch(e) {\n            console.warn(\"The execution was not found in the response, cannot verify the execution\");\n            return false;\n        }\n    }\n\n    /**\n     * Create a program object from a program's source code\n     *\n     * @param {string} program Program source code\n     * @returns {Program | Error} The program object\n     */\n    createProgramFromSource(program: string): Program | Error {\n        return Program.fromString(program);\n    }\n\n    /**\n     * Get the credits program object\n     *\n     * @returns {Program} The credits program object\n     */\n    creditsProgram(): Program {\n        return Program.getCreditsProgram();\n    }\n\n    /**\n     * Verify a program is valid\n     *\n     * @param {string} program The program source code\n     */\n    verifyProgram(program: string): boolean {\n        try {\n            <Program>Program.fromString(program);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    // Internal utility function for getting a credits.aleo record\n    async getCreditsRecord(amount: number, nonces: string[], record?: RecordPlaintext | string, params?: RecordSearchParams): Promise<RecordPlaintext | Error> {\n        try {\n            return record instanceof RecordPlaintext ? record : RecordPlaintext.fromString(<string>record);\n        } catch (e) {\n            try {\n                const recordProvider = <RecordProvider>this.recordProvider;\n                return <RecordPlaintext>(await recordProvider.findCreditsRecord(amount, true, nonces, params))\n            } catch (e) {\n                throw logAndThrow(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);\n            }\n        }\n    }\n}\n\n// Ensure the transfer type requires an amount record\nfunction requiresAmountRecord(transferType: string): boolean {\n    return PRIVATE_TRANSFER_TYPES.has(transferType);\n}\n\n// Validate the transfer type\nfunction validateTransferType(transferType: string): string | Error {\n    return VALID_TRANSFER_TYPES.has(transferType) ? transferType :\n        logAndThrow(`Invalid transfer type '${transferType}'. Valid transfer types are 'private', 'privateToPublic', 'public', and 'publicToPrivate'.`);\n}\n\nexport { ProgramManager }\n","import {VerifyingKey} from \"@aleohq/wasm\";\nconst KEY_STORE = \"https://testnet3.parameters.aleo.org/\";\n\nconst CREDITS_PROGRAM_KEYS = {\n    bond_public: {\n        locator: \"credits.aleo/bond_public\",\n        prover: KEY_STORE + \"bond_public.prover.9c3547d\",\n        verifier: \"bond_public.verifier.10315ae\",\n        verifyingKey: VerifyingKey.bondPublicVerifier\n    },\n    claim_unbond_public: {\n        locator: \"credits.aleo/claim_unbond_public\",\n        prover: KEY_STORE + \"claim_unbond_public.prover.f8b64aa\",\n        verifier: \"claim_unbond_public.verifier.8fd7445\",\n        verifyingKey: VerifyingKey.claimUnbondPublicVerifier\n    },\n    fee_private: {\n        locator: \"credits.aleo/fee_private\",\n        prover: KEY_STORE + \"fee_private.prover.43fab98\",\n        verifier: \"fee_private.verifier.f3dfefc\",\n        verifyingKey: VerifyingKey.feePrivateVerifier\n    },\n    fee_public: {\n        locator: \"credits.aleo/fee_public\",\n        prover: KEY_STORE + \"fee_public.prover.634f153\",\n        verifier: \"fee_public.verifier.09eeb4f\",\n        verifyingKey: VerifyingKey.feePublicVerifier\n    },\n    inclusion: {\n        locator: \"inclusion\",\n        prover: KEY_STORE + \"inclusion.prover.cd85cc5\",\n        verifier: \"inclusion.verifier.e6f3add\",\n        verifyingKey: VerifyingKey.inclusionVerifier\n    },\n    join: {\n        locator: \"credits.aleo/join\",\n        prover: KEY_STORE + \"join.prover.1a76fe8\",\n        verifier: \"join.verifier.4f1701b\",\n        verifyingKey: VerifyingKey.joinVerifier\n    },\n    set_validator_state: {\n        locator: \"credits.aleo/set_validator_state\",\n        prover: KEY_STORE + \"set_validator_state.prover.5ce19be\",\n        verifier: \"set_validator_state.verifier.730d95b\",\n        verifyingKey: VerifyingKey.setValidatorStateVerifier\n    },\n    split: {\n        locator: \"credits.aleo/split\",\n        prover: KEY_STORE + \"split.prover.e6d12b9\",\n        verifier: \"split.verifier.2f9733d\",\n        verifyingKey: VerifyingKey.splitVerifier\n    },\n    transfer_private: {\n        locator: \"credits.aleo/transfer_private\",\n        prover: KEY_STORE + \"transfer_private.prover.2b487c0\",\n        verifier: \"transfer_private.verifier.3a3cbba\",\n        verifyingKey: VerifyingKey.transferPrivateVerifier\n    },\n    transfer_private_to_public: {\n        locator: \"credits.aleo/transfer_private_to_public\",\n        prover: KEY_STORE + \"transfer_private_to_public.prover.1ff64cb\",\n        verifier: \"transfer_private_to_public.verifier.d5b60de\",\n        verifyingKey: VerifyingKey.transferPrivateToPublicVerifier\n    },\n    transfer_public: {\n        locator: \"credits.aleo/transfer_public\",\n        prover: KEY_STORE + \"transfer_public.prover.a74565e\",\n        verifier: \"transfer_public.verifier.a4c2906\",\n        verifyingKey: VerifyingKey.transferPublicVerifier\n    },\n    transfer_public_to_private: {\n        locator: \"credits.aleo/transfer_public_to_private\",\n        prover: KEY_STORE + \"transfer_public_to_private.prover.1bcddf9\",\n        verifier: \"transfer_public_to_private.verifier.b094554\",\n        verifyingKey: VerifyingKey.transferPublicToPrivateVerifier\n    },\n    unbond_delegator_as_validator: {\n        locator: \"credits.aleo/unbond_delegator_as_validator\",\n        prover: KEY_STORE + \"unbond_delegator_as_validator.prover.115a86b\",\n        verifier: \"unbond_delegator_as_validator.verifier.9585609\",\n        verifyingKey: VerifyingKey.unbondDelegatorAsValidatorVerifier\n    },\n    unbond_public: {\n        locator: \"credits.aleo/unbond_public\",\n        prover: KEY_STORE + \"unbond_public.prover.9547c05\",\n        verifier: \"unbond_public.verifier.09873cd\",\n        verifyingKey: VerifyingKey.unbondPublicVerifier\n    },\n};\n\nconst PRIVATE_TRANSFER_TYPES = new Set([\n    \"transfer_private\",\n    \"private\",\n    \"transferPrivate\",\n    \"transfer_private_to_public\",\n    \"privateToPublic\",\n    \"transferPrivateToPublic\",\n]);\nconst VALID_TRANSFER_TYPES = new Set([\n    \"transfer_private\",\n    \"private\",\n    \"transferPrivate\",\n    \"transfer_private_to_public\",\n    \"privateToPublic\",\n    \"transferPrivateToPublic\",\n    \"transfer_public\",\n    \"public\",\n    \"transferPublic\",\n    \"transfer_public_to_private\",\n    \"publicToPrivate\",\n    \"transferPublicToPrivate\",\n]);\nconst PRIVATE_TRANSFER = new Set([\n    \"private\",\n    \"transfer_private\",\n    \"transferPrivate\",\n]);\nconst PRIVATE_TO_PUBLIC_TRANSFER = new Set([\n    \"private_to_public\",\n    \"privateToPublic\",\n    \"transfer_private_to_public\",\n    \"transferPrivateToPublic\",\n]);\nconst PUBLIC_TRANSFER = new Set([\n    \"public\",\n    \"transfer_public\",\n    \"transferPublic\",\n]);\nconst PUBLIC_TO_PRIVATE_TRANSFER = new Set([\n    \"public_to_private\",\n    \"publicToPrivate\",\n    \"transfer_public_to_private\",\n    \"transferPublicToPrivate\",\n]);\n\nfunction logAndThrow(message: string): Error {\n    console.error(message);\n    throw message;\n}\n\nimport { Account } from \"./account\";\nimport { AleoNetworkClient, ProgramImports } from \"./network-client\";\nimport { Block } from \"./models/block\";\nimport { Execution } from \"./models/execution\";\nimport { Input } from \"./models/input\";\nimport { Output } from \"./models/output\";\nimport { TransactionModel } from \"./models/transactionModel\";\nimport { Transition } from \"./models/transition\";\nimport {\n    AleoKeyProvider,\n    AleoKeyProviderParams,\n    AleoKeyProviderInitParams,\n    CachedKeyPair,\n    FunctionKeyPair,\n    FunctionKeyProvider,\n    KeySearchParams,\n} from \"./function-key-provider\";\nimport {\n    OfflineKeyProvider,\n    OfflineSearchParams\n} from \"./offline-key-provider\";\nimport {\n    BlockHeightSearch,\n    NetworkRecordProvider,\n    RecordProvider,\n    RecordSearchParams,\n} from \"./record-provider\";\n\n// @TODO: This function is no longer needed, remove it.\nasync function initializeWasm() {\n    console.warn(\"initializeWasm is deprecated, you no longer need to use it\");\n}\n\nexport { createAleoWorker } from \"./managed-worker\";\n\nexport { ProgramManager } from \"./program-manager\";\n\nexport {\n    Address,\n    Execution as FunctionExecution,\n    ExecutionResponse,\n    Field,\n    OfflineQuery,\n    PrivateKey,\n    PrivateKeyCiphertext,\n    Program,\n    ProgramManager as ProgramManagerBase,\n    ProvingKey,\n    RecordCiphertext,\n    RecordPlaintext,\n    Signature,\n    Transaction,\n    VerifyingKey,\n    ViewKey,\n    initThreadPool,\n    verifyFunctionExecution,\n} from \"@aleohq/wasm\";\n\nexport { initializeWasm };\n\nexport {\n    Account,\n    AleoKeyProvider,\n    AleoKeyProviderParams,\n    AleoKeyProviderInitParams,\n    AleoNetworkClient,\n    Block,\n    BlockHeightSearch,\n    CachedKeyPair,\n    Execution,\n    FunctionKeyPair,\n    FunctionKeyProvider,\n    Input,\n    KeySearchParams,\n    NetworkRecordProvider,\n    ProgramImports,\n    OfflineKeyProvider,\n    OfflineSearchParams,\n    Output,\n    RecordProvider,\n    RecordSearchParams,\n    TransactionModel,\n    Transition,\n    CREDITS_PROGRAM_KEYS,\n    KEY_STORE,\n    PRIVATE_TRANSFER,\n    PRIVATE_TO_PUBLIC_TRANSFER,\n    PRIVATE_TRANSFER_TYPES,\n    PUBLIC_TRANSFER,\n    PUBLIC_TO_PRIVATE_TRANSFER,\n    VALID_TRANSFER_TYPES,\n    logAndThrow,\n};\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously \\_()_/\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnt happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".bundle.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t859: 1\n};\n\n// no chunk install function needed\n// no chunk loading\n\n// no HMR\n\n// no HMR manifest","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(3539);\n"],"names":["webpackQueues","webpackExports","webpackError","resolveQueue","spawnWorker","url","module","memory","address","Promise","resolve","worker","Worker","type","addEventListener","event","unref","capture","once","postMessage","wasm","heap","Array","fill","undefined","getObject","idx","push","heap_next","length","dropObject","takeObject","ret","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","decode","Error","cachedUint8Memory0","getUint8Memory0","buffer","Uint8Array","getStringFromWasm0","ptr","len","slice","addHeapObject","obj","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encode","encodeString","arg","view","buf","set","read","written","passStringToWasm0","malloc","realloc","subarray","mem","offset","code","charCodeAt","isLikeNone","x","cachedInt32Memory0","getInt32Memory0","Int32Array","debugString","val","description","name","isArray","debug","i","builtInMatches","exec","toString","call","className","JSON","stringify","_","message","stack","makeMutClosure","arg0","arg1","dtor","f","state","a","b","cnt","real","args","__wbindgen_export_3","get","original","__wbg_adapter_34","arg2","wasm_bindgen__convert__closures__invoke1_mut__h53d50e21bb2d5c71","_assertClass","instance","klass","passArray8ToWasm0","verifyFunctionExecution$1","execution","verifying_key","program","function_id","retptr","__wbindgen_add_to_stack_pointer","Execution$1","VerifyingKey$1","Program$1","ptr0","__wbindgen_malloc","__wbindgen_realloc","len0","verifyFunctionExecution","__wbg_ptr","r0","r1","cachedBigInt64Memory0","getBigInt64Memory0","BigInt64Array","getArrayU8FromWasm0","runRayonThread","receiver","initThreadPool$1","num_threads","initThreadPool","handleError","apply","this","e","__wbindgen_exn_store","__wbg_adapter_251","arg3","wasm_bindgen__convert__closures__invoke2_mut__he97f6a3b9df30e2b","Address","__wrap","Object","create","prototype","__destroy_into_raw","free","__wbg_address_free","from_private_key","private_key","PrivateKey$1","address_from_private_key","from_view_key","view_key","ViewKey$1","address_from_view_key","from_string","address_from_string","to_string","deferred1_0","deferred1_1","address_to_string","__wbindgen_free","verify","signature","Signature$1","address_verify","Execution","__wbg_execution_free","execution_toString","fromString","execution_fromString","ExecutionResponse","__wbg_executionresponse_free","getOutputs","executionresponse_getOutputs","getExecution","executionresponse_getExecution","getKeys","executionresponse_getKeys","KeyPair","getProvingKey","executionresponse_getProvingKey","ProvingKey$1","getVerifyingKey","executionresponse_getVerifyingKey","getFunctionId","executionresponse_getFunctionId","getProgram","executionresponse_getProgram","Field","__wbg_field_free","field_toString","field","field_fromString","__wbg_keypair_free","constructor","proving_key","ptr1","keypair_new","provingKey","keypair_provingKey","verifyingKey","keypair_verifyingKey","OfflineQuery","__wbg_offlinequery_free","state_root","offlinequery_new","addStatePath","commitment","state_path","len1","offlinequery_addStatePath","offlinequery_toString","s","offlinequery_fromString","PrivateKey","__wbg_privatekey_free","privatekey_new","from_seed_unchecked","seed","privatekey_from_seed_unchecked","privatekey_from_string","privatekey_to_string","to_view_key","privatekey_to_view_key","to_address","Address$1","sign","privatekey_sign","newEncrypted","secret","privatekey_newEncrypted","PrivateKeyCiphertext$1","toCiphertext","privatekey_toCiphertext","fromPrivateKeyCiphertext","ciphertext","privatekey_fromPrivateKeyCiphertext","PrivateKeyCiphertext","__wbg_privatekeyciphertext_free","encryptPrivateKey","decryptToPrivateKey","privatekeyciphertext_decryptToPrivateKey","privatekeyciphertext_toString","privatekeyciphertext_fromString","Program","__wbg_program_free","program_fromString","program_toString","hasFunction","function_name","program_hasFunction","getFunctions","program_getFunctions","getFunctionInputs","program_getFunctionInputs","getMappings","program_getMappings","getRecordMembers","record_name","program_getRecordMembers","getStructMembers","struct_name","program_getStructMembers","getCreditsProgram","program_getCreditsProgram","id","program_id","isEqual","other","program_isEqual","getImports","program_getImports","__wbg_programmanager_free","buildDeploymentTransaction","fee_credits","fee_record","imports","fee_proving_key","fee_verifying_key","offline_query","RecordPlaintext$1","ptr2","len2","ptr3","ptr4","ptr5","OfflineQuery$1","programmanager_buildDeploymentTransaction","estimateDeploymentFee","programmanager_estimateDeploymentFee","estimateProgramNameCost","programmanager_estimateProgramNameCost","r2","BigInt","asUintN","executeFunctionOffline","_function","inputs","prove_execution","cache","len4","programmanager_executeFunctionOffline","buildExecutionTransaction","len3","ptr6","ptr7","ptr8","programmanager_buildExecutionTransaction","estimateExecutionFee","programmanager_estimateExecutionFee","estimateFinalizeFee","programmanager_estimateFinalizeFee","buildJoinTransaction","record_1","record_2","join_proving_key","join_verifying_key","programmanager_buildJoinTransaction","buildSplitTransaction","split_amount","amount_record","split_proving_key","split_verifying_key","programmanager_buildSplitTransaction","buildTransferTransaction","amount_credits","recipient","transfer_type","transfer_proving_key","transfer_verifying_key","ptr9","programmanager_buildTransferTransaction","synthesizeKeyPair","programmanager_synthesizeKeyPair","ProvingKey","__wbg_provingkey_free","isBondPublicProver","provingkey_isBondPublicProver","isClaimUnbondPublicProver","provingkey_isClaimUnbondPublicProver","isFeePrivateProver","provingkey_isFeePrivateProver","isFeePublicProver","provingkey_isFeePublicProver","isInclusionProver","provingkey_isInclusionProver","isJoinProver","provingkey_isJoinProver","isSetValidatorStateProver","provingkey_isSetValidatorStateProver","isSplitProver","provingkey_isSplitProver","isTransferPrivateProver","provingkey_isTransferPrivateProver","isTransferPrivateToPublicProver","provingkey_isTransferPrivateToPublicProver","isTransferPublicProver","provingkey_isTransferPublicProver","isTransferPublicToPrivateProver","provingkey_isTransferPublicToPrivateProver","isUnbondDelegatorAsValidatorProver","provingkey_isUnbondDelegatorAsValidatorProver","isUnbondPublicProver","provingkey_isUnbondPublicProver","checksum","provingkey_checksum","copy","provingkey_copy","fromBytes","bytes","provingkey_fromBytes","string","provingkey_fromString","toBytes","provingkey_toBytes","v1","provingkey_toString","RecordCiphertext","__wbg_recordciphertext_free","record","recordciphertext_fromString","recordciphertext_toString","decrypt","recordciphertext_decrypt","isOwner","recordciphertext_isOwner","RecordPlaintext","__wbg_recordplaintext_free","recordplaintext_commitment","Field$1","recordplaintext_fromString","recordplaintext_toString","microcredits","recordplaintext_microcredits","nonce","recordplaintext_nonce","serialNumberString","deferred4_0","deferred4_1","recordplaintext_serialNumberString","r3","Signature","__wbg_signature_free","signature_verify","signature_from_string","signature_to_string","Transaction","__wbg_transaction_free","transaction","transaction_fromString","transaction_toString","transactionId","transaction_transactionId","transactionType","transaction_transactionType","VerifyingKey","__wbg_verifyingkey_free","bondPublicVerifier","verifyingkey_bondPublicVerifier","claimUnbondPublicVerifier","verifyingkey_claimUnbondPublicVerifier","feePrivateVerifier","verifyingkey_feePrivateVerifier","feePublicVerifier","verifyingkey_feePublicVerifier","inclusionVerifier","verifyingkey_inclusionVerifier","joinVerifier","verifyingkey_joinVerifier","setValidatorStateVerifier","verifyingkey_setValidatorStateVerifier","splitVerifier","verifyingkey_splitVerifier","transferPrivateVerifier","verifyingkey_transferPrivateVerifier","transferPrivateToPublicVerifier","verifyingkey_transferPrivateToPublicVerifier","transferPublicVerifier","verifyingkey_transferPublicVerifier","transferPublicToPrivateVerifier","verifyingkey_transferPublicToPrivateVerifier","unbondDelegatorAsValidatorVerifier","verifyingkey_unbondDelegatorAsValidatorVerifier","unbondPublicVerifier","verifyingkey_unbondPublicVerifier","isBondPublicVerifier","verifyingkey_isBondPublicVerifier","isClaimUnbondPublicVerifier","verifyingkey_isClaimUnbondPublicVerifier","isFeePrivateVerifier","verifyingkey_isFeePrivateVerifier","isFeePublicVerifier","verifyingkey_isFeePublicVerifier","isInclusionVerifier","verifyingkey_isInclusionVerifier","isJoinVerifier","verifyingkey_isJoinVerifier","isSetValidatorStateVerifier","verifyingkey_isSetValidatorStateVerifier","isSplitVerifier","verifyingkey_isSplitVerifier","isTransferPrivateVerifier","verifyingkey_isTransferPrivateVerifier","isTransferPrivateToPublicVerifier","verifyingkey_isTransferPrivateToPublicVerifier","isTransferPublicVerifier","verifyingkey_isTransferPublicVerifier","isTransferPublicToPrivateVerifier","verifyingkey_isTransferPublicToPrivateVerifier","isUnbondDelegatorAsValidatorVerifier","verifyingkey_isUnbondDelegatorAsValidatorVerifier","isUnbondPublicVerifier","verifyingkey_isUnbondPublicVerifier","verifyingkey_checksum","verifyingkey_fromBytes","verifyingkey_fromString","verifyingkey_toBytes","verifyingkey_toString","ViewKey","__wbg_viewkey_free","viewkey_from_string","viewkey_to_string","deferred3_0","deferred3_1","viewkey_decrypt","async","__wbg_load","Response","WebAssembly","instantiateStreaming","headers","console","warn","arrayBuffer","instantiate","Instance","__wbg_get_imports","wbg","__wbindgen_object_drop_ref","__wbg_new_daafff584c71593b","XMLHttpRequest","arguments","__wbg_overrideMimeType_1a661d17da5f8baf","overrideMimeType","__wbg_open_56fa1eb95989f6a5","arg4","arg5","open","__wbg_send_9f5007eae908c72e","send","__wbg_response_f2acf2ecbe021710","response","__wbg_new_b51585de1b234aff","__wbindgen_string_new","__wbg_set_092e06b0f9d71865","Reflect","__wbg_new_1eead62f64ca15ce","Headers","__wbindgen_object_clone_ref","__wbg_append_fda9e3432e3e88da","append","__wbg_new_55c9955722952374","AbortController","__wbg_signal_4bd18fb489af2d4c","signal","__wbg_instanceof_Response_fc4327dbfcdf5ced","result","__wbg_status_ac85a3142a84caa2","status","__wbg_url_8503de97f69da463","__wbg_headers_b70de86b8e989bc0","__wbg_iterator_97f0c81209c6c35a","Symbol","iterator","__wbg_get_97b561fb56f034b5","__wbindgen_is_function","__wbg_call_cb65541d95d71282","__wbindgen_is_object","__wbg_next_526fc47e980da008","next","__wbg_next_ddb3312ca1c4e32a","__wbg_done_5c1f01fb660d73b5","done","__wbg_value_1695675138684bd5","value","__wbg_abort_654b796176d117aa","abort","__wbg_stringify_e25465938f3f611f","__wbindgen_string_get","__wbg_call_01734de55d61e11d","__wbg_keypair_new","__wbg_log_0159ca40cddf5b15","log","__wbg_transaction_new","Transaction$1","__wbindgen_bigint_from_u64","__wbindgen_module","__wbg_init","__wbindgen_wasm_module","__wbindgen_memory","__wbg_spawnWorker_f6acaddb2e29dc4a","__wbg_executionresponse_new","ExecutionResponse$1","__wbg_newwithlength_3ec098a360da1909","__wbg_set_502d29070ea18557","__wbindgen_cb_drop","__wbg_arrayBuffer_288fb3538806e85c","__wbg_new_8125e318e6245eed","__wbg_length_72e2208bbc0efc61","__wbg_new_43f1b47c28813cbd","state0","cb0","__wbg_new_898a68150f225f2e","__wbg_push_ca1c26067ef907ac","__wbindgen_number_new","__wbg_new_abda76e883ba8a5f","__wbg_stack_658279fe44541cf6","__wbg_error_f851667af71bcfc6","deferred0_0","deferred0_1","error","__wbg_subarray_13db269f57aa838d","__wbg_getRandomValues_37fa2ca9e4e07fab","getRandomValues","__wbg_buffer_085ec1f694018c4f","__wbg_set_5cf90238115182c3","__wbg_newwithbyteoffsetandlength_6da8e527659b86aa","__wbg_randomFillSync_dc1e9a60c158336d","randomFillSync","__wbg_crypto_c48a774b022d20ac","crypto","__wbg_process_298734cf255a885d","process","__wbg_versions_e2e78e134e3e5d01","versions","__wbg_node_1cd7a5d853dbea79","node","__wbindgen_is_string","__wbg_msCrypto_bcb970640f50a1e8","msCrypto","__wbg_newwithlength_e5d69174d6984cd7","__wbg_require_8f08ceecec0f4fee","require","__wbg_length_fff51ee6522a1a18","__wbg_get_44be0491f933a435","__wbg_self_1ff1d729e9aae938","self","__wbg_window_5f4faef6c12b79ec","window","__wbg_globalThis_1d39714405582d3c","globalThis","__wbg_global_651f05c6a0944d1c","global","__wbindgen_is_undefined","__wbg_newnoargs_581967eacc0e2604","Function","__wbg_has_c5fcd020291e56b8","has","__wbg_fetch_8eaf01857a5bb21f","fetch","__wbg_fetch_b5d6bebed1e6c2d2","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_rethrow","__wbg_then_b2267541e2a73865","then","__wbg_then_f7e06ee3c11698eb","__wbg_resolve_53698b95aaf7fcf8","__wbg_waitAsync_60fb5e2e86467e31","Atomics","waitAsync","__wbg_new_a0af68041688e8fd","__wbg_waitAsync_73fd6eb3bace0a8d","__wbg_async_e1a2a669aacf35ff","__wbg_value_555e4f564193db05","__wbindgen_link_22046963fe0b707a","encodeURIComponent","__wbg_new_8e7322f46d5d019c","__wbg_setonmessage_f0bd0280573b7084","onmessage","__wbg_of_3f69007bb4eeae65","of","__wbg_postMessage_8c609e2bde333d9c","__wbg_data_ab99ae4a2e1e8bc9","data","__wbg_newwithstrandinit_cad5cd6038c7ff5d","Request","__wbg_status_114ef6fe27fb8b00","__wbg_responseText_da275667251fd153","responseText","__wbindgen_closure_wrapper5654","__wbindgen_closure_wrapper5677","__wbg_init_memory","maybe_memory","Memory","initial","maximum","shared","__wbg_finalize_init","exports","__wbindgen_start","initSync","Module","input","URL","freeze","__proto__","ProgramManager","ProgramManager$1","RecordCiphertext$1","default","wasm_path","wasmInitThreadPool","Private","opt","importHook","serverPath","initializeHook","final_path","Cargo","threads","navigator","hardwareConcurrency","info","defaultHost","keyProvider","AleoKeyProvider","programManager","useCache","lastLocalProgram","executeOffline","localProgram","aleoFunction","privateKey","proveExecution","startTime","performance","now","createProgramFromSource","cacheKey","networkClient","getProgramImports","keys","synthesizeKeys","cacheKeys","keyParams","AleoKeyProviderParams","run","outputs","executionString","getPrivateKey","workerAPI","expose","ok","post","options","method","AleoNetworkClient","host","account","setAccount","getAccount","setHost","fetchData","json","findUnspentRecords","startHeight","endHeight","amounts","maxMicrocredits","nonces","records","start","end","resolvedPrivateKey","latestHeight","failures","totalRecordValue","_privateKey","viewKey","blockHeight","getLatestHeight","blocks","getBlockRange","transactions","j","confirmedTransaction","transitions","k","transition","l","output","recordPlaintext","includes","serialNumber","getTransitionId","amounts_found","getBlock","height","getDeploymentTransactionIDForProgram","replace","getDeploymentTransactionForProgram","transaction_id","getTransaction","getLatestBlock","getLatestCommittee","programId","getProgramObject","inputProgram","importList","import_id","hasOwnProperty","programSource","nestedImports","key","logAndThrow","getProgramImportNames","getProgramMappingNames","getProgramMappingValue","mappingName","getStateRoot","getTransactions","getTransactionsInMempool","inputOrOutputID","submitTransaction","transaction_string","body","proverUri","verifierUri","params","cacheOption","keyUris","fetchBytes","KEY_STORE","Map","clearCache","clear","keyId","containsKeys","deleteKeys","delete","provingKeyBytes","verifyingKeyBytes","functionKeys","proverUrl","verifierUrl","fetchKeys","bondPublicKeys","CREDITS_PROGRAM_KEYS","bond_public","prover","verifier","locator","claimUnbondPublicKeys","claim_unbond_public","transferKeys","visibility","PRIVATE_TRANSFER","transfer_private","PRIVATE_TO_PUBLIC_TRANSFER","transfer_private_to_public","PUBLIC_TRANSFER","transfer_public","PUBLIC_TO_PRIVATE_TRANSFER","transfer_public_to_private","joinKeys","join","splitKeys","split","feePrivateKeys","fee_private","feePublicKeys","fee_public","inclusion","set_validator_state","unbond_delegator_as_validator","unbond_public","text","inner","unBondPublicKeys","recordProvider","setKeyProvider","setRecordProvider","deploy","fee","privateFee","recordSearchParams","feeRecord","programObject","feeKeys","deploymentPrivateKey","getCreditsRecord","feeProvingKey","feeVerifyingKey","tx","programName","functionName","keySearchParams","offlineQuery","executionPrivateKey","execute","recordOne","recordTwo","joinProvingKey","joinVerifyingKey","splitAmount","amountRecord","splitProvingKey","splitVerifyingKey","keyPair","amount","transferType","validateTransferType","transferProvingKey","transferVerifyingKey","requiresAmountRecord","buildTransferPublicTransaction","transfer","buildBondPublicTransaction","Math","trunc","offlineParams","executionParams","creditsProgram","bondPublic","buildUnbondPublicTransaction","unbondPublic","buildClaimUnbondPublicTransaction","claimUnbondPublic","setValidatorState","validator_state","unbondDelegatorAsValidator","verifyExecution","executionResponse","verifyProgram","findCreditsRecord","PRIVATE_TRANSFER_TYPES","VALID_TRANSFER_TYPES","Set","proxyMarker","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","proxyTransferHandler","canHandle","serialize","port1","port2","MessageChannel","deserialize","port","ep","target","pendingListeners","ev","resolver","createProxy","wrap","transferHandlers","serialized","isError","assign","allowedOrigins","callback","origin","allowedOrigin","RegExp","test","isAllowedOrigin","path","argumentList","map","fromWireValue","returnValue","parent","reduce","prop","rawValue","proxy","transfers","transferCache","catch","wireValue","transferables","toWireValue","removeEventListener","closeEndPoint","TypeError","endpoint","isMessagePort","close","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","r","p","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","arr","concat","handler","serializedValue","msg","floor","random","Number","MAX_SAFE_INTEGER","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","m","queue","d","forEach","fn","hasAwait","currentDeps","outerResolve","reject","depQueues","promise","rej","deps","dep","wrapDeps","getResult","fnQueue","q","add","err","definition","o","defineProperty","enumerable","u","chunkId","g","scriptUrl","importScripts","location","document","currentScript","tagName","toUpperCase","src","scripts","getElementsByTagName"],"sourceRoot":""}