{"version":3,"file":"992.bundle.js","mappings":"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","sources":["webpack://deposit_vault/../../src/account.ts","webpack://deposit_vault/../../src/record-provider.ts","webpack://deposit_vault/../../src/utils.ts","webpack://deposit_vault/../../src/network-client.ts","webpack://deposit_vault/../../src/constants.ts","webpack://deposit_vault/../../src/function-key-provider.ts","webpack://deposit_vault/../../src/program-manager.ts","webpack://deposit_vault/tmp/index.js","webpack://deposit_vault/tmp/aleo_wasm.js","webpack://deposit_vault/./node_modules/comlink/dist/esm/comlink.mjs"],"sourcesContent":["import {\n  Address,\n  ComputeKey,\n  PrivateKey,\n  Signature,\n  ViewKey,\n  PrivateKeyCiphertext,\n  RecordCiphertext,\n  RecordPlaintext,\n} from \"./wasm\";\n\ninterface AccountParam {\n  privateKey?: string;\n  seed?: Uint8Array;\n}\n\n/**\n * Key Management class. Enables the creation of a new Aleo Account, importation of an existing account from\n * an existing private key or seed, and message signing and verification functionality. An Aleo Account is generated\n * from a randomly generated seed (number) from which an account private key, view key, and a public account address are\n * derived. The private key lies at the root of an Aleo account. It is a highly sensitive secret and should be protected\n * as it allows for creation of Aleo Program executions and arbitrary value transfers. The View Key allows for decryption\n * of a user's activity on the blockchain. The Address is the public address to which other users of Aleo can send Aleo\n * credits and other records to. This class should only be used in environments where the safety of the underlying key\n * material can be assured.\n *\n * @example\n * import { Account } from \"@provablehq/sdk/testnet.js\";\n *\n * // Create a new account\n * const myRandomAccount = new Account();\n *\n * // Create an account from a randomly generated seed\n * const seed = new Uint8Array([94, 91, 52, 251, 240, 230, 226, 35, 117, 253, 224, 210, 175, 13, 205, 120, 155, 214, 7, 169, 66, 62, 206, 50, 188, 40, 29, 122, 40, 250, 54, 18]);\n * const mySeededAccount = new Account({seed: seed});\n *\n * // Create an account from an existing private key\n * const myExistingAccount = new Account({privateKey: process.env.privateKey});\n *\n * // Sign a message\n * const hello_world = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100]);\n * const signature = myRandomAccount.sign(hello_world);\n *\n * // Verify a signature\n * assert(myRandomAccount.verify(hello_world, signature));\n */\nexport class Account {\n  _privateKey: PrivateKey;\n  _viewKey: ViewKey;\n  _computeKey: ComputeKey;\n  _address: Address;\n\n  constructor(params: AccountParam = {}) {\n    try {\n      this._privateKey = this.privateKeyFromParams(params);\n    } catch (e) {\n      console.error(\"Wrong parameter\", e);\n      throw new Error(\"Wrong Parameter\");\n    }\n    this._viewKey = ViewKey.from_private_key(this._privateKey);\n    this._computeKey = ComputeKey.from_private_key(this._privateKey);\n    this._address = Address.from_private_key(this._privateKey);\n  }\n\n  /**\n   * Attempts to create an account from a private key ciphertext\n   * @param {PrivateKeyCiphertext | string} ciphertext The encrypted private key ciphertext or its string representation\n   * @param {string} password The password used to decrypt the private key ciphertext\n   * @returns {Account} A new Account instance created from the decrypted private key\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create an account object from a previously encrypted ciphertext and password.\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   */\n  public static fromCiphertext(ciphertext: PrivateKeyCiphertext | string, password: string): Account {\n    try {\n      ciphertext = (typeof ciphertext === \"string\") ? PrivateKeyCiphertext.fromString(ciphertext) : ciphertext;\n      const _privateKey = PrivateKey.fromPrivateKeyCiphertext(ciphertext, password);\n      return new Account({ privateKey: _privateKey.to_string() });\n    } catch(e) {\n      throw new Error(\"Wrong password or invalid ciphertext\");\n    }\n  }\n\n  /**\n   * Creates a PrivateKey from the provided parameters.\n   * @param {AccountParam} params The parameters containing either a private key string or a seed\n   * @returns {PrivateKey} A PrivateKey instance derived from the provided parameters\n   */\n  private privateKeyFromParams(params: AccountParam): PrivateKey {\n    if (params.seed) {\n      return PrivateKey.from_seed_unchecked(params.seed);\n    }\n    if (params.privateKey) {\n      return PrivateKey.from_string(params.privateKey);\n    }\n    return new PrivateKey();\n  }\n\n  /**\n   * Returns the PrivateKey associated with the account.\n   * @returns {PrivateKey} The private key of the account\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const privateKey = account.privateKey();\n   */\n  privateKey(): PrivateKey {\n    return this._privateKey;\n  }\n\n  /**\n   * Returns the ViewKey associated with the account.\n   * @returns {ViewKey} The view key of the account\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const viewKey = account.viewKey();\n   */\n  viewKey(): ViewKey {\n    return this._viewKey;\n  }\n\n  /**\n   * Returns the ComputeKey associated with the account.\n   * @returns {ComputeKey} The compute key of the account\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const computeKey = account.computeKey();\n   */\n  computeKey(): ComputeKey {\n    return this._computeKey;\n  }\n\n  /**\n   * Returns the Aleo address associated with the account.\n   * @returns {Address} The public address of the account\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const address = account.address();\n   */\n  address(): Address {\n    return this._address;\n  }\n\n  /**\n   * Deep clones the Account.\n   * @returns {Account} A new Account instance with the same private key\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const clonedAccount = account.clone();\n   */\n  clone(): Account {\n    return new Account({ privateKey: this._privateKey.to_string() });\n  }\n\n  /**\n   * Returns the address of the account in a string representation.\n   *\n   * @returns {string} The string representation of the account address\n   */\n  toString(): string {\n    return this.address().to_string()\n  }\n\n  /**\n   * Encrypts the account's private key with a password.\n   *\n   * @param {string} password Password to encrypt the private key.\n   * @returns {PrivateKeyCiphertext} The encrypted private key ciphertext\n   *\n   * @example\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * const account = new Account();\n   * const ciphertext = account.encryptAccount(\"password\");\n   * process.env.ciphertext = ciphertext.toString();\n   */\n  encryptAccount(password: string): PrivateKeyCiphertext {\n    return this._privateKey.toCiphertext(password);\n  }\n\n  /**\n   * Decrypts an encrypted record string into a plaintext record object.\n   *\n   * @param {string} ciphertext A string representing the ciphertext of a record.\n   * @returns {RecordPlaintext} The decrypted record plaintext\n   *\n   * @example\n   * // Import the AleoNetworkClient and Account classes\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a connection to the Aleo network and an account\n   * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n   * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);\n   *\n   * // Get the record ciphertexts from a transaction.\n   * const transaction = await networkClient.getTransactionObject(\"at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd\");\n   * const records = transaction.records();\n   *\n   * // Decrypt any records the account owns.\n   * const decryptedRecords = [];\n   * for (const record of records) {\n   *    if (account.decryptRecord(record)) {\n   *      decryptedRecords.push(record);\n   *    }\n   * }\n   */\n  decryptRecord(ciphertext: string): RecordPlaintext {\n    return this._viewKey.decrypt(ciphertext);\n  }\n\n  /**\n   * Decrypts an array of Record ciphertext strings into an array of record plaintext objects.\n   *\n   * @param {string[]} ciphertexts An array of strings representing the ciphertexts of records.\n   * @returns {RecordPlaintext[]} An array of decrypted record plaintexts\n   *\n   * @example\n   * // Import the AleoNetworkClient and Account classes\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a connection to the Aleo network and an account\n   * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n   * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);\n   *\n   * // Get the record ciphertexts from a transaction.\n   * const transaction = await networkClient.getTransactionObject(\"at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd\");\n   * const records = transaction.records();\n   *\n   * // Decrypt any records the account owns. If the account owns no records, the array will be empty.\n   * const decryptedRecords = account.decryptRecords(records);\n   */\n  decryptRecords(ciphertexts: string[]): RecordPlaintext[] {\n    return ciphertexts.map((ciphertext) => this._viewKey.decrypt(ciphertext));\n  }\n\n  /**\n   * Determines whether the account owns a ciphertext record.\n   * @param {RecordCiphertext | string} ciphertext The record ciphertext to check ownership of\n   * @returns {boolean} True if the account owns the record, false otherwise\n   *\n   * @example\n   * // Import the AleoNetworkClient and Account classes\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a connection to the Aleo network and an account\n   * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n   * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);\n   *\n   * // Get the record ciphertexts from a transaction and check ownership of them.\n   * const transaction = await networkClient.getTransactionObject(\"at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd\");\n   * const records = transaction.records();\n   *\n   * // Check if the account owns any of the record ciphertexts present in the transaction.\n   * const ownedRecords = [];\n   * for (const record of records) {\n   *    if (account.ownsRecordCiphertext(record)) {\n   *      ownedRecords.push(record);\n   *    }\n   * }\n   */\n  ownsRecordCiphertext(ciphertext: RecordCiphertext | string): boolean {\n    if (typeof ciphertext === 'string') {\n      try {\n        const ciphertextObject = RecordCiphertext.fromString(ciphertext);\n        return ciphertextObject.isOwner(this._viewKey);\n      }\n      catch (e) {\n        return false;\n      }\n    }\n    else {\n      return ciphertext.isOwner(this._viewKey);\n    }\n  }\n\n  /**\n   * Signs a message with the account's private key.\n   * Returns a Signature.\n   *\n   * @param {Uint8Array} message Message to be signed.\n   * @returns {Signature} Signature over the message in bytes.\n   *\n   * @example\n   * // Import the Account class\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a connection to the Aleo network and an account\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   *\n   * // Create an account and a message to sign.\n   * const account = new Account();\n   * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n   * const signature = account.sign(message);\n   *\n   * // Verify the signature.\n   * assert(account.verify(message, signature));\n   */\n  sign(message: Uint8Array): Signature {\n    return this._privateKey.sign(message);\n  }\n\n  /**\n   * Verifies the Signature on a message.\n   *\n   * @param {Uint8Array} message Message in bytes to be signed.\n   * @param {Signature} signature Signature to be verified.\n   * @returns {boolean} True if the signature is valid, false otherwise.\n   *\n   * @example\n   * // Import the Account class\n   * import { Account } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a connection to the Aleo network and an account\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   *\n   * // Sign a message.\n   * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n   * const signature = account.sign(message);\n   *\n   * // Verify the signature.\n   * assert(account.verify(message, signature));\n   */\n  verify(message: Uint8Array, signature: Signature): boolean {\n    return this._address.verify(message, signature);\n  }\n}\n","import { RecordPlaintext } from \"./wasm\";\nimport { logAndThrow } from \"./utils\";\nimport { Account } from \"./account\";\nimport { AleoNetworkClient } from \"./network-client\";\n\n/**\n * Interface for record search parameters. This allows for arbitrary search parameters to be passed to record provider\n * implementations.\n */\ninterface RecordSearchParams {\n    [key: string]: any; // This allows for arbitrary keys with any type values\n}\n\n/**\n * Interface for a record provider. A record provider is used to find records for use in deployment and execution\n * transactions on the Aleo Network. A default implementation is provided by the NetworkRecordProvider class. However,\n * a custom implementation can be provided (say if records are synced locally to a database from the network) by\n * implementing this interface.\n */\ninterface RecordProvider {\n    account: Account\n\n    /**\n     * Find a credits.aleo record with a given number of microcredits from the chosen provider\n     *\n     * @param {number} microcredits The number of microcredits to search for\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * @example\n     * // A class implementing record provider can be used to find a record with a given number of microcredits\n     * const record = await recordProvider.findCreditsRecord(5000, true, []);\n     *\n     * // When a record is found but not yet used, its nonce should be added to the nonces array so that it is not\n     * // found again if a subsequent search is performed\n     * const record2 = await recordProvider.findCreditsRecord(5000, true, [record.nonce()]);\n     *\n     * // When the program manager is initialized with the record provider it will be used to find automatically find\n     * // fee records and amount records for value transfers so that they do not need to be specified manually\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     */\n    findCreditsRecord(microcredits: number, unspent: boolean,  nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext>;\n\n    /**\n     * Find a list of credit.aleo records with a given number of microcredits from the chosen provider\n     *\n     * @param {number} microcreditAmounts A list of separate microcredit amounts to search for (e.g. [5000, 100000])\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext[]>} A list of records with a value greater or equal to the amounts specified if such records exist, otherwise an error\n     *\n     * @example\n     * // A class implementing record provider can be used to find a record with a given number of microcredits\n     * const records = await recordProvider.findCreditsRecords([5000, 5000], true, []);\n     *\n     * // When a record is found but not yet used, it's nonce should be added to the nonces array so that it is not\n     * // found again if a subsequent search is performed\n     * const nonces = [];\n     * records.forEach(record => { nonces.push(record.nonce()) });\n     * const records2 = await recordProvider.findCreditsRecord(5000, true, nonces);\n     *\n     * // When the program manager is initialized with the record provider it will be used to find automatically find\n     * // fee records and amount records for value transfers so that they do not need to be specified manually\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     */\n    findCreditsRecords(microcreditAmounts: number[], unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext[]>;\n\n    /**\n     * Find an arbitrary record\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * @example\n     * // The RecordSearchParams interface can be used to create parameters for custom record searches which can then\n     * // be passed to the record provider. An example of how this would be done for the credits.aleo program is shown\n     * // below.\n     *\n     * class CustomRecordSearch implements RecordSearchParams {\n     *     startHeight: number;\n     *     endHeight: number;\n     *     amount: number;\n     *     program: string;\n     *     recordName: string;\n     *     constructor(startHeight: number, endHeight: number, credits: number, maxRecords: number, programName: string, recordName: string) {\n     *         this.startHeight = startHeight;\n     *         this.endHeight = endHeight;\n     *         this.amount = amount;\n     *         this.program = programName;\n     *         this.recordName = recordName;\n     *     }\n     * }\n     *\n     * const params = new CustomRecordSearch(0, 100, 5000, \"credits.aleo\", \"credits\");\n     *\n     * const record = await recordProvider.findRecord(true, [], params);\n     */\n    findRecord(unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext>;\n\n    /**\n     * Find multiple records from arbitrary programs\n     *\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * // The RecordSearchParams interface can be used to create parameters for custom record searches which can then\n     * // be passed to the record provider. An example of how this would be done for the credits.aleo program is shown\n     * // below.\n     *\n     * class CustomRecordSearch implements RecordSearchParams {\n     *     startHeight: number;\n     *     endHeight: number;\n     *     amount: number;\n     *     maxRecords: number;\n     *     programName: string;\n     *     recordName: string;\n     *     constructor(startHeight: number, endHeight: number, credits: number, maxRecords: number, programName: string, recordName: string) {\n     *         this.startHeight = startHeight;\n     *         this.endHeight = endHeight;\n     *         this.amount = amount;\n     *         this.maxRecords = maxRecords;\n     *         this.programName = programName;\n     *         this.recordName = recordName;\n     *     }\n     * }\n     *\n     * const params = new CustomRecordSearch(0, 100, 5000, 2, \"credits.aleo\", \"credits\");\n     * const records = await recordProvider.findRecord(true, [], params);\n     */\n    findRecords(unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext[]>;\n}\n\n/**\n * A record provider implementation that uses the official Aleo API to find records for usage in program execution and\n * deployment, wallet functionality, and other use cases.\n */\nclass NetworkRecordProvider implements RecordProvider {\n    account: Account;\n    networkClient: AleoNetworkClient;\n    constructor(account: Account, networkClient: AleoNetworkClient) {\n        this.account = account;\n        this.networkClient = networkClient;\n    }\n\n    /**\n     * Set the account used to search for records\n     *\n     * @param {Account} account The account to use for searching for records\n     */\n    setAccount(account: Account) {\n        this.account = account;\n    }\n\n    /**\n     * Find a list of credit records with a given number of microcredits by via the official Aleo API\n     *\n     * @param {number[]} microcredits The number of microcredits to search for\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * @example\n     * // Create a new NetworkRecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // The record provider can be used to find records with a given number of microcredits\n     * const record = await recordProvider.findCreditsRecord(5000, true, []);\n     *\n     * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not\n     * // found again if a subsequent search is performed\n     * const records = await recordProvider.findCreditsRecords(5000, true, [record.nonce()]);\n     *\n     * // When the program manager is initialized with the record provider it will be used to find automatically find\n     * // fee records and amount records for value transfers so that they do not need to be specified manually\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * */\n    async findCreditsRecords(microcredits: number[], unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext[]> {\n        let startHeight = 0;\n        let endHeight = 0;\n        let maxAmount = undefined;\n\n        if (searchParameters) {\n            if (\"startHeight\" in searchParameters && typeof searchParameters[\"startHeight\"] == \"number\") {\n                startHeight = searchParameters[\"startHeight\"];\n            }\n\n            if (\"endHeight\" in searchParameters && typeof searchParameters[\"endHeight\"] == \"number\") {\n                endHeight = searchParameters[\"endHeight\"];\n            }\n\n            if (\"amounts\" in searchParameters && Array.isArray(searchParameters[\"amounts\"]) && searchParameters[\"amount\"].every((item: any) => typeof item === 'number')) {\n                microcredits = searchParameters[\"amounts\"];\n            }\n\n            if (\"maxAmount\" in searchParameters && typeof searchParameters[\"maxAmount\"] == \"number\") {\n                maxAmount = searchParameters[\"maxAmount\"];\n            }\n\n            if (\"unspent\" in searchParameters && typeof searchParameters[\"unspent\"] == \"boolean\") {\n                unspent = searchParameters[\"unspent\"]\n            }\n        }\n\n        // If the end height is not specified, use the current block height\n        if (endHeight == 0) {\n            const end = await this.networkClient.getLatestHeight();\n            endHeight = end;\n        }\n\n        // If the start height is greater than the end height, throw an error\n        if (startHeight >= endHeight) {\n            logAndThrow(\"Start height must be less than end height\");\n        }\n\n        return await this.networkClient.findRecords(startHeight, endHeight, unspent, [\"credits.aleo\"], microcredits, maxAmount, nonces, this.account.privateKey());\n    }\n\n    /**\n     * Find a credit record with a given number of microcredits by via the official Aleo API\n     *\n     * @param {number} microcredits The number of microcredits to search for\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * @example\n     * // Create a new NetworkRecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // The record provider can be used to find records with a given number of microcredits\n     * const record = await recordProvider.findCreditsRecord(5000, true, []);\n     *\n     * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not\n     * // found again if a subsequent search is performed\n     * const records = await recordProvider.findCreditsRecords(5000, true, [record.nonce()]);\n     *\n     * // When the program manager is initialized with the record provider it will be used to find automatically find\n     * // fee records and amount records for value transfers so that they do not need to be specified manually\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     */\n    async findCreditsRecord(microcredits: number, unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext> {\n        let records = null;\n\n        try {\n            records = await this.findCreditsRecords([microcredits], unspent, nonces, searchParameters);\n        } catch (e) {\n            console.log(\"No records found with error:\", e);\n        }\n\n        if (records && records.length > 0) {\n            return records[0];\n        }\n\n        console.error(\"Record not found with error:\", records);\n        throw new Error(\"Record not found\");\n    }\n\n    /**\n     * Find an arbitrary record. WARNING: This function is not implemented yet and will throw an error.\n     */\n    async findRecord(unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext> {\n        throw new Error(\"Not implemented\");\n    }\n\n    /**\n     * Find multiple records from a specified program.\n     */\n    async findRecords(unspent: boolean, nonces?: string[], searchParameters?: RecordSearchParams): Promise<RecordPlaintext[]> {\n        let startHeight = 0;\n        let endHeight = 0;\n        let amounts = undefined;\n        let maxAmount = undefined;\n        let programs = undefined;\n\n        if (searchParameters) {\n            if (\"startHeight\" in searchParameters && typeof searchParameters[\"startHeight\"] == \"number\") {\n                startHeight = searchParameters[\"startHeight\"];\n            }\n\n            if (\"endHeight\" in searchParameters && typeof searchParameters[\"endHeight\"] == \"number\") {\n                endHeight = searchParameters[\"endHeight\"];\n            }\n\n            if (\"amounts\" in searchParameters && Array.isArray(searchParameters[\"amounts\"]) && searchParameters[\"amounts\"].every((item: any) => typeof item === 'number')) {\n                amounts = searchParameters[\"amounts\"];\n            }\n\n            if (\"maxAmount\" in searchParameters && typeof searchParameters[\"maxAmount\"] == \"number\") {\n                maxAmount = searchParameters[\"maxAmount\"];\n            }\n\n            if (\"nonces\" in searchParameters && Array.isArray(searchParameters[\"nonces\"]) && searchParameters[\"nonces\"].every((item: any) => typeof item === \"string\")) {\n                nonces = searchParameters[\"nonces\"];\n            }\n\n            if (\"program\" in searchParameters && typeof searchParameters[\"program\"] == \"string\") {\n                programs = [searchParameters[\"program\"]];\n            }\n\n            if (\"programs\" in searchParameters && Array.isArray(searchParameters[\"programs\"]) && searchParameters[\"programs\"].every((item: any) => typeof item === \"string\")) {\n                programs = searchParameters[\"programs\"];\n            }\n\n            if (\"unspent\" in searchParameters && typeof searchParameters[\"unspent\"] == \"boolean\") {\n                unspent = searchParameters[\"unspent\"]\n            }\n        }\n\n        // If the end height is not specified, use the current block height\n        if (endHeight == 0) {\n            const end = await this.networkClient.getLatestHeight();\n            endHeight = end;\n        }\n\n        // If the start height is greater than the end height, throw an error\n        if (startHeight >= endHeight) {\n            logAndThrow(\"Start height must be less than end height\");\n        }\n\n        return await this.networkClient.findRecords(startHeight, endHeight, unspent, programs, amounts, maxAmount, nonces, this.account.privateKey());\n    }\n\n}\n\n/**\n * BlockHeightSearch is a RecordSearchParams implementation that allows for searching for records within a given\n * block height range.\n *\n * @example\n * // Create a new BlockHeightSearch\n * const params = new BlockHeightSearch(89995, 99995);\n *\n * // Create a new NetworkRecordProvider\n * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n * const keyProvider = new AleoKeyProvider();\n * const recordProvider = new NetworkRecordProvider(account, networkClient);\n *\n * // The record provider can be used to find records with a given number of microcredits and the block height search\n * // can be used to find records within a given block height range\n * const record = await recordProvider.findCreditsRecord(5000, true, [], params);\n *\n */\nclass BlockHeightSearch implements RecordSearchParams {\n    startHeight: number;\n    endHeight: number;\n    constructor(startHeight: number, endHeight: number) {\n        this.startHeight = startHeight;\n        this.endHeight = endHeight;\n    }\n}\n\nexport { BlockHeightSearch, NetworkRecordProvider, RecordProvider, RecordSearchParams};\n","export function logAndThrow(message: string): never {\n    console.error(message);\n    throw new Error(message);\n}\n\n\nexport function parseJSON(json: string): any {\n    function revive(key: string, value: any, context: any) {\n        if (Number.isInteger(value)) {\n            return BigInt(context.source);\n        } else {\n            return value;\n        }\n    }\n\n    return JSON.parse(json, revive as any);\n}\n\n\nexport async function get(url: URL | string, options?: RequestInit) {\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n        throw new Error(response.status + \" could not get URL \" + url);\n    }\n\n    return response;\n}\n\n\nexport async function post(url: URL | string, options: RequestInit) {\n    options.method = \"POST\";\n\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n        throw new Error(response.status + \" could not post URL \" + url);\n    }\n\n    return response;\n}\n","import { get, post, parseJSON, logAndThrow } from \"./utils\";\nimport { Account } from \"./account\";\nimport { BlockJSON } from \"./models/blockJSON\";\nimport { TransactionJSON } from \"./models/transaction/transactionJSON\";\nimport {\n  Address,\n  Plaintext,\n  RecordCiphertext,\n  Program,\n  RecordPlaintext,\n  PrivateKey,\n  Transaction,\n} from \"./wasm\";\nimport { ConfirmedTransactionJSON } from \"./models/confirmed_transaction\";\n\ntype ProgramImports = { [key: string]: string | Program };\n\ninterface AleoNetworkClientOptions {\n  headers?: { [key: string]: string };\n}\n\n/**\n * Client library that encapsulates REST calls to publicly exposed endpoints of Aleo nodes. The methods provided in this\n * allow users to query public information from the Aleo blockchain and submit transactions to the network.\n *\n * @param {string} host\n * @example\n * // Connection to a local node.\n * const localNetworkClient = new AleoNetworkClient(\"http://0.0.0.0:3030\", undefined, account);\n *\n * // Connection to a public beacon node\n * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n * const publicNetworkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined, account);\n */\nclass AleoNetworkClient {\n  host: string;\n  headers: { [key: string]: string };\n  account: Account | undefined;\n\n  constructor(host: string, options?: AleoNetworkClientOptions) {\n    this.host = host + \"/%%NETWORK%%\";\n\n    if (options && options.headers) {\n      this.headers = options.headers;\n\n    } else {\n      this.headers = {\n        // This is replaced by the actual version by a Rollup plugin\n        \"X-Aleo-SDK-Version\": \"%%VERSION%%\",\n      };\n    }\n  }\n\n  /**\n   * Set an account to use in networkClient calls\n   *\n   * @param {Account} account Set an account to use for record scanning functions.\n   * @example\n   * import { Account, AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\");\n   * const account = new Account();\n   * networkClient.setAccount(account);\n   */\n  setAccount(account: Account) {\n    this.account = account;\n  }\n\n  /**\n   * Return the Aleo account used in the networkClient\n   *\n   * @example\n   * const account = networkClient.getAccount();\n   */\n  getAccount(): Account | undefined {\n    return this.account;\n  }\n\n  /**\n   * Set a new host for the networkClient\n   *\n   * @param {string} host The address of a node hosting the Aleo API\n   * @param host\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a networkClient that connects to a local node.\n   * const networkClient = new AleoNetworkClient(\"http://0.0.0.0:3030\", undefined);\n   *\n   * // Set the host to a public node.\n   * networkClient.setHost(\"http://api.explorer.provable.com/v1\");\n   */\n  setHost(host: string) {\n    this.host = host + \"/%%NETWORK%%\";\n  }\n\n  /**\n   * Fetches data from the Aleo network and returns it as a JSON object.\n   *\n   * @param url The URL to fetch data from.\n   */\n  async fetchData<Type>(\n      url = \"/\",\n  ): Promise<Type> {\n    try {\n      return parseJSON(await this.fetchRaw(url));\n    } catch (error) {\n      throw new Error(`Error fetching data: ${error}`);\n    }\n  }\n\n  /**\n   * Fetches data from the Aleo network and returns it as an unparsed string.\n   *\n   * This method should be used when it is desired to reconstitute data returned\n   * from the network into a WASM object.\n   *\n   * @param url\n   */\n  async fetchRaw(\n      url = \"/\",\n  ): Promise<string> {\n    try {\n      const response = await get(this.host + url, {\n        headers: this.headers\n      });\n      return await response.text();\n    } catch (error) {\n      throw new Error(`Error fetching data: ${error}`);\n    }\n  }\n\n  /**\n   * Attempt to find records in the Aleo blockchain.\n   *\n   * @param {number} startHeight - The height at which to start searching for unspent records\n   * @param {number} endHeight - The height at which to stop searching for unspent records\n   * @param {boolean} unspent - Whether to search for unspent records only\n   * @param {string[]} programs - The program(s) to search for unspent records in\n   * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])\n   * @param {number} maxMicrocredits - The maximum number of microcredits to search for\n   * @param {string[]} nonces - The nonces of already found records to exclude from the search\n   * @param {string | PrivateKey} privateKey - An optional private key to use to find unspent records.\n   * @returns {Promise<Array<RecordPlaintext>>} An array of records belonging to the account configured in the network client.\n   *\n   * @example\n   * import { Account, AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Import an account from a ciphertext and password.\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * networkClient.setAccount(account);\n   *\n   * // Find specific amounts\n   * const startHeight = 500000;\n   * const amounts = [600000, 1000000];\n   * const records = networkClient.findRecords(startHeight, undefined, true, [\"credits.aleo\"] amounts);\n   *\n   * // Find specific amounts with a maximum number of cumulative microcredits\n   * const maxMicrocredits = 100000;\n   * const records = networkClient.findRecords(startHeight, undefined, true, [\"credits.aleo\"] undefined, maxMicrocredits);\n   */\n  async findRecords(\n      startHeight: number,\n      endHeight: number | undefined,\n      unspent: boolean = false,\n      programs?: string[],\n      amounts?: number[] | undefined,\n      maxMicrocredits?: number | undefined,\n      nonces?: string[] | undefined,\n      privateKey?: string | PrivateKey | undefined,\n  ): Promise<Array<RecordPlaintext>> {\n    nonces = nonces || [];\n    // Ensure start height is not negative\n    if (startHeight < 0) {\n      throw new Error(\"Start height must be greater than or equal to 0\");\n    }\n\n    // Initialize search parameters\n    const records = new Array<RecordPlaintext>();\n    let start;\n    let end;\n    let resolvedPrivateKey: PrivateKey;\n    let failures = 0;\n    let totalRecordValue = BigInt(0);\n    let latestHeight: number;\n\n    // Ensure a private key is present to find owned records\n    if (typeof privateKey === \"undefined\") {\n      if (typeof this.account === \"undefined\") {\n        throw new Error(\"Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient\");\n      } else {\n        resolvedPrivateKey = this.account._privateKey;\n      }\n    } else {\n      try {\n        resolvedPrivateKey = privateKey instanceof PrivateKey ? privateKey : PrivateKey.from_string(privateKey);\n      } catch (error) {\n        throw new Error(\"Error parsing private key provided.\");\n      }\n    }\n    const viewKey = resolvedPrivateKey.to_view_key();\n\n    // Get the latest height to ensure the range being searched is valid\n    try {\n      const blockHeight = await this.getLatestHeight();\n      if (typeof blockHeight === \"number\") {\n        latestHeight = blockHeight;\n      } else {\n        throw new Error(`Error fetching latest block height: Expected type 'number' got '${typeof blockHeight}'`);\n      }\n    } catch (error) {\n      throw new Error(`Error fetching latest block height: ${error}`);\n    }\n\n    // If no end height is specified or is greater than the latest height, set the end height to the latest height\n    if (typeof endHeight === \"number\" && endHeight <= latestHeight) {\n      end = endHeight\n    } else {\n      end = latestHeight;\n    }\n\n    // If the starting is greater than the ending height, return an error\n    if (startHeight > end) {\n      throw new Error(\"Start height must be less than or equal to end height.\");\n    }\n\n    // Iterate through blocks in reverse order in chunks of 50\n    while (end > startHeight) {\n      start = end - 50;\n      if (start < startHeight) {\n        start = startHeight;\n      }\n      try {\n        // Get 50 blocks (or the difference between the start and end if less than 50)\n        const blocks = await this.getBlockRange(start, end);\n        end = start;\n        // Iterate through blocks to find unspent records\n        for (let i = 0; i < blocks.length; i++) {\n          const block = blocks[i];\n          const transactions = block.transactions;\n          if (!(typeof transactions === \"undefined\")) {\n            for (let j = 0; j < transactions.length; j++) {\n              const confirmedTransaction = transactions[j];\n              // Search for unspent records in execute transactions of credits.aleo\n              if (confirmedTransaction.type == \"execute\") {\n                const transaction = confirmedTransaction.transaction;\n                if (transaction.execution && !(typeof transaction.execution.transitions == \"undefined\")) {\n                  for (let k = 0; k < transaction.execution.transitions.length; k++) {\n                    const transition = transaction.execution.transitions[k];\n                    // Only search for unspent records in the specified programs.\n                    if (!(typeof programs === \"undefined\")) {\n                      if (!programs.includes(transition.program)) {\n                        continue;\n                      }\n                    }\n                    if (!(typeof transition.outputs == \"undefined\")) {\n                      for (let l = 0; l < transition.outputs.length; l++) {\n                        const output = transition.outputs[l];\n                        if (output.type === \"record\") {\n                          try {\n                            // Create a wasm record ciphertext object from the found output\n                            const record = RecordCiphertext.fromString(output.value);\n                            // Determine if the record is owned by the specified view key\n                            if (record.isOwner(viewKey)) {\n                              // Decrypt the record and get the serial number\n                              const recordPlaintext = record.decrypt(viewKey);\n\n                              // If the record has already been found, skip it\n                              const nonce = recordPlaintext.nonce();\n                              if (nonces.includes(nonce)) {\n                                continue;\n                              }\n\n                              if (unspent) {\n                                // Otherwise record the nonce that has been found\n                                const serialNumber = recordPlaintext.serialNumberString(resolvedPrivateKey, \"credits.aleo\", \"credits\");\n                                // Attempt to see if the serial number is spent\n                                try {\n                                  await this.getTransitionId(serialNumber);\n                                  continue;\n                                } catch (error) {\n                                  console.log(\"Found unspent record!\")\n                                }\n                              }\n\n                              // Add the record to the list of records if the user did not specify amounts.\n                              if (!amounts) {\n                                records.push(recordPlaintext);\n                                // If the user specified a maximum number of microcredits, check if the search has found enough\n                                if (typeof maxMicrocredits === \"number\") {\n                                  totalRecordValue += recordPlaintext.microcredits();\n                                  // Exit if the search has found the amount specified\n                                  if (totalRecordValue >= BigInt(maxMicrocredits)) {\n                                    return records;\n                                  }\n                                }\n                              }\n\n                              // If the user specified a list of amounts, check if the search has found them\n                              if (!(typeof amounts === \"undefined\") && amounts.length > 0) {\n                                let amounts_found = 0;\n                                if (recordPlaintext.microcredits() > amounts[amounts_found]) {\n                                  amounts_found += 1;\n                                  records.push(recordPlaintext);\n                                  // If the user specified a maximum number of microcredits, check if the search has found enough\n                                  if (typeof maxMicrocredits === \"number\") {\n                                    totalRecordValue += recordPlaintext.microcredits();\n                                    // Exit if the search has found the amount specified\n                                    if (totalRecordValue >= BigInt(maxMicrocredits)) {\n                                      return records;\n                                    }\n                                  }\n                                  if (records.length >= amounts.length) {\n                                    return records;\n                                  }\n                                }\n                              }\n                            }\n                          } catch (error) {\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (error) {\n        // If there is an error fetching blocks, log it and keep searching\n        console.warn(\"Error fetching blocks in range: \" + start.toString() + \"-\" + end.toString());\n        console.warn(\"Error: \", error);\n        failures += 1;\n        if (failures > 10) {\n          console.warn(\"10 failures fetching records reached. Returning records fetched so far\");\n          return records;\n        }\n      }\n    }\n    return records;\n  }\n\n  /**\n   * Attempts to find unspent records in the Aleo blockchain.\n   *\n   * @param {number} startHeight - The height at which to start searching for unspent records\n   * @param {number} endHeight - The height at which to stop searching for unspent records\n   * @param {string[]} programs - The program(s) to search for unspent records in\n   * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])\n   * @param {number} maxMicrocredits - The maximum number of microcredits to search for\n   * @param {string[]} nonces - The nonces of already found records to exclude from the search\n   * @param {string | PrivateKey} privateKey - An optional private key to use to find unspent records.\n   * @returns {Promise<Array<RecordPlaintext>>} An array of unspent records belonging to the account configured in the network client.\n   *\n   * @example\n   * import { Account, AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   *\n   * // Create a network client and set an account to search for records with.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * networkClient.setAccount(account);\n   *\n   * // Find specific amounts\n   * const startHeight = 500000;\n   * const endHeight = 550000;\n   * const amounts = [600000, 1000000];\n   * const records = networkClient.findUnspentRecords(startHeight, endHeight, [\"credits.aleo\"], amounts);\n   *\n   * // Find specific amounts with a maximum number of cumulative microcredits\n   * const maxMicrocredits = 100000;\n   * const records = networkClient.findUnspentRecords(startHeight, undefined, [\"credits.aleo\"], undefined, maxMicrocredits);\n   */\n  async findUnspentRecords(\n      startHeight: number,\n      endHeight: number | undefined,\n      programs?: string[],\n      amounts?: number[] | undefined,\n      maxMicrocredits?: number | undefined,\n      nonces?: string[] | undefined,\n      privateKey?: string | PrivateKey | undefined,\n  ): Promise<Array<RecordPlaintext>> {\n    return await this.findRecords(startHeight, endHeight, true, programs, amounts, maxMicrocredits, nonces, privateKey);\n  }\n\n  /**\n   * Returns the contents of the block at the specified block height.\n   *\n   * @param {number} blockHeight - The height of the block to fetch\n   * @returns {Promise<BlockJSON>} A javascript object containing the block at the specified height\n   * \n   * @example\n   * const block = networkClient.getBlock(1234);\n   */\n  async getBlock(blockHeight: number): Promise<BlockJSON> {\n    try {\n      const block = await this.fetchData<BlockJSON>(\"/block/\" + blockHeight);\n      return block;\n    } catch (error) {\n      throw new Error(`Error fetching block ${blockHeight}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the contents of the block with the specified hash.\n   * \n   * @param {string} blockHash The hash of the block to fetch.\n   * @returns {Promise<BlockJSON>} A javascript object representation of the block matching the hash.\n   * \n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const block = networkClient.getBlockByHash(\"ab19dklwl9vp63zu3hwg57wyhvmqf92fx5g8x0t6dr72py8r87pxupqfne5t9\");\n   */\n  async getBlockByHash(blockHash: string): Promise<BlockJSON> {\n      try {\n        const block = await this.fetchData<BlockJSON>(`/block/${blockHash}`);\n        return block;\n      } catch (error) {\n        throw new Error(`Error fetching block ${blockHash}: ${error}`);\n      }\n  }\n\n  /**\n   * Returns a range of blocks between the specified block heights. A maximum of 50 blocks can be fetched at a time.\n   *\n   * @param {number} start Starting block to fetch.\n   * @param {number} end Ending block to fetch. This cannot be more than 50 blocks ahead of the start block.\n   * @returns {Promise<Array<BlockJSON>>} An array of block objects\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Fetch 50 blocks.\n   * const (start, end) = (2050, 2100);\n   * const blockRange = networkClient.getBlockRange(start, end);\n   *\n   * let cursor = start;\n   * blockRange.forEach((block) => {\n   *   assert(block.height == cursor);\n   *   cursor += 1;\n   *  }\n   */\n  async getBlockRange(start: number, end: number): Promise<Array<BlockJSON>> {\n    try {\n      return await this.fetchData<Array<BlockJSON>>(\"/blocks?start=\" + start + \"&end=\" + end);\n    } catch (error) {\n      throw new Error(`Error fetching blocks between ${start} and ${end}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the deployment transaction id associated with the specified program.\n   *\n   * @param {Program | string} program The name of the deployed program OR a wasm Program object.\n   * @returns {Promise<string>} The transaction ID of the deployment transaction.\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Get the transaction ID of the deployment transaction for a program.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const transactionId = networkClient.getDeploymentTransactionIDForProgram(\"hello_hello.aleo\");\n   *\n   * // Get the transaction data for the deployment transaction.\n   * const transaction = networkClient.getTransactionObject(transactionId);\n   *\n   * // Get the verifying keys for the functions in the deployed program.\n   * const verifyingKeys = transaction.verifyingKeys();\n   */\n  async getDeploymentTransactionIDForProgram(program: Program | string): Promise<string> {\n    if (program instanceof Program) {\n      program = program.id();\n    }\n    try {\n      const id = await this.fetchData<string>(\"/find/transactionID/deployment/\" + program);\n      return id.replace(\"\\\"\", \"\")\n    } catch (error) {\n      throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the deployment transaction associated with a specified program as a JSON object.\n   *\n   * @param {Program | string} program The name of the deployed program OR a wasm Program object.\n   * @returns {Promise<Transaction>} JSON representation of the deployment transaction.\n   *\n   * @example\n   * import { AleoNetworkClient, DeploymentJSON } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Get the transaction ID of the deployment transaction for a program.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const transaction = networkClient.getDeploymentTransactionForProgram(\"hello_hello.aleo\");\n   *\n   * // Get the verifying keys for each function in the deployment.\n   * const deployment = <DeploymentJSON>transaction.deployment;\n   * const verifyingKeys = deployment.verifying_keys;\n   */\n  async getDeploymentTransactionForProgram(program: Program | string): Promise<TransactionJSON> {\n    if (program instanceof Program) {\n      program = program.id();\n    }\n    try {\n      const transaction_id = <string>await this.getDeploymentTransactionIDForProgram(program);\n      return <TransactionJSON>await this.getTransaction(transaction_id);\n    } catch (error) {\n      throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the deployment transaction associated with a specified program as a wasm object.\n   *\n   * @param {Program | string} program The name of the deployed program OR a wasm Program object.\n   * @returns {Promise<Transaction>} Wasm object representation of the deployment transaction.\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Get the transaction ID of the deployment transaction for a program.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const transactionId = networkClient.getDeploymentTransactionIDForProgram(\"hello_hello.aleo\");\n   *\n   * // Get the transaction data for the deployment transaction.\n   * const transaction = networkClient.getDeploymentTransactionObjectForProgram(transactionId);\n   *\n   * // Get the verifying keys for the functions in the deployed program.\n   * const verifyingKeys = transaction.verifyingKeys();\n   */\n  async getDeploymentTransactionObjectForProgram(program: Program | string): Promise<Transaction> {\n    try {\n      const transaction_id = <string>await this.getDeploymentTransactionIDForProgram(program);\n      return await this.getTransactionObject(transaction_id);\n    } catch (error) {\n      throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the contents of the latest block as JSON.\n   *\n   * @returns {Promise<BlockJSON>} A javascript object containing the latest block\n   * \n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/testnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const latestHeight = networkClient.getLatestBlock();\n   */\n  async getLatestBlock(): Promise<BlockJSON> {\n    try {\n      return await this.fetchData<BlockJSON>(\"/block/latest\") as BlockJSON;\n    } catch (error) {\n      throw new Error(`Error fetching latest block: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the latest committee.\n   *\n   * @returns {Promise<object>} A javascript object containing the latest committee\n   * \n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * \n   * // Create a network client and get the latest committee.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const latestCommittee = await networkClient.getLatestCommittee();\n   */\n  async getLatestCommittee(): Promise<object> {\n    try {\n      return await this.fetchData<object>(\"/committee/latest\");\n    } catch (error) {\n      throw new Error(`Error fetching latest committee: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the committee at the specified block height.\n   * \n   * @param {number} blockHeight - The height of the block to fetch the committee for\n   * @returns {Promise<object>} A javascript object containing the committee\n   * \n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * \n   * // Create a network client and get the committee for a specific block.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const committee = await networkClient.getCommitteeByBlockHeight(1234);\n   */\n  async getCommitteeByBlockHeight(blockHeight: number): Promise<object> {\n    try {\n      return await this.fetchData<object>(`/committee/${blockHeight}`);\n    } catch (error) {\n      throw new Error(`Error fetching committee at height ${blockHeight}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the latest block height.\n   *\n   * @returns {Promise<number>} The latest block height.\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const latestHeight = networkClient.getLatestHeight();\n   */\n  async getLatestHeight(): Promise<number> {\n    try {\n      return Number(await this.fetchData<bigint>(\"/block/height/latest\"));\n    } catch (error) {\n      throw new Error(`Error fetching latest height: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the latest block hash.\n   *\n   * @returns {Promise<string>} The latest block hash.\n   * \n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get the latest block hash.\n   * const latestHash = networkClient.getLatestBlockHash();\n   */\n  async getLatestBlockHash(): Promise<string> {\n    try {\n      return String(await this.fetchData<string>(\"/block/hash/latest\"));\n    } catch (error) {\n      throw new Error(`Error fetching latest hash: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the source code of a program given a program ID.\n   *\n   * @param {string} programId The program ID of a program deployed to the Aleo Network\n   * @returns {Promise<string>} Source code of the program\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const program = networkClient.getProgram(\"hello_hello.aleo\");\n   * const expectedSource = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n   * assert.equal(program, expectedSource);\n   */\n  async getProgram(programId: string): Promise<string> {\n    try {\n      return await this.fetchData<string>(\"/program/\" + programId)\n    } catch (error) {\n      throw new Error(`Error fetching program ${programId}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns a program object from a program ID or program source code.\n   *\n   * @param {string} inputProgram The program ID or program source code of a program deployed to the Aleo Network\n   * @returns {Promise<Program>} Source code of the program\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const programID = \"hello_hello.aleo\";\n   * const programSource = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n   *\n   * // Get program object from program ID or program source code\n   * const programObjectFromID = await networkClient.getProgramObject(programID);\n   * const programObjectFromSource = await networkClient.getProgramObject(programSource);\n   *\n   * // Both program objects should be equal\n   * assert(programObjectFromID.to_string() === programObjectFromSource.to_string());\n   */\n  async getProgramObject(inputProgram: string): Promise<Program> {\n    try {\n      return Program.fromString(inputProgram);\n    } catch (error) {\n      try {\n        return Program.fromString(<string>(await this.getProgram(inputProgram)));\n      } catch (error) {\n        throw new Error(`${inputProgram} is neither a program name or a valid program: ${error}`);\n      }\n    }\n  }\n\n  /**\n   *  Returns an object containing the source code of a program and the source code of all programs it imports\n   *\n   * @param {Program | string} inputProgram The program ID or program source code of a program deployed to the Aleo Network\n   * @returns {Promise<ProgramImports>} Object of the form { \"program_id\": \"program_source\", .. } containing program id & source code for all program imports\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   * \n   * const double_test_source = \"import multiply_test.aleo;\\n\\nprogram double_test.aleo;\\n\\nfunction double_it:\\n    input r0 as u32.private;\\n    call multiply_test.aleo/multiply 2u32 r0 into r1;\\n    output r1 as u32.private;\\n\"\n   * const double_test = Program.fromString(double_test_source);\n   * const expectedImports = {\n   *     \"multiply_test.aleo\": \"program multiply_test.aleo;\\n\\nfunction multiply:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    mul r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n   * }\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Imports can be fetched using the program ID, source code, or program object\n   * let programImports = await networkClient.getProgramImports(\"double_test.aleo\");\n   * assert.deepStrictEqual(programImports, expectedImports);\n   *\n   * // Using the program source code\n   * programImports = await networkClient.getProgramImports(double_test_source);\n   * assert.deepStrictEqual(programImports, expectedImports);\n   *\n   * // Using the program object\n   * programImports = await networkClient.getProgramImports(double_test);\n   * assert.deepStrictEqual(programImports, expectedImports);\n   */\n  async getProgramImports(inputProgram: Program | string): Promise<ProgramImports> {\n    try {\n      const imports: ProgramImports = {};\n\n      // Get the program object or fail if the program is not valid or does not exist\n      const program = inputProgram instanceof Program ? inputProgram : <Program>(await this.getProgramObject(inputProgram));\n\n      // Get the list of programs that the program imports\n      const importList = program.getImports();\n\n      // Recursively get any imports that the imported programs have in a depth first search order\n      for (let i = 0; i < importList.length; i++) {\n        const import_id = importList[i];\n        if (!imports.hasOwnProperty(import_id)) {\n          const programSource = <string>await this.getProgram(import_id);\n          const nestedImports = <ProgramImports>await this.getProgramImports(import_id);\n          for (const key in nestedImports) {\n            if (!imports.hasOwnProperty(key)) {\n              imports[key] = nestedImports[key];\n            }\n          }\n          imports[import_id] = programSource;\n        }\n      }\n      return imports;\n    } catch (error: any) {\n      logAndThrow(\"Error fetching program imports: \" + error.message);\n    }\n  }\n\n  /**\n   * Get a list of the program names that a program imports.\n   *\n   * @param {Program | string} inputProgram - The program id or program source code to get the imports of\n   * @returns {string[]} - The list of program names that the program imports\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const programImportsNames = networkClient.getProgramImports(\"wrapped_credits.aleo\");\n   * const expectedImportsNames = [\"credits.aleo\"];\n   * assert.deepStrictEqual(programImportsNames, expectedImportsNames);\n   */\n  async getProgramImportNames(inputProgram: Program | string): Promise<string[]> {\n    try {\n      const program = inputProgram instanceof Program ? inputProgram : <Program>(await this.getProgramObject(inputProgram));\n      return program.getImports();\n    } catch (error: any) {\n      throw new Error(`Error fetching imports for program ${inputProgram instanceof Program ? inputProgram.id() : inputProgram}: ${error.message}`);\n    }\n  }\n\n  /**\n   * Returns the names of the mappings of a program.\n   *\n   * @param {string} programId - The program ID to get the mappings of (e.g. \"credits.aleo\")\n   * @returns {Promise<Array<string>>} - The names of the mappings of the program.\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const mappings = networkClient.getProgramMappingNames(\"credits.aleo\");\n   * const expectedMappings = [\n   *   \"committee\",\n   *   \"delegated\",\n   *   \"metadata\",\n   *   \"bonded\",\n   *   \"unbonding\",\n   *   \"account\",\n   *   \"withdraw\"\n   * ];\n   * assert.deepStrictEqual(mappings, expectedMappings);\n   */\n  async getProgramMappingNames(programId: string): Promise<Array<string>> {\n    try {\n      return await this.fetchData<Array<string>>(`/program/${programId}/mappings`)\n    } catch (error) {\n      throw new Error(`Error fetching mappings for program ${programId} - ensure the program exists on chain before trying again`);\n    }\n  }\n\n  /**\n   * Returns the value of a program's mapping for a specific key.\n   *\n   * @param {string} programId - The program ID to get the mapping value of (e.g. \"credits.aleo\")\n   * @param {string} mappingName - The name of the mapping to get the value of (e.g. \"account\")\n   * @param {string | Plaintext} key - The key to look up in the mapping (e.g. an address for the \"account\" mapping)\n   * @returns {Promise<string>} String representation of the value of the mapping\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get public balance of an account\n   * const mappingValue = networkClient.getMappingValue(\"credits.aleo\", \"account\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\");\n   * const expectedValue = \"0u64\";\n   * assert(mappingValue === expectedValue);\n   */\n  async getProgramMappingValue(programId: string, mappingName: string, key: string | Plaintext): Promise<string> {\n    try {\n      const keyString = key instanceof Plaintext ? key.toString() : key;\n      return await this.fetchData<string>(`/program/${programId}/mapping/${mappingName}/${keyString}`);\n    } catch (error) {\n      throw new Error(`Error fetching value for key '${key}' in mapping '${mappingName}' in program '${programId}' - ensure the mapping exists and the key is correct`);\n    }\n  }\n\n\n  /**\n   * Returns the value of a mapping as a wasm Plaintext object. Returning an object in this format allows it to be converted to a Js type and for its internal members to be inspected if it's a struct or array.\n   *\n   * @param {string} programId - The program ID to get the mapping value of (e.g. \"credits.aleo\")\n   * @param {string} mappingName - The name of the mapping to get the value of (e.g. \"bonded\")\n   * @param {string | Plaintext} key - The key to look up in the mapping (e.g. an address for the \"bonded\" mapping)\n   * @returns {Promise<Plaintext>} String representation of the value of the mapping\n   *\n   * @example\n   * import { AleoNetworkClient } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get the bond state as an account.\n   * const unbondedState = networkClient.getMappingPlaintext(\"credits.aleo\", \"bonded\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\");\n   *\n   * // Get the two members of the object individually.\n   * const validator = unbondedState.getMember(\"validator\");\n   * const microcredits = unbondedState.getMember(\"microcredits\");\n   *\n   * // Ensure the expected values are correct.\n   * assert.equal(validator, \"aleo1u6940v5m0fzud859xx2c9tj2gjg6m5qrd28n636e6fdd2akvfcgqs34mfd\");\n   * assert.equal(microcredits, BigInt(\"9007199254740991\"));\n   *\n   * // Get a JS object representation of the unbonded state.\n   * const unbondedStateObject = unbondedState.toObject();\n   *\n   * const expectedState = {\n   *     validator: \"aleo1u6940v5m0fzud859xx2c9tj2gjg6m5qrd28n636e6fdd2akvfcgqs34mfd\",\n   *     microcredits: BigInt(9007199254740991)\n   * };\n   * assert.equal(unbondedState, expectedState);\n   */\n  async getProgramMappingPlaintext(programId: string, mappingName: string, key: string | Plaintext): Promise<Plaintext> {\n    try {\n      const keyString = key instanceof Plaintext ? key.toString() : key;\n      const value = await this.fetchRaw(`/program/${programId}/mapping/${mappingName}/${keyString}`);\n      return Plaintext.fromString(JSON.parse(value));\n    } catch (error) {\n      throw new Error(\"Failed to fetch mapping value.\" + error);\n    }\n  }\n\n  /**\n   * Returns the public balance of an address from the account mapping in credits.aleo\n   * \n   * @param {Address | string} address A string or wasm object representing an address.\n   * @returns {Promise<number>} The public balance of the address in microcredits.\n   * \n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get the balance of an account from either an address object or address string.\n   * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n   * const publicBalance = await networkClient.getPublicBalance(account.address());\n   * const publicBalanceFromString = await networkClient.getPublicBalance(account.address().to_string());\n   * assert(publicBalance === publicBalanceFromString);\n   */\n  async getPublicBalance(address: Address | string): Promise<number> {\n    try {\n      const addressString = address instanceof Address ? address.to_string() : address;\n      const balanceStr = await this.getProgramMappingValue('credits.aleo', 'account', addressString);\n      return balanceStr ? parseInt(balanceStr) : 0;\n    } catch (error) {\n      throw new Error(`Error fetching public balance for ${address}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the latest state/merkle root of the Aleo blockchain.\n   * \n   * @returns {Promise<string>} A string representing the latest state root of the Aleo blockchain.\n   * \n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get the latest state root.\n   * const stateRoot = networkClient.getStateRoot();\n   */\n  async getStateRoot(): Promise<string> {\n    try {\n      return await this.fetchData<string>('/stateRoot/latest');\n    } catch (error) {\n      throw new Error(`Error fetching latest state root: ${error}`);\n    }\n  }\n\n  /**\n   * Returns a transaction by its unique identifier.\n   *\n   * @param {string} transactionId The transaction ID to fetch.\n   * @returns {Promise<TransactionJSON>} A json representation of the transaction.\n   * \n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const transaction = networkClient.getTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n   */\n  async getTransaction(transactionId: string): Promise<TransactionJSON> {\n    try {\n    return await this.fetchData<TransactionJSON>(\"/transaction/\" + transactionId);\n    } catch (error) {\n      throw new Error(`Error fetching transaction ${transactionId}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns a confirmed transaction by its unique identifier.\n   * \n   * @param {string} transactionId The transaction ID to fetch.\n   * @returns {Promise<ConfirmedTransactionJSON>} A json object containing the confirmed transaction.\n   * \n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * \n   * const transaction = networkClient.getConfirmedTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n   * assert.equal(transaction.status, \"confirmed\");\n   */\n  async getConfirmedTransaction(transactionId: string): Promise<ConfirmedTransactionJSON> {\n    try {\n      return await this.fetchData<ConfirmedTransactionJSON>(`/transaction/confirmed/${transactionId}`);\n    } catch (error) {\n      throw new Error(`Error fetching confirmed transaction ${transactionId}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns a transaction as a wasm object. Getting a transaction of this type will allow the ability for the inputs,\n   * outputs, and records to be searched for and displayed.\n   * \n   * @param {string} transactionId - The unique identifier of the transaction to fetch\n   * @returns {Promise<Transaction>} A wasm object representation of the transaction.\n   *\n   * @example\n   * const transactionObject = networkClient.getTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n   * // Get the transaction inputs as a JS array.\n   * const transactionInputs = transactionObject.inputs(true);\n   *\n   * // Get the transaction outputs as a JS object.\n   * const transactionOutputs = transactionObject.outputs(true);\n   *\n   * // Get any records generated in transitions in the transaction as a JS object.\n   * const records = transactionObject.records();\n   *\n   * // Get the transaction type.\n   * const transactionType = transactionObject.transactionType();\n   * assert.equal(transactionType, \"Execute\");\n   *\n   * // Get a JS representation of all inputs, outputs, and transaction metadata.\n   * const transactionSummary = transactionObject.summary();\n   */\n  async getTransactionObject(transactionId: string): Promise<Transaction> {\n    try {\n      const transaction = await this.fetchRaw(\"/transaction/\" + transactionId);\n      return Transaction.fromString(transaction);\n    } catch (error) {\n      throw new Error(`Error fetching transaction object ${transactionId}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the transactions present at the specified block height.\n   *\n   * @param {number} blockHeight The block height to fetch the confirmed transactions at.\n   * @returns {Promise<Array<ConfirmedTransactionJSON>>} An array of confirmed transactions (in JSON format) for the block height.\n   *\n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const transactions = networkClient.getTransactions(654);\n   */\n  async getTransactions(blockHeight: number): Promise<Array<ConfirmedTransactionJSON>> {\n    try {\n      return await this.fetchData<Array<ConfirmedTransactionJSON>>(\"/block/\" + blockHeight.toString() + \"/transactions\");\n    } catch (error) {\n      throw new Error(`Error fetching transactions: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the confirmed transactions present in the block with the specified block hash.\n   *\n   * @param {string} blockHash The block hash to fetch the confirmed transactions at.\n   * @returns {Promise<Array<ConfirmedTransactionJSON>>} An array of confirmed transactions (in JSON format) for the block hash.\n   *\n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * const transactions = networkClient.getTransactionsByBlockHash(\"ab19dklwl9vp63zu3hwg57wyhvmqf92fx5g8x0t6dr72py8r87pxupqfne5t9\");\n   */\n  async getTransactionsByBlockHash(blockHash: string): Promise<Array<ConfirmedTransactionJSON>> {\n    try {\n      const block = await this.fetchData<BlockJSON>(`/block/${blockHash}`);\n      const height = block.header.metadata.height;\n      return await this.getTransactions(Number(height));\n    } catch (error) {\n      throw new Error(`Error fetching transactions for block ${blockHash}: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the transactions in the memory pool. This method requires access to a validator's REST API.\n   *\n   * @returns {Promise<Array<TransactionJSON>>} An array of transactions (in JSON format) currently in the mempool.\n   *\n   * @example\n   * import { AleoNetworkClient, Account } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   *\n   * // Get the current transactions in the mempool.\n   * const transactions = networkClient.getTransactionsInMempool();\n   */\n  async getTransactionsInMempool(): Promise<Array<TransactionJSON>> {\n    try {\n      return await this.fetchData<Array<TransactionJSON>>(\"/memoryPool/transactions\");\n    } catch (error) {\n      throw new Error(`Error fetching transactions from mempool: ${error}`);\n    }\n  }\n\n  /**\n   * Returns the transition ID of the transition corresponding to the ID of the input or output.\n   * @param {string} inputOrOutputID - The unique identifier of the input or output to find the transition ID for\n   * @returns {Promise<string>} - The transition ID of the input or output ID.\n   *\n   * @example\n   * const transitionId = networkClient.getTransitionId(\"2429232855236830926144356377868449890830704336664550203176918782554219952323field\");\n   */\n  async getTransitionId(inputOrOutputID: string): Promise<string> {\n    try {\n      return await this.fetchData<string>(\"/find/transitionID/\" + inputOrOutputID);\n    } catch (error) {\n      throw new Error(`Error fetching transition ID for input/output ${inputOrOutputID}: ${error}`);\n    }\n  }\n\n  /**\n   * Submit an execute or deployment transaction to the Aleo network.\n   *\n   * @param {Transaction | string} transaction - The transaction to submit, either as a Transaction object or string representation\n   * @returns {Promise<string>} - The transaction id of the submitted transaction or the resulting error\n   */\n  async submitTransaction(transaction: Transaction | string): Promise<string> {\n    const transaction_string = transaction instanceof Transaction ? transaction.toString() : transaction;\n    try {\n      const response = await post(this.host + \"/transaction/broadcast\", {\n        body: transaction_string,\n        headers: Object.assign({}, this.headers, {\n          \"Content-Type\": \"application/json\",\n        }),\n      });\n\n      try {\n        const text = await response.text();\n        return parseJSON(text);\n\n      } catch (error: any) {\n        throw new Error(`Error posting transaction. Aleo network response: ${error.message}`);\n      }\n    } catch (error: any) {\n      throw new Error(`Error posting transaction: No response received: ${error.message}`);\n    }\n  }\n\n  /**\n   * Submit a solution to the Aleo network.\n   *\n   * @param {string} solution - The string representation of the solution to submit\n   * @returns {Promise<string>} The solution id of the submitted solution or the resulting error.\n   */\n  async submitSolution(solution: string): Promise<string> {\n    try {\n      const response = await post(this.host + \"/solution/broadcast\", {\n        body: solution,\n        headers: Object.assign({}, this.headers, {\n          \"Content-Type\": \"application/json\",\n        }),\n      });\n\n      try {\n        const text = await response.text();\n        return parseJSON(text);\n\n      } catch (error: any) {\n        throw new Error(`Error posting transaction. Aleo network response: ${error.message}`);\n      }\n    } catch (error: any) {\n      throw new Error(`Error posting transaction: No response received: ${error.message}`);\n    }\n  }\n\n  /**\n   * Await a submitted transaction to be confirmed or rejected on the Aleo network.\n   *\n   * @param {string} transactionId - The transaction ID to wait for confirmation\n   * @param {number} checkInterval - The interval in milliseconds to check for confirmation (default: 2000)\n   * @param {number} timeout - The maximum time in milliseconds to wait for confirmation (default: 45000)\n   * @returns {Promise<Transaction>} The confirmed transaction object that returns if the transaction is confirmed.\n   *\n   * @example\n   * import { AleoNetworkClient, Account, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n   *\n   * // Create a network client and program manager.\n   * const networkClient = new AleoNetworkClient(\"http://api.explorer.provable.com/v1\", undefined);\n   * const programManager = new ProgramManager(networkClient);\n   *\n   * // Set the account for the program manager.\n   * programManager.setAccount(Account.fromCiphertext(process.env.ciphertext, process.env.password));\n   *\n   * // Build a transfer transaction.\n   * const tx = await programManager.buildTransferPublicTransaction(100, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", 0);\n   *\n   * // Submit the transaction to the network.\n   * const transactionId = await networkClient.submitTransaction(tx);\n   *\n   * // Wait for the transaction to be confirmed.\n   * const transaction = await networkClient.waitForTransactionConfirmation(transactionId);\n   */\n  async waitForTransactionConfirmation(\n      transactionId: string,\n      checkInterval: number = 2000,  // Poll every 2 seconds\n      timeout: number = 45000        // Timeout after 45 seconds\n  ): Promise<Transaction> {\n    const startTime = Date.now();\n\n    return new Promise<Transaction>((resolve, reject) => {\n      const interval = setInterval(async () => {\n        try {\n          // Replace with actual Aleo transaction lookup API\n          const transaction = <Transaction>await this.getTransactionObject(transactionId);\n          resolve(transaction);\n          if (Date.now() - startTime > timeout) {\n            clearInterval(interval);\n            reject(new Error(\"Transaction confirmation timed out\"));\n          }\n        } catch (error) {\n          console.error(\"Error checking transaction:\", error);\n        }\n      }, checkInterval);\n    });\n  }\n}\n\nexport { AleoNetworkClient, AleoNetworkClientOptions, ProgramImports }\n","import {VerifyingKey, Metadata} from \"./wasm\";\n\nexport const KEY_STORE = Metadata.baseUrl();\n\nexport interface Key {\n    name: string,\n    locator: string,\n    prover: string,\n    verifier: string,\n    verifyingKey: () => VerifyingKey,\n}\n\nfunction convert(metadata: Metadata): Key {\n    // This looks up the method name in VerifyingKey\n    const verifyingKey = (VerifyingKey as any)[metadata.verifyingKey];\n\n    if (!verifyingKey) {\n        throw new Error(\"Invalid method name: \" + metadata.verifyingKey);\n    }\n\n    return {\n        name: metadata.name,\n        locator: metadata.locator,\n        prover: metadata.prover,\n        verifier: metadata.verifier,\n        verifyingKey,\n    };\n}\n\nexport const CREDITS_PROGRAM_KEYS = {\n    bond_public: convert(Metadata.bond_public()),\n    bond_validator: convert(Metadata.bond_validator()),\n    claim_unbond_public: convert(Metadata.claim_unbond_public()),\n    fee_private: convert(Metadata.fee_private()),\n    fee_public: convert(Metadata.fee_public()),\n    inclusion: convert(Metadata.inclusion()),\n    join: convert(Metadata.join()),\n    set_validator_state: convert(Metadata.set_validator_state()),\n    split: convert(Metadata.split()),\n    transfer_private: convert(Metadata.transfer_private()),\n    transfer_private_to_public: convert(Metadata.transfer_private_to_public()),\n    transfer_public: convert(Metadata.transfer_public()),\n    transfer_public_as_signer: convert(Metadata.transfer_public_as_signer()),\n    transfer_public_to_private: convert(Metadata.transfer_public_to_private()),\n    unbond_public: convert(Metadata.unbond_public()),\n    getKey: function(key: string): Key {\n        if (this.hasOwnProperty(key)) {\n            return (this as any)[key] as Key;\n        } else {\n            throw new Error(`Key \"${key}\" not found.`);\n        }\n    }\n};\n\nexport const PRIVATE_TRANSFER_TYPES = new Set([\n    \"transfer_private\",\n    \"private\",\n    \"transferPrivate\",\n    \"transfer_private_to_public\",\n    \"privateToPublic\",\n    \"transferPrivateToPublic\",\n]);\n\nexport const VALID_TRANSFER_TYPES = new Set([\n    \"transfer_private\",\n    \"private\",\n    \"transferPrivate\",\n    \"transfer_private_to_public\",\n    \"privateToPublic\",\n    \"transferPrivateToPublic\",\n    \"transfer_public\",\n    \"transfer_public_as_signer\",\n    \"public\",\n    \"public_as_signer\",\n    \"transferPublic\",\n    \"transferPublicAsSigner\",\n    \"transfer_public_to_private\",\n    \"publicToPrivate\",\n    \"publicAsSigner\",\n    \"transferPublicToPrivate\",\n]);\n\nexport const PRIVATE_TRANSFER = new Set([\n    \"private\",\n    \"transfer_private\",\n    \"transferPrivate\",\n]);\n\nexport const PRIVATE_TO_PUBLIC_TRANSFER = new Set([\n    \"private_to_public\",\n    \"privateToPublic\",\n    \"transfer_private_to_public\",\n    \"transferPrivateToPublic\",\n]);\n\nexport const PUBLIC_TRANSFER = new Set([\n    \"public\",\n    \"transfer_public\",\n    \"transferPublic\",\n]);\n\nexport const PUBLIC_TRANSFER_AS_SIGNER = new Set([\n    \"public_as_signer\",\n    \"transfer_public_as_signer\",\n    \"transferPublicAsSigner\",\n]);\n\nexport const PUBLIC_TO_PRIVATE_TRANSFER = new Set([\n    \"public_to_private\",\n    \"publicToPrivate\",\n    \"transfer_public_to_private\",\n    \"transferPublicToPrivate\",\n]);\n","import {\n    CREDITS_PROGRAM_KEYS,\n    KEY_STORE,\n    Key,\n    PRIVATE_TRANSFER,\n    PRIVATE_TO_PUBLIC_TRANSFER,\n    PUBLIC_TRANSFER,\n    PUBLIC_TO_PRIVATE_TRANSFER,\n    PUBLIC_TRANSFER_AS_SIGNER,\n} from \"./constants\";\n\nimport {\n    ProvingKey,\n    VerifyingKey,\n} from \"./wasm\";\n\nimport { get } from \"./utils\";\n\ntype FunctionKeyPair = [ProvingKey, VerifyingKey];\ntype CachedKeyPair = [Uint8Array, Uint8Array];\ntype AleoKeyProviderInitParams = {\n    proverUri?: string;\n    verifierUri?: string;\n    cacheKey?: string;\n};\n\n/**\n * Interface for record search parameters. This allows for arbitrary search parameters to be passed to record provider\n * implementations.\n */\ninterface KeySearchParams {\n    [key: string]: any; // This allows for arbitrary keys with any type values\n}\n\n/**\n * AleoKeyProviderParams search parameter for the AleoKeyProvider. It allows for the specification of a proverUri and\n * verifierUri to fetch keys via HTTP from a remote resource as well as a unique cacheKey to store the keys in memory.\n */\nclass AleoKeyProviderParams implements KeySearchParams {\n    name: string | undefined;\n    proverUri: string | undefined;\n    verifierUri: string | undefined;\n    cacheKey: string | undefined;\n\n    /**\n     * Create a new AleoKeyProviderParams object which implements the KeySearchParams interface. Users can optionally\n     * specify a url for the proverUri & verifierUri to fetch keys via HTTP from a remote resource as well as a unique\n     * cacheKey to store the keys in memory for future use. If no proverUri or verifierUri is specified, a cachekey must\n     * be provided.\n     *\n     * @param { AleoKeyProviderInitParams } params - Optional search parameters\n     */\n    constructor(params: {proverUri?: string, verifierUri?: string, cacheKey?: string, name?: string}) {\n        this.proverUri = params.proverUri;\n        this.verifierUri = params.verifierUri;\n        this.cacheKey = params.cacheKey;\n        this.name = params.name;\n    }\n}\n\n/**\n * KeyProvider interface. Enables the retrieval of public proving and verifying keys for Aleo Programs.\n */\ninterface FunctionKeyProvider {\n    /**\n     * Get bond_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_public function\n     */\n    bondPublicKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get bond_validator function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_validator function\n     */\n    bondValidatorKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId\n     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.\n     *\n     * @param {string} keyId access key for the cache\n     * @param {FunctionKeyPair} keys keys to cache\n     */\n    cacheKeys(keyId: string, keys: FunctionKeyPair): void;\n\n    /**\n     * Get unbond_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the unbond_public function\n     */\n    claimUnbondPublicKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get arbitrary function keys from a provider\n     *\n     * @param {KeySearchParams | undefined} params - Optional search parameters for the key provider\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * // Create a search object which implements the KeySearchParams interface\n     * class IndexDbSearch implements KeySearchParams {\n     *     db: string\n     *     keyId: string\n     *     constructor(params: {db: string, keyId: string}) {\n     *         this.db = params.db;\n     *         this.keyId = params.keyId;\n     *     }\n     * }\n     *\n     * // Create a new object which implements the KeyProvider interface\n     * class IndexDbKeyProvider implements FunctionKeyProvider {\n     *     async functionKeys(params: KeySearchParams): Promise<FunctionKeyPair> {\n     *         return new Promise((resolve, reject) => {\n     *             const request = indexedDB.open(params.db, 1);\n     *\n     *             request.onupgradeneeded = function(e) {\n     *                 const db = e.target.result;\n     *                 if (!db.objectStoreNames.contains('keys')) {\n     *                     db.createObjectStore('keys', { keyPath: 'id' });\n     *                 }\n     *             };\n     *\n     *             request.onsuccess = function(e) {\n     *                 const db = e.target.result;\n     *                 const transaction = db.transaction([\"keys\"], \"readonly\");\n     *                 const store = transaction.objectStore(\"keys\");\n     *                 const request = store.get(params.keyId);\n     *                 request.onsuccess = function(e) {\n     *                     if (request.result) {\n     *                         resolve(request.result as FunctionKeyPair);\n     *                     } else {\n     *                         reject(new Error(\"Key not found\"));\n     *                     }\n     *                 };\n     *                 request.onerror = function(e) { reject(new Error(\"Error fetching key\")); };\n     *             };\n     *\n     *             request.onerror = function(e) { reject(new Error(\"Error opening database\")); };\n     *         });\n     *     }\n     *\n     *     // implement the other methods...\n     * }\n     *\n     *\n     * const keyProvider = new AleoKeyProvider();\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const searchParams = new IndexDbSearch({db: \"keys\", keyId: \"credits.aleo:transferPrivate\"});\n     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.functionKeys(searchParams);\n     */\n    functionKeys(params?: KeySearchParams): Promise<FunctionKeyPair>;\n\n    /**\n     * Get fee_private function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    feePrivateKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get fee_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    feePublicKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get join function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    joinKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get split function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    splitKeys(): Promise<FunctionKeyPair>;\n\n    /**\n     * Get keys for a variant of the transfer function from the credits.aleo program\n     *\n     * @param {string} visibility Visibility of the transfer function (private, public, privateToPublic, publicToPrivate)\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified transfer function\n     *\n     * @example\n     * // Create a new object which implements the KeyProvider interface\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys(\"public\");\n     */\n    transferKeys(visibility: string): Promise<FunctionKeyPair>;\n\n    /**\n     * Get unbond_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    unBondPublicKeys(): Promise<FunctionKeyPair>;\n\n}\n\n\n/**\n * AleoKeyProvider class. Implements the KeyProvider interface. Enables the retrieval of Aleo program proving and\n * verifying keys for the credits.aleo program over http from official Aleo sources and storing and retrieving function\n * keys from a local memory cache.\n */\nclass AleoKeyProvider implements FunctionKeyProvider {\n    cache: Map<string, CachedKeyPair>;\n    cacheOption: boolean;\n    keyUris: string;\n\n    async fetchBytes(\n        url = \"/\",\n    ): Promise<Uint8Array> {\n        try {\n        const response = await get(url);\n        const data = await response.arrayBuffer();\n        return new Uint8Array(data);\n        } catch (error: any) {\n            throw new Error(\"Error fetching data.\" + error.message);\n        }\n    }\n\n    constructor() {\n        this.keyUris = KEY_STORE;\n        this.cache = new Map<string, CachedKeyPair>();\n        this.cacheOption = false;\n    }\n\n    /**\n     * Use local memory to store keys\n     *\n     * @param {boolean} useCache whether to store keys in local memory\n     */\n    useCache(useCache: boolean) {\n        this.cacheOption = useCache;\n    }\n\n    /**\n     * Clear the key cache\n     */\n    clearCache() {\n        this.cache.clear();\n    }\n\n    /**\n     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId\n     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.\n     *\n     * @param {string} keyId access key for the cache\n     * @param {FunctionKeyPair} keys keys to cache\n     */\n    cacheKeys(keyId: string, keys: FunctionKeyPair) {\n        const [provingKey, verifyingKey] = keys;\n        this.cache.set(keyId, [provingKey.toBytes(), verifyingKey.toBytes()]);\n    }\n\n    /**\n     * Determine if a keyId exists in the cache\n     *\n     * @param {string} keyId keyId of a proving and verifying key pair\n     * @returns {boolean} true if the keyId exists in the cache, false otherwise\n     */\n    containsKeys(keyId: string): boolean {\n        return this.cache.has(keyId)\n    }\n\n    /**\n     * Delete a set of keys from the cache\n     *\n     * @param {string} keyId keyId of a proving and verifying key pair to delete from memory\n     * @returns {boolean} true if the keyId exists in the cache and was deleted, false if the key did not exist\n     */\n    deleteKeys(keyId: string): boolean {\n        return this.cache.delete(keyId)\n    }\n\n    /**\n     * Get a set of keys from the cache\n     * @param keyId keyId of a proving and verifying key pair\n     *\n     * @returns {FunctionKeyPair} Proving and verifying keys for the specified program\n     */\n    getKeys(keyId: string): FunctionKeyPair {\n        console.debug(`Checking if key exists in cache. KeyId: ${keyId}`)\n        if (this.cache.has(keyId)) {\n            const [provingKeyBytes, verifyingKeyBytes] = <CachedKeyPair>this.cache.get(keyId);\n            return [ProvingKey.fromBytes(provingKeyBytes), VerifyingKey.fromBytes(verifyingKeyBytes)];\n        } else {\n            throw new Error(\"Key not found in cache.\");\n        }\n    }\n\n    /**\n     * Get arbitrary function keys from a provider\n     *\n     * @param {KeySearchParams} params parameters for the key search in form of: {proverUri: string, verifierUri: string, cacheKey: string}\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * // Create a new object which implements the KeyProvider interface\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually using the key provider\n     * const keySearchParams = { \"cacheKey\": \"myProgram:myFunction\" };\n     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.functionKeys(keySearchParams);\n     */\n    async functionKeys(params?: KeySearchParams): Promise<FunctionKeyPair> {\n        if (params) {\n            let proverUrl;\n            let verifierUrl;\n            let cacheKey;\n            if (\"name\" in params && typeof params[\"name\"] == \"string\") {\n                let key = CREDITS_PROGRAM_KEYS.getKey(params[\"name\"]);\n                return this.fetchCreditsKeys(key);\n            }\n\n            if (\"proverUri\" in params && typeof params[\"proverUri\"] == \"string\") {\n                proverUrl = params[\"proverUri\"];\n            }\n\n            if (\"verifierUri\" in params && typeof params[\"verifierUri\"] == \"string\") {\n                verifierUrl = params[\"verifierUri\"];\n            }\n\n            if (\"cacheKey\" in params && typeof params[\"cacheKey\"] == \"string\") {\n                cacheKey = params[\"cacheKey\"];\n            }\n\n            if (proverUrl && verifierUrl) {\n                return await this.fetchRemoteKeys(proverUrl, verifierUrl, cacheKey);\n            }\n\n            if (cacheKey) {\n                return this.getKeys(cacheKey);\n            }\n        }\n        throw new Error(\"Invalid parameters provided, must provide either a cacheKey and/or a proverUrl and a verifierUrl\");\n    }\n\n    /**\n     * Returns the proving and verifying keys for a specified program from a specified url.\n     *\n     * @param {string} verifierUrl Url of the proving key\n     * @param {string} proverUrl Url the verifying key\n     * @param {string} cacheKey Key to store the keys in the cache\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * // Create a new AleoKeyProvider object\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.fetchKeys(\n     *     CREDITS_PROGRAM_KEYS.transfer_private.prover,\n     *     CREDITS_PROGRAM_KEYS.transfer_private.verifier,\n     * );\n     */\n    async fetchRemoteKeys(proverUrl: string, verifierUrl: string, cacheKey?: string): Promise<FunctionKeyPair> {\n        try {\n            // If cache is enabled, check if the keys have already been fetched and return them if they have\n            if (this.cacheOption) {\n                if (!cacheKey) {\n                    cacheKey = proverUrl;\n                }\n                const value = this.cache.get(cacheKey);\n                if (typeof value !== \"undefined\") {\n                    return [ProvingKey.fromBytes(value[0]), VerifyingKey.fromBytes(value[1])];\n                } else {\n                    console.debug(\"Fetching proving keys from url \" + proverUrl);\n                    const provingKey = <ProvingKey>ProvingKey.fromBytes(await this.fetchBytes(proverUrl))\n                    console.debug(\"Fetching verifying keys \" + verifierUrl);\n                    const verifyingKey = <VerifyingKey>(await this.getVerifyingKey(verifierUrl));\n                    this.cache.set(cacheKey, [provingKey.toBytes(), verifyingKey.toBytes()]);\n                    return [provingKey, verifyingKey];\n                }\n            }\n            else {\n                // If cache is disabled, fetch the keys and return them\n                const provingKey = <ProvingKey>ProvingKey.fromBytes(await this.fetchBytes(proverUrl))\n                const verifyingKey = <VerifyingKey>(await this.getVerifyingKey(verifierUrl));\n                return [provingKey, verifyingKey];\n            }\n        } catch (error: any) {\n            throw new Error(`Error: ${error.message} fetching fee proving and verifying keys from ${proverUrl} and ${verifierUrl}.`);\n        }\n    }\n\n    /***\n     * Fetches the proving key from a remote source.\n     *\n     * @param proverUrl\n     * @param cacheKey\n     *\n     * @returns {Promise<ProvingKey>} Proving key for the specified program\n     */\n    async fetchProvingKey(proverUrl: string, cacheKey?: string): Promise<ProvingKey> {\n        try {\n            // If cache is enabled, check if the keys have already been fetched and return them if they have\n            if (this.cacheOption) {\n                if (!cacheKey) {\n                    cacheKey = proverUrl;\n                }\n                const value = this.cache.get(cacheKey);\n                if (typeof value !== \"undefined\") {\n                    return ProvingKey.fromBytes(value[0]);\n                } else {\n                    console.debug(\"Fetching proving keys from url \" + proverUrl);\n                    const provingKey = <ProvingKey>ProvingKey.fromBytes(await this.fetchBytes(proverUrl));\n                    return provingKey;\n                }\n            }\n            else {\n                const provingKey = <ProvingKey>ProvingKey.fromBytes(await this.fetchBytes(proverUrl));\n                return provingKey;\n            }\n        } catch (error: any) {\n            throw new Error(`Error: ${error.message} fetching fee proving keys from ${proverUrl}`);\n        }\n    }\n\n    async fetchCreditsKeys(key: Key): Promise<FunctionKeyPair> {\n        try {\n            if (!this.cache.has(key.locator) || !this.cacheOption) {\n                const verifying_key = key.verifyingKey()\n                const proving_key = <ProvingKey>await this.fetchProvingKey(key.prover, key.locator);\n                if (this.cacheOption) {\n                    this.cache.set(CREDITS_PROGRAM_KEYS.bond_public.locator, [proving_key.toBytes(), verifying_key.toBytes()]);\n                }\n                return [proving_key, verifying_key];\n            } else {\n                const keyPair = <CachedKeyPair>this.cache.get(key.locator);\n                return [ProvingKey.fromBytes(keyPair[0]), VerifyingKey.fromBytes(keyPair[1])];\n            }\n        } catch (error: any) {\n            throw new Error(`Error: fetching credits.aleo keys: ${error.message}`);\n        }\n    }\n\n    async bondPublicKeys(): Promise<FunctionKeyPair> {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.bond_public);\n    }\n\n    bondValidatorKeys(): Promise<FunctionKeyPair> {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.bond_validator);\n    }\n\n    claimUnbondPublicKeys(): Promise<FunctionKeyPair> {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.claim_unbond_public)\n    }\n\n    /**\n     * Returns the proving and verifying keys for the transfer functions in the credits.aleo program\n     * @param {string} visibility Visibility of the transfer function\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the transfer functions\n     *\n     * @example\n     * // Create a new AleoKeyProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys(\"public\");\n     */\n    async transferKeys(visibility: string): Promise<FunctionKeyPair> {\n        if (PRIVATE_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_private);\n        } else if (PRIVATE_TO_PUBLIC_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_private_to_public);\n        } else if (PUBLIC_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public);\n        } else if (PUBLIC_TRANSFER_AS_SIGNER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public_as_signer);\n        } else if (PUBLIC_TO_PRIVATE_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public_to_private);\n        } else {\n            throw new Error(\"Invalid visibility type\");\n        }\n    }\n\n    /**\n     * Returns the proving and verifying keys for the join function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    async joinKeys(): Promise<FunctionKeyPair> {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.join);\n    }\n\n    /**\n     * Returns the proving and verifying keys for the split function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the split function\n     * */\n    async splitKeys(): Promise<FunctionKeyPair> {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.split);\n    }\n\n    /**\n     * Returns the proving and verifying keys for the fee_private function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the fee function\n     */\n    async feePrivateKeys(): Promise<FunctionKeyPair> {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.fee_private);\n    }\n\n    /**\n     * Returns the proving and verifying keys for the fee_public function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the fee function\n     */\n    async feePublicKeys(): Promise<FunctionKeyPair> {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.fee_public);\n    }\n\n    /**\n     * Gets a verifying key. If the verifying key is for a credits.aleo function, get it from the wasm cache otherwise\n     *\n     * @returns {Promise<VerifyingKey>} Verifying key for the function\n     */\n    // attempt to fetch it from the network\n    async getVerifyingKey(verifierUri: string): Promise<VerifyingKey> {\n        switch (verifierUri) {\n            case CREDITS_PROGRAM_KEYS.bond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.bond_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.bond_validator.verifier:\n                return CREDITS_PROGRAM_KEYS.bond_validator.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.claim_unbond_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.fee_private.verifier:\n                return CREDITS_PROGRAM_KEYS.fee_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.fee_public.verifier:\n                return CREDITS_PROGRAM_KEYS.fee_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.inclusion.verifier:\n                return CREDITS_PROGRAM_KEYS.inclusion.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.join.verifier:\n                return CREDITS_PROGRAM_KEYS.join.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.set_validator_state.verifier:\n                return CREDITS_PROGRAM_KEYS.set_validator_state.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.split.verifier:\n                return CREDITS_PROGRAM_KEYS.split.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_private.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_public.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_public_as_signer.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_public_as_signer.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.unbond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.unbond_public.verifyingKey();\n            default:\n                try {\n                    /// Try to fetch the verifying key from the network as a string\n                    const response = await get(verifierUri);\n                    const text = await response.text();\n                    return <VerifyingKey>VerifyingKey.fromString(text);\n                } catch (e) {\n                    /// If that fails, try to fetch the verifying key from the network as bytes\n                    try {\n                    return <VerifyingKey>VerifyingKey.fromBytes(await this.fetchBytes(verifierUri));\n                    } catch (inner: any) {\n                        throw new Error(\"Invalid verifying key. Error: \" + inner.message);\n                    }\n                }\n        }\n    }\n\n    unBondPublicKeys(): Promise<FunctionKeyPair> {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.unbond_public);\n    }\n}\n\nexport {AleoKeyProvider, AleoKeyProviderParams, AleoKeyProviderInitParams, CachedKeyPair, FunctionKeyPair, FunctionKeyProvider, KeySearchParams}\n","import { Account } from \"./account\";\nimport { AleoNetworkClient, ProgramImports } from \"./network-client\";\n\nimport { RecordProvider, RecordSearchParams } from \"./record-provider\";\n\nimport {\n    AleoKeyProvider,\n    AleoKeyProviderParams,\n    FunctionKeyPair,\n    FunctionKeyProvider,\n    KeySearchParams,\n} from \"./function-key-provider\";\n\nimport {\n    Address,\n    ExecutionResponse,\n    Execution as FunctionExecution,\n    OfflineQuery,\n    RecordPlaintext,\n    PrivateKey,\n    Program,\n    ProvingKey,\n    VerifyingKey,\n    Transaction,\n    ProgramManager as WasmProgramManager,\n    verifyFunctionExecution,\n} from \"./wasm\";\n\nimport {\n    CREDITS_PROGRAM_KEYS,\n    PRIVATE_TRANSFER_TYPES,\n    VALID_TRANSFER_TYPES,\n} from \"./constants\";\n\nimport { logAndThrow } from \"./utils\";\n\n/**\n * Represents the options for executing a transaction in the Aleo network.\n * This interface is used to specify the parameters required for building and submitting an execution transaction.\n *\n * @property {string} programName - The name of the program containing the function to be executed.\n * @property {string} functionName - The name of the function to execute within the program.\n * @property {number} priorityFee - The optional priority fee to be paid for the transaction.\n * @property {boolean} privateFee - If true, uses a private record to pay the fee; otherwise, uses the account's public credit balance.\n * @property {string[]} inputs - The inputs to the function being executed.\n * @property {RecordSearchParams} [recordSearchParams] - Optional parameters for searching for a record to pay the execution transaction fee.\n * @property {KeySearchParams} [keySearchParams] - Optional parameters for finding the matching proving & verifying keys for the function.\n * @property {string | RecordPlaintext} [feeRecord] - Optional fee record to use for the transaction.\n * @property {ProvingKey} [provingKey] - Optional proving key to use for the transaction.\n * @property {VerifyingKey} [verifyingKey] - Optional verifying key to use for the transaction.\n * @property {PrivateKey} [privateKey] - Optional private key to use for the transaction.\n * @property {OfflineQuery} [offlineQuery] - Optional offline query if creating transactions in an offline environment.\n * @property {string | Program} [program] - Optional program source code to use for the transaction.\n * @property {ProgramImports} [imports] - Optional programs that the program being executed imports.\n */\ninterface ExecuteOptions {\n    programName: string;\n    functionName: string;\n    priorityFee: number;\n    privateFee: boolean;\n    inputs: string[];\n    recordSearchParams?: RecordSearchParams;\n    keySearchParams?: KeySearchParams;\n    feeRecord?: string | RecordPlaintext;\n    provingKey?: ProvingKey;\n    verifyingKey?: VerifyingKey;\n    privateKey?: PrivateKey;\n    offlineQuery?: OfflineQuery;\n    program?: string | Program;\n    imports?: ProgramImports;\n}\n\n/**\n * The ProgramManager class is used to execute and deploy programs on the Aleo network and create value transfers.\n */\nclass ProgramManager {\n    account: Account | undefined;\n    keyProvider: FunctionKeyProvider;\n    host: string;\n    networkClient: AleoNetworkClient;\n    recordProvider: RecordProvider | undefined;\n\n    /** Create a new instance of the ProgramManager\n     *\n     * @param { string | undefined } host A host uri running the official Aleo API\n     * @param { FunctionKeyProvider | undefined } keyProvider A key provider that implements {@link FunctionKeyProvider} interface\n     * @param { RecordProvider | undefined } recordProvider A record provider that implements {@link RecordProvider} interface\n     */\n    constructor(\n        host?: string | undefined,\n        keyProvider?: FunctionKeyProvider | undefined,\n        recordProvider?: RecordProvider | undefined,\n    ) {\n        this.host = host ? host : \"https://api.explorer.provable.com/v1\";\n        this.networkClient = new AleoNetworkClient(this.host);\n\n        this.keyProvider = keyProvider ? keyProvider : new AleoKeyProvider();\n        this.recordProvider = recordProvider;\n    }\n\n    /**\n     * Check if the fee is sufficient to pay for the transaction\n     */\n    async checkFee(address: string, feeAmount: bigint) {\n        const balance =\n            BigInt(await this.networkClient.getPublicBalance(address));\n        if (feeAmount > balance) {\n            throw Error(\n                `The desired execution requires a fee of ${feeAmount} microcredits, but the account paying the fee has ${balance} microcredits available.`,\n            );\n        }\n    }\n\n    /**\n     * Set the account to use for transaction submission to the Aleo network\n     *\n     * @param {Account} account Account to use for transaction submission\n     */\n    setAccount(account: Account) {\n        this.account = account;\n    }\n\n    /**\n     * Set the key provider that provides the proving and verifying keys for programs\n     *\n     * @param {FunctionKeyProvider} keyProvider\n     */\n    setKeyProvider(keyProvider: FunctionKeyProvider) {\n        this.keyProvider = keyProvider;\n    }\n\n    /**\n     * Set the host peer to use for transaction submission to the Aleo network\n     *\n     * @param host {string} Peer url to use for transaction submission\n     */\n    setHost(host: string) {\n        this.host = host;\n        this.networkClient.setHost(host);\n    }\n\n    /**\n     * Set the record provider that provides records for transactions\n     *\n     * @param {RecordProvider} recordProvider\n     */\n    setRecordProvider(recordProvider: RecordProvider) {\n        this.recordProvider = recordProvider;\n    }\n\n    /**\n     * Builds a deployment transaction for submission to the Aleo network.\n     *\n     * @param {string} program Program source code\n     * @param {number} priorityFee The optional priority fee to be paid for that transaction.\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to use pay the deployment fee\n     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @returns {string} The transaction id of the deployed program or a failure message from the network\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for deployments\n     * const program = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\";\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.setAccount(Account);\n     *\n     * // Define a fee in credits\n     * const priorityFee = 0.0;\n     *\n     * // Create the deployment transaction.\n     * const tx = await programManager.buildDeploymentTransaction(program, fee, false);\n     * await programManager.networkClient.submitTransaction(tx);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 20000);\n     */\n    async buildDeploymentTransaction(\n        program: string,\n        priorityFee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams,\n        feeRecord?: string | RecordPlaintext,\n        privateKey?: PrivateKey,\n    ): Promise<Transaction> {\n        // Ensure the program is valid.\n        let programObject;\n        try {\n            programObject = Program.fromString(program);\n        } catch (e: any) {\n            logAndThrow(\n                `Error parsing program: '${e.message}'. Please ensure the program is valid.`,\n            );\n        }\n\n        // Ensure the program is valid and does not exist on the network\n        try {\n            let programSource;\n            try {\n                programSource = await this.networkClient.getProgram(\n                    programObject.id(),\n                );\n            } catch (e) {\n                // Program does not exist on the network, deployment can proceed\n                console.log(\n                    `Program ${programObject.id()} does not exist on the network, deploying...`,\n                );\n            }\n            if (typeof programSource === \"string\") {\n                throw Error(`Program ${programObject.id()} already exists on the network, please rename your program`);\n            }\n        } catch (e: any) {\n            logAndThrow(`Error validating program: ${e.message}`);\n        }\n\n        // Get the private key from the account if it is not provided in the parameters\n        let deploymentPrivateKey = privateKey;\n        if (\n            typeof privateKey === \"undefined\" &&\n            typeof this.account !== \"undefined\"\n        ) {\n            deploymentPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof deploymentPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee\n                ? <RecordPlaintext>(\n                      await this.getCreditsRecord(\n                          priorityFee,\n                          [],\n                          feeRecord,\n                          recordSearchParams,\n                      )\n                  )\n                : undefined;\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`,\n            );\n        }\n\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        try {\n            feeKeys = privateFee\n                ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys()\n                : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`,\n            );\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n\n        // Resolve the program imports if they exist\n        let imports;\n        try {\n            imports = await this.networkClient.getProgramImports(program);\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`,\n            );\n        }\n\n        // Build a deployment transaction\n        return await WasmProgramManager.buildDeploymentTransaction(\n            deploymentPrivateKey,\n            program,\n            priorityFee,\n            feeRecord,\n            this.host,\n            imports,\n            feeProvingKey,\n            feeVerifyingKey,\n        );\n    }\n\n    /**\n     * Deploy an Aleo program to the Aleo network\n     *\n     * @param {string} program Program source code\n     * @param {number} priorityFee The optional fee to be paid for the transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to used pay the deployment fee\n     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @returns {string} The transaction id of the deployed program or a failure message from the network\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for deployments\n     * const program = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\";\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     *\n     * // Define a fee in credits\n     * const priorityFee = 0.0;\n     *\n     * // Deploy the program\n     * const tx_id = await programManager.deploy(program, fee, false);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 20000);\n     */\n    async deploy(\n        program: string,\n        priorityFee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams,\n        feeRecord?: string | RecordPlaintext,\n        privateKey?: PrivateKey,\n    ): Promise<string> {\n        const tx = <Transaction>(\n            await this.buildDeploymentTransaction(\n                program,\n                priorityFee,\n                privateFee,\n                recordSearchParams,\n                feeRecord,\n                privateKey,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Builds an execution transaction for submission to the Aleo network.\n     *\n     * @param {ExecuteOptions} options - The options for the execution transaction.\n     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error.\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     *\n     * // Build and execute the transaction\n     * const tx = await programManager.buildExecutionTransaction({\n     *   programName: \"hello_hello.aleo\",\n     *   functionName: \"hello_hello\",\n     *   priorityFee: 0.0,\n     *   privateFee: false,\n     *   inputs: [\"5u32\", \"5u32\"],\n     *   keySearchParams: { \"cacheKey\": \"hello_hello:hello\" }\n     * });\n     *\n     * // Submit the transaction to the network\n     * await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildExecutionTransaction(\n        options: ExecuteOptions,\n    ): Promise<Transaction> {\n        // Destructure the options object to access the parameters\n        const {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            recordSearchParams,\n            keySearchParams,\n            privateKey,\n            offlineQuery,\n        } = options;\n\n        let feeRecord = options.feeRecord;\n        let provingKey = options.provingKey;\n        let verifyingKey = options.verifyingKey;\n        let program = options.program;\n        let imports = options.imports;\n\n        // Ensure the function exists on the network\n        if (program === undefined) {\n            try {\n                program = <string>(\n                    await this.networkClient.getProgram(programName)\n                );\n            } catch (e: any) {\n                logAndThrow(\n                    `Error finding ${programName}. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`,\n                );\n            }\n        } else if (program instanceof Program) {\n            program = program.toString();\n        }\n\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (\n            typeof privateKey === \"undefined\" &&\n            typeof this.account !== \"undefined\"\n        ) {\n            executionPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee\n                ? <RecordPlaintext>(\n                      await this.getCreditsRecord(\n                          priorityFee,\n                          [],\n                          feeRecord,\n                          recordSearchParams,\n                      )\n                  )\n                : undefined;\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`,\n            );\n        }\n\n        // Get the fee proving and verifying keys from the key provider\n        let feeKeys;\n        try {\n            feeKeys = privateFee\n                ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys()\n                : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`,\n            );\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n\n        // If the function proving and verifying keys are not provided, attempt to find them using the key provider\n        if (!provingKey || !verifyingKey) {\n            try {\n                [provingKey, verifyingKey] = <FunctionKeyPair>(\n                    await this.keyProvider.functionKeys(keySearchParams)\n                );\n            } catch (e) {\n                console.log(\n                    `Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`,\n                );\n            }\n        }\n\n        // Resolve the program imports if they exist\n        const numberOfImports = Program.fromString(program).getImports().length;\n        if (numberOfImports > 0 && !imports) {\n            try {\n                imports = <ProgramImports>(\n                    await this.networkClient.getProgramImports(programName)\n                );\n            } catch (e: any) {\n                logAndThrow(\n                    `Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`,\n                );\n            }\n        }\n\n        // Build an execution transaction\n        return await WasmProgramManager.buildExecutionTransaction(\n            executionPrivateKey,\n            program,\n            functionName,\n            inputs,\n            priorityFee,\n            feeRecord,\n            this.host,\n            imports,\n            provingKey,\n            verifyingKey,\n            feeProvingKey,\n            feeVerifyingKey,\n            offlineQuery,\n        );\n    }\n\n    /**\n     * Builds an execution transaction for submission to the Aleo network.\n     *\n     * @param {ExecuteOptions} options - The options for the execution transaction.\n     * @returns {Promise<string>} - The transaction id\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     *\n     * // Build and execute the transaction\n     * const tx_id = await programManager.execute({\n     *   programName: \"hello_hello.aleo\",\n     *   functionName: \"hello_hello\",\n     *   priorityFee: 0.0,\n     *   privateFee: false,\n     *   inputs: [\"5u32\", \"5u32\"],\n     *   keySearchParams: { \"cacheKey\": \"hello_hello:hello\" }\n     * });\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async execute(options: ExecuteOptions): Promise<string> {\n        const tx = <Transaction>await this.buildExecutionTransaction(options);\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Run an Aleo program in offline mode\n     *\n     * @param {string} program Program source code containing the function to be executed\n     * @param {string} function_name Function name to execute\n     * @param {string[]} inputs Inputs to the function\n     * @param {number} proveExecution Whether to prove the execution of the function and return an execution transcript that contains the proof.\n     * @param {string[] | undefined} imports Optional imports to the program\n     * @param {KeySearchParams | undefined} keySearchParams Optional parameters for finding the matching proving & verifying keys for the function\n     * @param {ProvingKey | undefined} provingKey Optional proving key to use for the transaction\n     * @param {VerifyingKey | undefined} verifyingKey Optional verifying key to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<ExecutionResponse>} The execution response containing the outputs of the function and the proof if the program is proved.\n     *\n     * @example\n     * /// Import the mainnet version of the sdk used to build executions.\n     * import { Account, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * /// Create the source for the \"helloworld\" program\n     * const program = \"program helloworld.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\";\n     * const programManager = new ProgramManager(undefined, undefined, undefined);\n     *\n     * /// Create a temporary account for the execution of the program\n     * const account = new Account();\n     * programManager.setAccount(account);\n     *\n     * /// Get the response and ensure that the program executed correctly\n     * const executionResponse = await programManager.run(program, \"hello\", [\"5u32\", \"5u32\"]);\n     * const result = executionResponse.getOutputs();\n     * assert(result === [\"10u32\"]);\n     */\n    async run(\n        program: string,\n        function_name: string,\n        inputs: string[],\n        proveExecution: boolean,\n        imports?: ProgramImports,\n        keySearchParams?: KeySearchParams,\n        provingKey?: ProvingKey,\n        verifyingKey?: VerifyingKey,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<ExecutionResponse> {\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (\n            typeof privateKey === \"undefined\" &&\n            typeof this.account !== \"undefined\"\n        ) {\n            executionPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n\n        // If the function proving and verifying keys are not provided, attempt to find them using the key provider\n        if (!provingKey || !verifyingKey) {\n            try {\n                [provingKey, verifyingKey] = <FunctionKeyPair>(\n                    await this.keyProvider.functionKeys(keySearchParams)\n                );\n            } catch (e) {\n                console.log(\n                    `Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`,\n                );\n            }\n        }\n\n        // Run the program offline and return the result\n        console.log(\"Running program offline\");\n        console.log(\"Proving key: \", provingKey);\n        console.log(\"Verifying key: \", verifyingKey);\n        return WasmProgramManager.executeFunctionOffline(\n            executionPrivateKey,\n            program,\n            function_name,\n            inputs,\n            proveExecution,\n            false,\n            imports,\n            provingKey,\n            verifyingKey,\n            this.host,\n            offlineQuery,\n        );\n    }\n\n    /**\n     * Join two credits records into a single credits record\n     *\n     * @param {RecordPlaintext | string} recordOne First credits record to join\n     * @param {RecordPlaintext | string} recordTwo Second credits record to join\n     * @param {number} priorityFee The optional priority fee to be paid for the transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the fee record to use to pay the fee for the join transaction\n     * @param {RecordPlaintext | string | undefined} feeRecord Fee record to use for the join transaction\n     * @param {PrivateKey | undefined} privateKey Private key to use for the join transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const record_1 = \"{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 4106205762862305308495708971985748592380064201230396559307556388725936304984group.public}\"\n     * const record_2 = \"{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 1540945439182663264862696551825005342995406165131907382295858612069623286213group.public}\"\n     * const tx_id = await programManager.join(record_1, record_2, 0.05, false);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async join(\n        recordOne: RecordPlaintext | string,\n        recordTwo: RecordPlaintext | string,\n        priorityFee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams | undefined,\n        feeRecord?: RecordPlaintext | string | undefined,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<string> {\n        // Get the private key from the account if it is not provided in the parameters and assign the fee address\n        let executionPrivateKey = privateKey;\n        let feeAddress;\n        if (\n            typeof privateKey === \"undefined\" &&\n            typeof this.account !== \"undefined\"\n        ) {\n            executionPrivateKey = this.account.privateKey();\n            feeAddress = this.account?.address();\n        }\n        else if (typeof executionPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n        else {\n            feeAddress = Address.from_private_key(executionPrivateKey);\n        }\n\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        let joinKeys;\n        try {\n            feeKeys = privateFee\n                ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys()\n                : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n            joinKeys = <FunctionKeyPair>await this.keyProvider.joinKeys();\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`,\n            );\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n        const [joinProvingKey, joinVerifyingKey] = joinKeys;\n\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee\n                ? <RecordPlaintext>(\n                      await this.getCreditsRecord(\n                          priorityFee,\n                          [],\n                          feeRecord,\n                          recordSearchParams,\n                      )\n                  )\n                : undefined;\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`,\n            );\n        }\n\n        // Validate the records provided are valid plaintext records\n        try {\n            recordOne =\n                recordOne instanceof RecordPlaintext\n                    ? recordOne\n                    : RecordPlaintext.fromString(recordOne);\n            recordTwo =\n                recordTwo instanceof RecordPlaintext\n                    ? recordTwo\n                    : RecordPlaintext.fromString(recordTwo);\n        } catch (e: any) {\n            logAndThrow(\n                \"Records provided are not valid. Please ensure they are valid plaintext records.\",\n            );\n        }\n\n        // Build an execution transaction and submit it to the network\n        const tx = await WasmProgramManager.buildJoinTransaction(\n            executionPrivateKey,\n            recordOne,\n            recordTwo,\n            priorityFee,\n            feeRecord,\n            this.host,\n            joinProvingKey,\n            joinVerifyingKey,\n            feeProvingKey,\n            feeVerifyingKey,\n            offlineQuery,\n        );\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Split credits into two new credits records\n     *\n     * @param {number} splitAmount Amount in microcredits to split from the original credits record\n     * @param {RecordPlaintext | string} amountRecord Amount record to use for the split transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the split transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const record = \"{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 4106205762862305308495708971985748592380064201230396559307556388725936304984group.public}\"\n     * const tx_id = await programManager.split(25000000, record);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async split(\n        splitAmount: number,\n        amountRecord: RecordPlaintext | string,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<string> {\n         // Get the private key from the account if it is not provided in the parameters\n         let executionPrivateKey = privateKey;\n         if (\n             typeof privateKey === \"undefined\" &&\n             typeof this.account !== \"undefined\"\n         ) {\n             executionPrivateKey = this.account.privateKey();\n         }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n\n        // Get the split keys from the key provider\n        let splitKeys;\n        try {\n            splitKeys = <FunctionKeyPair>await this.keyProvider.splitKeys();\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`,\n            );\n        }\n        const [splitProvingKey, splitVerifyingKey] = splitKeys;\n\n        // Validate the record to be split\n        try {\n            amountRecord =\n                amountRecord instanceof RecordPlaintext\n                    ? amountRecord\n                    : RecordPlaintext.fromString(amountRecord);\n        } catch (e: any) {\n            logAndThrow(\n                \"Record provided is not valid. Please ensure it is a valid plaintext record.\",\n            );\n        }\n\n        // Build an execution transaction and submit it to the network\n        const tx = await WasmProgramManager.buildSplitTransaction(\n            executionPrivateKey,\n            splitAmount,\n            amountRecord,\n            this.host,\n            splitProvingKey,\n            splitVerifyingKey,\n            offlineQuery,\n        );\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Pre-synthesize proving and verifying keys for a program\n     *\n     * @param program {string} The program source code to synthesize keys for\n     * @param function_id {string} The function id to synthesize keys for\n     * @param inputs {Array<string>}  Sample inputs to the function\n     * @param privateKey {PrivateKey | undefined} Optional private key to use for the key synthesis\n     *\n     * @returns {Promise<FunctionKeyPair>}\n     */\n    async synthesizeKeys(\n        program: string,\n        function_id: string,\n        inputs: Array<string>,\n        privateKey?: PrivateKey,\n    ): Promise<FunctionKeyPair> {\n        // Resolve the program imports if they exist\n        let imports;\n\n        let executionPrivateKey = privateKey;\n        if (typeof executionPrivateKey === \"undefined\") {\n            if (typeof this.account !== \"undefined\") {\n                executionPrivateKey = this.account.privateKey();\n            } else {\n                executionPrivateKey = new PrivateKey();\n            }\n        }\n\n        // Attempt to run an offline execution of the program and extract the proving and verifying keys\n        try {\n            imports = await this.networkClient.getProgramImports(program);\n            const keyPair = await WasmProgramManager.synthesizeKeyPair(\n                executionPrivateKey,\n                program,\n                function_id,\n                inputs,\n                imports,\n            );\n            return [\n                <ProvingKey>keyPair.provingKey(),\n                <VerifyingKey>keyPair.verifyingKey(),\n            ];\n        } catch (e: any) {\n            logAndThrow(\n                `Could not synthesize keys - error ${e.message}. Please ensure the program is valid and the inputs are correct.`,\n            );\n        }\n    }\n\n    /**\n     * Build a transaction to transfer credits to another account for later submission to the Aleo network\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'\n     * @param {number} priorityFee The optional priority fee to be paid for the transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee records for the transfer transaction\n     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer\n     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const tx = await programManager.buildTransferTransaction(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"public\", 0.2, false);\n     * await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildTransferTransaction(\n        amount: number,\n        recipient: string,\n        transferType: string,\n        priorityFee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams,\n        amountRecord?: RecordPlaintext | string,\n        feeRecord?: RecordPlaintext | string,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<Transaction> {\n        // Validate the transfer type\n        transferType = <string>validateTransferType(transferType);\n\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (\n            typeof executionPrivateKey === \"undefined\" &&\n            typeof this.account !== \"undefined\"\n        ) {\n            executionPrivateKey = this.account.privateKey();\n        }\n\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw \"No private key provided and no private key set in the ProgramManager\";\n        }\n\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        let transferKeys;\n        try {\n            feeKeys = privateFee\n                ? <FunctionKeyPair>await this.keyProvider.feePrivateKeys()\n                : <FunctionKeyPair>await this.keyProvider.feePublicKeys();\n            transferKeys = <FunctionKeyPair>(\n                await this.keyProvider.transferKeys(transferType)\n            );\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`,\n            );\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n        const [transferProvingKey, transferVerifyingKey] = transferKeys;\n\n        // Get the amount and fee record from the account if it is not provided in the parameters\n        try {\n            // Track the nonces of the records found so no duplicate records are used\n            const nonces: string[] = [];\n            if (requiresAmountRecord(transferType)) {\n                // If the transfer type is private and requires an amount record, get it from the record provider\n                amountRecord = <RecordPlaintext>(\n                    await this.getCreditsRecord(\n                        priorityFee,\n                        [],\n                        amountRecord,\n                        recordSearchParams,\n                    )\n                );\n                nonces.push(amountRecord.nonce());\n            } else {\n                amountRecord = undefined;\n            }\n            feeRecord = privateFee\n                ? <RecordPlaintext>(\n                      await this.getCreditsRecord(\n                          priorityFee,\n                          nonces,\n                          feeRecord,\n                          recordSearchParams,\n                      )\n                  )\n                : undefined;\n        } catch (e: any) {\n            logAndThrow(\n                `Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`,\n            );\n        }\n\n        // Build an execution transaction\n        return await WasmProgramManager.buildTransferTransaction(\n            executionPrivateKey,\n            amount,\n            recipient,\n            transferType,\n            amountRecord,\n            priorityFee,\n            feeRecord,\n            this.host,\n            transferProvingKey,\n            transferVerifyingKey,\n            feeProvingKey,\n            feeVerifyingKey,\n            offlineQuery,\n        );\n    }\n\n    /**\n     * Build a transfer_public transaction to transfer credits to another account for later submission to the Aleo network\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {number} priorityFee The optional priority fee to be paid for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const tx = await programManager.buildTransferPublicTransaction(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", 0.2);\n     * await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildTransferPublicTransaction(\n        amount: number,\n        recipient: string,\n        priorityFee: number,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<Transaction> {\n        return this.buildTransferTransaction(\n            amount,\n            recipient,\n            \"public\",\n            priorityFee,\n            false,\n            undefined,\n            undefined,\n            undefined,\n            privateKey,\n            offlineQuery,\n        );\n    }\n\n    /**\n     * Build a transfer_public_as_signer transaction to transfer credits to another account for later submission to the Aleo network\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {number} priorityFee The optional priority fee to be paid for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const tx = await programManager.buildTransferPublicAsSignerTransaction(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", 0.2);\n     * await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildTransferPublicAsSignerTransaction(\n        amount: number,\n        recipient: string,\n        priorityFee: number,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<Transaction> {\n        return this.buildTransferTransaction(\n            amount,\n            recipient,\n            \"public\",\n            priorityFee,\n            false,\n            undefined,\n            undefined,\n            undefined,\n            privateKey,\n            offlineQuery,\n        );\n    }\n\n    /**\n     * Transfer credits to another account\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'\n     * @param {number} priorityFee The optional priority fee to be paid for the transfer\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee records for the transfer transaction\n     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer\n     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * /// Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     * keyProvider.useCache = true;\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const tx_id = await programManager.transfer(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"public\", 0.2, false);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async transfer(\n        amount: number,\n        recipient: string,\n        transferType: string,\n        priorityFee: number,\n        privateFee: boolean,\n        recordSearchParams?: RecordSearchParams,\n        amountRecord?: RecordPlaintext | string,\n        feeRecord?: RecordPlaintext | string,\n        privateKey?: PrivateKey,\n        offlineQuery?: OfflineQuery,\n    ): Promise<string> {\n        const tx = <Transaction>(\n            await this.buildTransferTransaction(\n                amount,\n                recipient,\n                transferType,\n                priorityFee,\n                privateFee,\n                recordSearchParams,\n                amountRecord,\n                feeRecord,\n                privateKey,\n                offlineQuery,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build transaction to bond credits to a validator for later submission to the Aleo Network\n     *\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 10,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction object for later submission\n     * const tx = await programManager.buildBondPublicTransaction(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     *\n     * // The transaction can be later submitted to the network using the network client.\n     * await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildBondPublicTransaction(\n        validator_address: string,\n        withdrawal_address: string,\n        amount: number,\n        options: Partial<ExecuteOptions> = {},\n    ) {\n        const scaledAmount = Math.trunc(amount * 1000000);\n\n        const {\n            programName = \"credits.aleo\",\n            functionName = \"bond_public\",\n            priorityFee = options.priorityFee || 0,\n            privateFee = false,\n            inputs = [\n                validator_address,\n                withdrawal_address,\n                `${scaledAmount.toString()}u64`,\n            ],\n            keySearchParams = new AleoKeyProviderParams({\n                proverUri: CREDITS_PROGRAM_KEYS.bond_public.prover,\n                verifierUri: CREDITS_PROGRAM_KEYS.bond_public.verifier,\n                cacheKey: \"credits.aleo/bond_public\",\n            }),\n            program = this.creditsProgram(),\n            ...additionalOptions\n        } = options;\n\n        const executeOptions: ExecuteOptions = {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions,\n        };\n\n        return await this.buildExecutionTransaction(executeOptions);\n    }\n\n    /**\n     * Bond credits to validator.\n     *\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the signer (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 1,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond\n     * @param {Options} options Options for the execution\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     *\n     * // Create the bonding transaction\n     * tx_id = await programManager.bondPublic(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async bondPublic(\n        validator_address: string,\n        withdrawal_address: string,\n        amount: number,\n        options: Partial<ExecuteOptions> = {},\n    ) {\n        const tx = <Transaction>(\n            await this.buildBondPublicTransaction(\n                validator_address,\n                withdrawal_address,\n                amount,\n                options,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build a bond_validator transaction for later submission to the Aleo Network.\n     *\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond. A minimum of 10000 credits is required to bond as a delegator.\n     * @param {number} commission The commission rate for the validator (must be between 0 and 100 - an error will be thrown if it is not)\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bond validator transaction object for later use.\n     * const tx = await programManager.buildBondValidatorTransaction(\"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     *\n     * // The transaction can later be submitted to the network using the network client.\n     * const tx_id = await programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async buildBondValidatorTransaction(\n        validator_address: string,\n        withdrawal_address: string,\n        amount: number,\n        commission: number,\n        options: Partial<ExecuteOptions> = {},\n    ) {\n        const scaledAmount = Math.trunc(amount * 1000000);\n\n        const adjustedCommission = Math.trunc(commission);\n\n        const {\n            programName = \"credits.aleo\",\n            functionName = \"bond_validator\",\n            priorityFee = options.priorityFee || 0,\n            privateFee = false,\n            inputs = [\n                validator_address,\n                withdrawal_address,\n                `${scaledAmount.toString()}u64`,\n                `${adjustedCommission.toString()}u8`,\n            ],\n            keySearchParams = new AleoKeyProviderParams({\n                proverUri: CREDITS_PROGRAM_KEYS.bond_validator.prover,\n                verifierUri: CREDITS_PROGRAM_KEYS.bond_validator.verifier,\n                cacheKey: \"credits.aleo/bond_validator\",\n            }),\n            program = this.creditsProgram(),\n            ...additionalOptions\n        } = options;\n\n        const executeOptions: ExecuteOptions = {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions,\n        };\n\n        return await this.buildExecutionTransaction(executeOptions);\n    }\n\n    /**\n     * Build transaction to bond a validator.\n     *\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 10,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond\n     * @param {number} commission The commission rate for the validator (must be between 0 and 100 - an error will be thrown if it is not)\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.bondValidator(\"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async bondValidator(\n        validator_address: string,\n        withdrawal_address: string,\n        amount: number,\n        commission: number,\n        options: Partial<ExecuteOptions> = {},\n    ) {\n        const tx = <Transaction>(\n            await this.buildBondValidatorTransaction(\n                validator_address,\n                withdrawal_address,\n                amount,\n                commission,\n                options,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build an unbond_public execution transaction to unbond credits from a validator in the Aleo network.\n     *\n     * @param {string} staker_address - The address of the staker who is unbonding the credits.\n     * @param {number} amount - The amount of credits to unbond (scaled by 1,000,000).\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error message.\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management.\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to unbond credits.\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * const tx = await programManager.buildUnbondPublicTransaction(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", 2000000);\n     *\n     * // The transaction can be submitted later to the network using the network client.\n     * programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildUnbondPublicTransaction(\n        staker_address: string,\n        amount: number,\n        options: Partial<ExecuteOptions> = {},\n    ): Promise<Transaction> {\n        const scaledAmount = Math.trunc(amount * 1000000);\n\n        const {\n            programName = \"credits.aleo\",\n            functionName = \"unbond_public\",\n            priorityFee = options.priorityFee || 0,\n            privateFee = false,\n            inputs = [staker_address, `${scaledAmount.toString()}u64`],\n            keySearchParams = new AleoKeyProviderParams({\n                proverUri: CREDITS_PROGRAM_KEYS.unbond_public.prover,\n                verifierUri: CREDITS_PROGRAM_KEYS.unbond_public.verifier,\n                cacheKey: \"credits.aleo/unbond_public\",\n            }),\n            program = this.creditsProgram(),\n            ...additionalOptions\n        } = options;\n\n        const executeOptions: ExecuteOptions = {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions,\n        };\n\n        return this.buildExecutionTransaction(executeOptions);\n    }\n\n    /**\n     * Unbond a specified amount of staked credits. If the address of the executor of this function is an existing\n     * validator, it will subtract this amount of credits from the validator's staked credits. If there are less than\n     * 1,000,000 credits staked pool after the unbond, the validator will be removed from the validator set. If the\n     * address of the executor of this function is not a validator and has credits bonded as a delegator, it will\n     * subtract this amount of credits from the delegator's staked credits. If there are less than 10 credits bonded\n     * after the unbond operation, the delegator will be removed from the validator's staking pool.\n     *\n     * @param {string} staker_address Address of the staker who is unbonding the credits\n     * @param {number} amount Amount of credits to unbond.\n     * @param {ExecuteOptions} options Options for the execution\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the unbond_public transaction and send it to the network\n     * const tx_id = await programManager.unbondPublic(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", 10);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async unbondPublic(\n        staker_address: string,\n        amount: number,\n        options: Partial<ExecuteOptions> = {},\n    ): Promise<string> {\n        const tx = <Transaction>(\n            await this.buildUnbondPublicTransaction(\n                staker_address,\n                amount,\n                options,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build a transaction to claim unbonded public credits in the Aleo network.\n     *\n     * @param {string} staker_address - The address of the staker who is claiming the credits.\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error message.\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to claim unbonded credits.\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     *\n     * // Create the claim_unbond_public transaction object for later use.\n     * const tx = await programManager.buildClaimUnbondPublicTransaction(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\");\n     *\n     * // The transaction can be submitted later to the network using the network client.\n     * programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildClaimUnbondPublicTransaction(\n        staker_address: string,\n        options: Partial<ExecuteOptions> = {},\n    ): Promise<Transaction> {\n        const {\n            programName = \"credits.aleo\",\n            functionName = \"claim_unbond_public\",\n            priorityFee = options.priorityFee || 0,\n            privateFee = false,\n            inputs = [staker_address],\n            keySearchParams = new AleoKeyProviderParams({\n                proverUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.prover,\n                verifierUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier,\n                cacheKey: \"credits.aleo/claim_unbond_public\",\n            }),\n            program = this.creditsProgram(),\n            ...additionalOptions\n        } = options;\n\n        const executeOptions: ExecuteOptions = {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions,\n        };\n\n        // Check if the account has sufficient credits to pay for the transaction\n        return await this.buildExecutionTransaction(executeOptions);\n    }\n\n    /**\n     * Claim unbonded credits. If credits have been unbonded by the account executing this function, this method will\n     * claim them and add them to the public balance of the account.\n     *\n     * @param {string} staker_address Address of the staker who is claiming the credits\n     * @param {ExecuteOptions} options\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the claim_unbond_public transaction\n     * const tx_id = await programManager.claimUnbondPublic(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\");\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async claimUnbondPublic(\n        staker_address: string,\n        options: Partial<ExecuteOptions> = {},\n    ): Promise<string> {\n        const tx = <Transaction>(\n            await this.buildClaimUnbondPublicTransaction(\n                staker_address,\n                options,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return await this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Build a set_validator_state transaction for later usage.\n     *\n     * This function allows a validator to set their state to be either opened or closed to new stakers.\n     * When the validator is open to new stakers, any staker (including the validator) can bond or unbond from the validator.\n     * When the validator is closed to new stakers, existing stakers can still bond or unbond from the validator, but new stakers cannot bond.\n     *\n     * This function serves two primary purposes:\n     * 1. Allow a validator to leave the committee, by closing themselves to stakers and then unbonding all of their stakers.\n     * 2. Allow a validator to maintain their % of stake, by closing themselves to allowing more stakers to bond to them.\n     *\n     * @param {boolean} validator_state\n     * @param {Partial<ExecuteOptions>} options - Override default execution options\n     * @returns {Promise<Transaction>} The transaction object\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     *\n     * // Create the set_validator_state transaction\n     * const tx = await programManager.buildSetValidatorStateTransaction(true);\n     *\n     * // The transaction can be submitted later to the network using the network client.\n     * programManager.networkClient.submitTransaction(tx.toString());\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx.id());\n     *  assert(transaction.id() === tx.id());\n     * }, 10000);\n     */\n    async buildSetValidatorStateTransaction(\n        validator_state: boolean,\n        options: Partial<ExecuteOptions> = {},\n    ): Promise<Transaction> {\n        const {\n            programName = \"credits.aleo\",\n            functionName = \"set_validator_state\",\n            priorityFee = 0,\n            privateFee = false,\n            inputs = [validator_state.toString()],\n            keySearchParams = new AleoKeyProviderParams({\n                proverUri: CREDITS_PROGRAM_KEYS.set_validator_state.prover,\n                verifierUri: CREDITS_PROGRAM_KEYS.set_validator_state.verifier,\n                cacheKey: \"credits.aleo/set_validator_state\",\n            }),\n            ...additionalOptions\n        } = options;\n\n        const executeOptions: ExecuteOptions = {\n            programName,\n            functionName,\n            priorityFee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions,\n        };\n\n        return await this.buildExecutionTransaction(executeOptions);\n    }\n\n    /**\n     * Submit a set_validator_state transaction to the Aleo Network.\n     *\n     * This function allows a validator to set their state to be either opened or closed to new stakers.\n     * When the validator is open to new stakers, any staker (including the validator) can bond or unbond from the validator.\n     * When the validator is closed to new stakers, existing stakers can still bond or unbond from the validator, but new stakers cannot bond.\n     *\n     * This function serves two primary purposes:\n     * 1. Allow a validator to leave the committee, by closing themselves to stakers and then unbonding all of their stakers.\n     * 2. Allow a validator to maintain their % of stake, by closing themselves to allowing more stakers to bond to them.\n     *\n     * @param {boolean} validator_state\n     * @param {Partial<ExecuteOptions>} options - Override default execution options\n     * @returns {Promise<string>} The transaction id\n     *\n     * @example\n     * // Import the mainnet version of the sdk.\n     * import { AleoKeyProvider, ProgramManager } from \"@provablehq/sdk/mainnet.js\";\n     *\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     *\n     * // Create the set_validator_state transaction\n     * const tx_id = await programManager.setValidatorState(true);\n     *\n     * // Verify the transaction was successful\n     * setTimeout(async () => {\n     *  const transaction = await programManager.networkClient.getTransaction(tx_id);\n     *  assert(transaction.id() === tx_id);\n     * }, 10000);\n     */\n    async setValidatorState(\n        validator_state: boolean,\n        options: Partial<ExecuteOptions> = {},\n    ) {\n        const tx = <Transaction>(\n            await this.buildSetValidatorStateTransaction(\n                validator_state,\n                options,\n            )\n        );\n\n        let feeAddress;\n\n        if (typeof options.privateKey !== \"undefined\") {\n            feeAddress = Address.from_private_key(options.privateKey);\n        } else if (this.account !== undefined) {\n            feeAddress = this.account?.address();\n        } else {\n            throw Error(\n                \"No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.\",\n            );\n        }\n\n        // Check if the account has sufficient credits to pay for the transaction\n        await this.checkFee(feeAddress.to_string(), tx.feeAmount());\n\n        return this.networkClient.submitTransaction(tx);\n    }\n\n    /**\n     * Verify a proof of execution from an offline execution\n     *\n     * @param {executionResponse} executionResponse\n     * @returns {boolean} True if the proof is valid, false otherwise\n     */\n    verifyExecution(executionResponse: ExecutionResponse): boolean {\n        try {\n            const execution = <FunctionExecution>(\n                executionResponse.getExecution()\n            );\n            const function_id = executionResponse.getFunctionId();\n            const program = executionResponse.getProgram();\n            const verifyingKey = executionResponse.getVerifyingKey();\n            return verifyFunctionExecution(\n                execution,\n                verifyingKey,\n                program,\n                function_id,\n            );\n        } catch (e) {\n            console.warn(\n                \"The execution was not found in the response, cannot verify the execution\",\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Create a program object from a program's source code\n     *\n     * @param {string} program Program source code\n     * @returns {Program} The program object\n     */\n    createProgramFromSource(program: string): Program {\n        return Program.fromString(program);\n    }\n\n    /**\n     * Get the credits program object\n     *\n     * @returns {Program} The credits program object\n     */\n    creditsProgram(): Program {\n        return Program.getCreditsProgram();\n    }\n\n    /**\n     * Verify a program is valid\n     *\n     * @param {string} program The program source code\n     */\n    verifyProgram(program: string): boolean {\n        try {\n            <Program>Program.fromString(program);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    // Internal utility function for getting a credits.aleo record\n    async getCreditsRecord(\n        amount: number,\n        nonces: string[],\n        record?: RecordPlaintext | string,\n        params?: RecordSearchParams,\n    ): Promise<RecordPlaintext> {\n        try {\n            return record instanceof RecordPlaintext\n                ? record\n                : RecordPlaintext.fromString(<string>record);\n        } catch (e) {\n            try {\n                const recordProvider = <RecordProvider>this.recordProvider;\n                return <RecordPlaintext>(\n                    await recordProvider.findCreditsRecord(\n                        amount,\n                        true,\n                        nonces,\n                        params,\n                    )\n                );\n            } catch (e: any) {\n                logAndThrow(\n                    `Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`,\n                );\n            }\n        }\n    }\n}\n\n// Ensure the transfer type requires an amount record\nfunction requiresAmountRecord(transferType: string): boolean {\n    return PRIVATE_TRANSFER_TYPES.has(transferType);\n}\n\n// Validate the transfer type\nfunction validateTransferType(transferType: string): string {\n    return VALID_TRANSFER_TYPES.has(transferType)\n        ? transferType\n        : logAndThrow(\n              `Invalid transfer type '${transferType}'. Valid transfer types are 'private', 'privateToPublic', 'public', and 'publicToPrivate'.`,\n          );\n}\n\nexport { ProgramManager };\n","function spawnWorker(url, module, memory, address) {\n        return new Promise((resolve) => {\n            const worker = new Worker(url, {\n                type: \"module\",\n            });\n\n            worker.addEventListener(\"message\", (event) => {\n                // This is needed in Node to wait one extra tick, so that way\n                // the Worker can fully initialize before we return.\n                setTimeout(() => {\n                    resolve(worker);\n\n                    // When running in Node, this allows the process to exit\n                    // even though the Worker is still running.\n                    if (worker.unref) {\n                        worker.unref();\n                    }\n                }, 0);\n            }, {\n                capture: true,\n                once: true,\n            });\n\n            worker.postMessage({\n                module,\n                memory,\n                address,\n            });\n        });\n    }\n\nlet wasm;\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); }\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.buffer !== wasm.memory.buffer) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().slice(ptr, ptr + len));\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_export_1(addHeapObject(e));\n    }\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n};\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer !== wasm.memory.buffer) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nconst CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(state => {\n    wasm.__wbindgen_export_5.get(state.dtor)(state.a, state.b);\n});\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_5.get(state.dtor)(a, state.b);\n                CLOSURE_DTORS.unregister(state);\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n    CLOSURE_DTORS.register(real, state, state);\n    return real;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * Verify an execution with a single function and a single transition. Executions with multiple\n * transitions or functions will fail to verify. Also, this does not verify that the state root of\n * the execution is included in the Aleo Network ledger.\n *\n * @param {Execution} execution The function execution to verify\n * @param {VerifyingKey} verifying_key The verifying key for the function\n * @param {Program} program The program that the function execution belongs to\n * @param {String} function_id The name of the function that was executed\n * @returns {boolean} True if the execution is valid, false otherwise\n * @param {Execution} execution\n * @param {VerifyingKey} verifying_key\n * @param {Program} program\n * @param {string} function_id\n * @returns {boolean}\n */\nfunction verifyFunctionExecution(execution, verifying_key, program, function_id) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(execution, Execution);\n        _assertClass(verifying_key, VerifyingKey);\n        _assertClass(program, Program);\n        const ptr0 = passStringToWasm0(function_id, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.verifyFunctionExecution(retptr, execution.__wbg_ptr, verifying_key.__wbg_ptr, program.__wbg_ptr, ptr0, len0);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return r0 !== 0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n/**\n * @param {number} receiver\n */\nfunction runRayonThread(receiver) {\n    wasm.runRayonThread(receiver);\n}\n\n/**\n * @param {URL} url\n * @param {number} num_threads\n * @returns {Promise<void>}\n */\nfunction initThreadPool(url, num_threads) {\n    const ret = wasm.initThreadPool(addHeapObject(url), num_threads);\n    return takeObject(ret);\n}\n\nfunction __wbg_adapter_40(arg0, arg1, arg2) {\n    wasm.__wbindgen_export_6(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_524(arg0, arg1, arg2, arg3) {\n    wasm.__wbindgen_export_7(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\nconst __wbindgen_enum_RequestCredentials = [\"omit\", \"same-origin\", \"include\"];\n\nconst __wbindgen_enum_RequestMode = [\"same-origin\", \"no-cors\", \"cors\", \"navigate\"];\n\nconst AddressFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_address_free(ptr >>> 0, 1));\n/**\n * Public address of an Aleo account\n */\nclass Address {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Address.prototype);\n        obj.__wbg_ptr = ptr;\n        AddressFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AddressFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr, 0);\n    }\n    /**\n     * Derive an Aleo address from a private key\n     *\n     * @param {PrivateKey} private_key The private key to derive the address from\n     * @returns {Address} Address corresponding to the private key\n     * @param {PrivateKey} private_key\n     * @returns {Address}\n     */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.address_from_private_key(private_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Derive an Aleo address from a view key\n     *\n     * @param {ViewKey} view_key The view key to derive the address from\n     * @returns {Address} Address corresponding to the view key\n     * @param {ViewKey} view_key\n     * @returns {Address}\n     */\n    static from_view_key(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.address_from_view_key(view_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Derive an Aleo address from a compute key.\n     *\n     * @param {ComputeKey} compute_key The compute key to derive the address from\n     * @param {ComputeKey} compute_key\n     * @returns {Address}\n     */\n    static from_compute_key(compute_key) {\n        _assertClass(compute_key, ComputeKey);\n        const ret = wasm.address_from_compute_key(compute_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Get an address from a series of bytes.\n     *\n     * @param {Uint8Array} bytes A left endian byte array representing the address.\n     *\n     * @returns {Address} The address object.\n     * @param {Uint8Array} bytes\n     * @returns {Address}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the left endian byte array representation of the address.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get an address from a series of bits represented as a boolean array.\n     *\n     * @param {Array} bits A left endian boolean array representing the bits of the address.\n     *\n     * @returns {Address} The address object.\n     * @param {Array<any>} bits\n     * @returns {Address}\n     */\n    static fromBitsLe(bits) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_fromBitsLe(retptr, addHeapObject(bits));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the left endian boolean array representation of the bits of the address.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.address_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get an address object from an array of fields.\n     *\n     * @param {Array} fields An array of fields.\n     *\n     * @returns {Plaintext} The address object.\n     * @param {Array<any>} fields\n     * @returns {Address}\n     */\n    static fromFields(fields) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_fromFields(retptr, addHeapObject(fields));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the field array representation of the address.\n     * @returns {Array<any>}\n     */\n    toFields() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_toFields(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get an address object from a group.\n     *\n     * @param {Group} group The group object.\n     *\n     * @returns {Address} The address object.\n     * @param {Group} group\n     * @returns {Address}\n     */\n    static fromGroup(group) {\n        _assertClass(group, Group);\n        var ptr0 = group.__destroy_into_raw();\n        const ret = wasm.address_fromGroup(ptr0);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Get the group representation of the address object.\n     * @returns {Group}\n     */\n    toGroup() {\n        const ret = wasm.address_toGroup(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Create an aleo address object from a string representation of an address\n     *\n     * @param {string} address String representation of an addressm\n     * @returns {Address} Address\n     * @param {string} address\n     * @returns {Address}\n     */\n    static from_string(address) {\n        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.address_from_string(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Get a string representation of an Aleo address object\n     *\n     * @param {Address} Address\n     * @returns {string} String representation of the address\n     * @returns {string}\n     */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the plaintext representation of the address.\n     * @returns {Plaintext}\n     */\n    toPlaintext() {\n        const ret = wasm.address_toPlaintext(this.__wbg_ptr);\n        return Plaintext.__wrap(ret);\n    }\n    /**\n     * Verify a signature for a message signed by the address\n     *\n     * @param {Uint8Array} Byte array representing a message signed by the address\n     * @returns {boolean} Boolean representing whether or not the signature is valid\n     * @param {Uint8Array} message\n     * @param {Signature} signature\n     * @returns {boolean}\n     */\n    verify(message, signature) {\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_3);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(signature, Signature);\n        const ret = wasm.address_verify(this.__wbg_ptr, ptr0, len0, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst BHP1024Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_bhp1024_free(ptr >>> 0, 1));\n\nclass BHP1024 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BHP1024.prototype);\n        obj.__wbg_ptr = ptr;\n        BHP1024Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BHP1024Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bhp1024_free(ptr, 0);\n    }\n    /**\n     * Create a BHP hasher with an input size of 1024 bits.\n     */\n    constructor() {\n        const ret = wasm.bhp1024_new();\n        this.__wbg_ptr = ret >>> 0;\n        BHP1024Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a BHP hasher with an input size of 1024 bits with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {BHP1024}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bhp1024_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BHP1024.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the BHP hash with an input hasher of 1024 bits.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp1024_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP hash with an input hasher of 1024 bits.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp1024_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 1024 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp1024_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 1024 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp1024_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst BHP256Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_bhp256_free(ptr >>> 0, 1));\n\nclass BHP256 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BHP256.prototype);\n        obj.__wbg_ptr = ptr;\n        BHP256Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BHP256Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bhp256_free(ptr, 0);\n    }\n    /**\n     * Create a BHP hasher with an input size of 256 bits.\n     */\n    constructor() {\n        const ret = wasm.bhp256_new();\n        this.__wbg_ptr = ret >>> 0;\n        BHP256Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a BHP hasher with an input size of 256 bits with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {BHP256}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bhp256_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BHP256.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the BHP hash with an input hasher of 256 bits.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp256_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP hash with an input hasher of 256 bits.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp256_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 256 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp256_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 256 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp256_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst BHP512Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_bhp512_free(ptr >>> 0, 1));\n\nclass BHP512 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BHP512.prototype);\n        obj.__wbg_ptr = ptr;\n        BHP512Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BHP512Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bhp512_free(ptr, 0);\n    }\n    /**\n     * Create a BHP hasher with an input size of 512 bits.\n     */\n    constructor() {\n        const ret = wasm.bhp512_new();\n        this.__wbg_ptr = ret >>> 0;\n        BHP512Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a BHP hasher with an input size of 512 bits with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {BHP512}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bhp512_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BHP512.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the BHP hash with an input hasher of 512 bits.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp512_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP hash with an input hasher of 512 bits.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp512_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 512 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp512_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 512 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp512_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst BHP768Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_bhp768_free(ptr >>> 0, 1));\n\nclass BHP768 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BHP768.prototype);\n        obj.__wbg_ptr = ptr;\n        BHP768Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BHP768Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bhp768_free(ptr, 0);\n    }\n    /**\n     * Create a BHP hasher with an input size of 768 bits.\n     */\n    constructor() {\n        const ret = wasm.bhp768_new();\n        this.__wbg_ptr = ret >>> 0;\n        BHP768Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a BHP hasher with an input size of 768 bits with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {BHP768}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bhp768_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BHP768.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the BHP hash with an input hasher of 768 bits.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp768_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP hash with an input hasher of 768 bits.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp768_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 768 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp768_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 768 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp768_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst CiphertextFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_ciphertext_free(ptr >>> 0, 1));\n/**\n * SnarkVM Ciphertext object. A Ciphertext represents an symmetrically encrypted plaintext. This\n * object provides decryption methods to recover the plaintext from the ciphertext (given the\n * api consumer has the proper decryption materials).\n *\n * @example\n */\nclass Ciphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Ciphertext.prototype);\n        obj.__wbg_ptr = ptr;\n        CiphertextFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CiphertextFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ciphertext_free(ptr, 0);\n    }\n    /**\n     * Decrypt the ciphertext using the given view key.\n     *\n     * @param {ViewKey} viewKey The view key of the account that encrypted the ciphertext.\n     * @param {Group} nonce The nonce used to encrypt the ciphertext.\n     *\n     * @returns {Plaintext} The decrypted plaintext.\n     * @param {ViewKey} view_key\n     * @param {Group} nonce\n     * @returns {Plaintext}\n     */\n    decrypt(view_key, nonce) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(view_key, ViewKey);\n            var ptr0 = view_key.__destroy_into_raw();\n            _assertClass(nonce, Group);\n            var ptr1 = nonce.__destroy_into_raw();\n            wasm.ciphertext_decrypt(retptr, this.__wbg_ptr, ptr0, ptr1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Decrypt a ciphertext using the view key of the transition signer, transition public key, and\n     * (program, function, index) tuple.\n     * @param {ViewKey} view_key\n     * @param {Group} transition_public_key\n     * @param {string} program\n     * @param {string} function_name\n     * @param {number} index\n     * @returns {Plaintext}\n     */\n    decryptWithTransitionInfo(view_key, transition_public_key, program, function_name, index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(view_key, ViewKey);\n            var ptr0 = view_key.__destroy_into_raw();\n            _assertClass(transition_public_key, Group);\n            var ptr1 = transition_public_key.__destroy_into_raw();\n            const ptr2 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len2 = WASM_VECTOR_LEN;\n            const ptr3 = passStringToWasm0(function_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len3 = WASM_VECTOR_LEN;\n            wasm.ciphertext_decryptWithTransitionInfo(retptr, this.__wbg_ptr, ptr0, ptr1, ptr2, len2, ptr3, len3, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Decrypt a ciphertext using the transition view key and a (program, function, index) tuple.\n     * @param {Field} transition_view_key\n     * @param {string} program\n     * @param {string} function_name\n     * @param {number} index\n     * @returns {Plaintext}\n     */\n    decryptWithTransitionViewKey(transition_view_key, program, function_name, index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(transition_view_key, Field);\n            var ptr0 = transition_view_key.__destroy_into_raw();\n            const ptr1 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len1 = WASM_VECTOR_LEN;\n            const ptr2 = passStringToWasm0(function_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len2 = WASM_VECTOR_LEN;\n            wasm.ciphertext_decryptWithTransitionViewKey(retptr, this.__wbg_ptr, ptr0, ptr1, len1, ptr2, len2, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Decrypts a ciphertext into plaintext using the given ciphertext view key.\n     *\n     * @param {Field} transition_view_key The transition view key that was used to encrypt the ciphertext.\n     *\n     * @returns {Plaintext} The decrypted plaintext.\n     * @param {Field} transition_view_key\n     * @returns {Plaintext}\n     */\n    decryptSymmetric(transition_view_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(transition_view_key, Field);\n            var ptr0 = transition_view_key.__destroy_into_raw();\n            wasm.ciphertext_decryptSymmetric(retptr, this.__wbg_ptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Deserialize a left endian byte array into a Ciphertext.\n     *\n     * @param {Uint8Array} bytes The byte array representing the Ciphertext.\n     *\n     * @returns {Ciphertext} The Ciphertext object.\n     * @param {Uint8Array} bytes\n     * @returns {Ciphertext}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ciphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the left endian byte array representation of the ciphertext.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_toBytes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a ciphertext object from a series of bits represented as a boolean array.\n     *\n     * @param {Array} bits A left endian boolean array representing the bits of the ciphertext.\n     *\n     * @returns {Ciphertext} The ciphertext object.\n     * @param {Array<any>} bits\n     * @returns {Ciphertext}\n     */\n    static fromBitsLe(bits) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_fromBitsLe(retptr, addHeapObject(bits));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ciphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the left endian boolean array representation of the bits of the ciphertext.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.ciphertext_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get a ciphertext object from an array of fields.\n     *\n     * @param {Array} fields An array of fields.\n     *\n     * @returns {Ciphertext} The ciphertext object.\n     * @param {Array<any>} fields\n     * @returns {Ciphertext}\n     */\n    static fromFields(fields) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_fromFields(retptr, addHeapObject(fields));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ciphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the field array representation of the ciphertext.\n     * @returns {Array<any>}\n     */\n    toFields() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_toFields(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Deserialize a Ciphertext string into a Ciphertext object.\n     *\n     * @param {string} ciphertext A string representation of the ciphertext.\n     *\n     * @returns {Ciphertext} The Ciphertext object.\n     * @param {string} ciphertext\n     * @returns {Ciphertext}\n     */\n    static fromString(ciphertext) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ciphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialize a Ciphertext object into a byte array.\n     *\n     * @returns {Uint8Array} The serialized Ciphertext.\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_toBytes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialize a Ciphertext into a js string.\n     *\n     * @returns {string} The serialized Ciphertext.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst ComputeKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_computekey_free(ptr >>> 0, 1));\n\nclass ComputeKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ComputeKey.prototype);\n        obj.__wbg_ptr = ptr;\n        ComputeKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ComputeKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_computekey_free(ptr, 0);\n    }\n    /**\n     * Create a new compute key from a private key.\n     *\n     * @param {PrivateKey} private_key Private key\n     *\n     * @returns {ComputeKey} Compute key\n     * @param {PrivateKey} private_key\n     * @returns {ComputeKey}\n     */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.computekey_from_private_key(private_key.__wbg_ptr);\n        return ComputeKey.__wrap(ret);\n    }\n    /**\n     * Get the address from the compute key.\n     *\n     * @returns {Address}\n     * @returns {Address}\n     */\n    address() {\n        const ret = wasm.address_from_compute_key(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Get the sk_prf of the compute key.\n     *\n     * @returns {Scalar} sk_prf\n     * @returns {Scalar}\n     */\n    sk_prf() {\n        const ret = wasm.computekey_sk_prf(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Get the pr_tag of the compute key.\n     *\n     * @returns {Group} pr_tag\n     * @returns {Group}\n     */\n    pk_sig() {\n        const ret = wasm.address_toGroup(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Get the pr_sig of the compute key.\n     *\n     * @returns {Group} pr_sig\n     * @returns {Group}\n     */\n    pr_sig() {\n        const ret = wasm.computekey_pr_sig(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n}\n\nconst ExecutionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_execution_free(ptr >>> 0, 1));\n/**\n * Execution of an Aleo program.\n */\nclass Execution {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Execution.prototype);\n        obj.__wbg_ptr = ptr;\n        ExecutionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ExecutionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_execution_free(ptr, 0);\n    }\n    /**\n     * Returns the string representation of the execution.\n     *\n     * @returns {string} The string representation of the execution.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.execution_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Creates an execution object from a string representation of an execution.\n     *\n     * @returns {Execution | Error} The wasm representation of an execution object.\n     * @param {string} execution\n     * @returns {Execution}\n     */\n    static fromString(execution) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(execution, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.execution_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Execution.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the global state root of the execution.\n     *\n     * @returns {Execution | Error} The global state root used in the execution.\n     * @returns {string}\n     */\n    globalStateRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.execution_globalStateRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the proof of the execution.\n     *\n     * @returns {string} The execution proof.\n     * @returns {string}\n     */\n    proof() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.execution_proof(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the transitions present in the execution.\n     *\n     * @returns Array<Transition> the array of transitions present in the execution.\n     * @returns {Array<any>}\n     */\n    transitions() {\n        const ret = wasm.execution_transitions(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n\nconst ExecutionResponseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_executionresponse_free(ptr >>> 0, 1));\n/**\n * Webassembly Representation of an Aleo function execution response\n *\n * This object is returned by the execution of an Aleo function off-chain. It provides methods for\n * retrieving the outputs of the function execution.\n */\nclass ExecutionResponse {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ExecutionResponse.prototype);\n        obj.__wbg_ptr = ptr;\n        ExecutionResponseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ExecutionResponseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_executionresponse_free(ptr, 0);\n    }\n    /**\n     * Get the outputs of the executed function\n     *\n     * @returns {Array} Array of strings representing the outputs of the function\n     * @returns {Array<any>}\n     */\n    getOutputs() {\n        const ret = wasm.executionresponse_getOutputs(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Returns the execution object if present, null if otherwise.\n     *\n     * @returns {Execution | undefined} The execution object if present, null if otherwise\n     * @returns {Execution | undefined}\n     */\n    getExecution() {\n        const ret = wasm.executionresponse_getExecution(this.__wbg_ptr);\n        return ret === 0 ? undefined : Execution.__wrap(ret);\n    }\n    /**\n     * Returns the program keys if present\n     * @returns {KeyPair}\n     */\n    getKeys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.executionresponse_getKeys(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return KeyPair.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the proving_key if the proving key was cached in the Execution response.\n     * Note the proving key is removed from the response object after the first call to this\n     * function. Subsequent calls will return null.\n     *\n     * @returns {ProvingKey | undefined} The proving key\n     * @returns {ProvingKey | undefined}\n     */\n    getProvingKey() {\n        const ret = wasm.executionresponse_getProvingKey(this.__wbg_ptr);\n        return ret === 0 ? undefined : ProvingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying_key associated with the program\n     *\n     * @returns {VerifyingKey} The verifying key\n     * @returns {VerifyingKey}\n     */\n    getVerifyingKey() {\n        const ret = wasm.executionresponse_getVerifyingKey(this.__wbg_ptr);\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the function identifier\n     * @returns {string}\n     */\n    getFunctionId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.executionresponse_getFunctionId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the program\n     * @returns {Program}\n     */\n    getProgram() {\n        const ret = wasm.executionresponse_getProgram(this.__wbg_ptr);\n        return Program.__wrap(ret);\n    }\n}\n\nconst FieldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_field_free(ptr >>> 0, 1));\n/**\n * Field element.\n */\nclass Field {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Field.prototype);\n        obj.__wbg_ptr = ptr;\n        FieldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof Field)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FieldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_field_free(ptr, 0);\n    }\n    /**\n     * Creates a field object from a string representation of a field element.\n     * @param {string} field\n     * @returns {Field}\n     */\n    static fromString(field) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(field, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.field_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the string representation of the field element.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.field_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a field element from a Uint8Array of left endian bytes.\n     * @param {Uint8Array} bytes\n     * @returns {Field}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.field_fromBytesLe(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Encode the field element as a Uint8Array of left endian bytes.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.field_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Reconstruct a field element from a boolean array representation.\n     * @param {Array<any>} bits\n     * @returns {Field}\n     */\n    static fromBitsLe(bits) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.field_fromBitsLe(retptr, addBorrowedObject(bits));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Get the left endian boolean array representation of the field element.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.field_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Create a plaintext from the field element.\n     * @returns {Plaintext}\n     */\n    toPlaintext() {\n        const ret = wasm.field_toPlaintext(this.__wbg_ptr);\n        return Plaintext.__wrap(ret);\n    }\n    /**\n     * Clone the field element.\n     * @returns {Field}\n     */\n    clone() {\n        const ret = wasm.field_clone(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Generate a random field element.\n     * @returns {Field}\n     */\n    static random() {\n        const ret = wasm.field_random();\n        return Field.__wrap(ret);\n    }\n    /**\n     * Add two field elements.\n     * @param {Field} other\n     * @returns {Field}\n     */\n    add(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_add(this.__wbg_ptr, other.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Subtract two field elements.\n     * @param {Field} other\n     * @returns {Field}\n     */\n    subtract(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_subtract(this.__wbg_ptr, other.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Multiply two field elements.\n     * @param {Field} other\n     * @returns {Field}\n     */\n    multiply(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_multiply(this.__wbg_ptr, other.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Divide two field elements.\n     * @param {Field} other\n     * @returns {Field}\n     */\n    divide(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_divide(this.__wbg_ptr, other.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Power of a field element.\n     * @param {Field} other\n     * @returns {Field}\n     */\n    pow(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_pow(this.__wbg_ptr, other.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Invert the field element.\n     * @returns {Field}\n     */\n    inverse() {\n        const ret = wasm.field_inverse(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Get the additive identity element of the field.\n     * @returns {Field}\n     */\n    static zero() {\n        const ret = wasm.field_zero();\n        return Field.__wrap(ret);\n    }\n    /**\n     * Get the multiplicative identity of the field.\n     * @returns {Field}\n     */\n    static one() {\n        const ret = wasm.field_one();\n        return Field.__wrap(ret);\n    }\n    /**\n     * Double the field element.\n     * @returns {Field}\n     */\n    double() {\n        const ret = wasm.field_double(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Check if one field element equals another.\n     * @param {Field} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_equals(this.__wbg_ptr, other.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst GraphKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_graphkey_free(ptr >>> 0, 1));\n\nclass GraphKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GraphKey.prototype);\n        obj.__wbg_ptr = ptr;\n        GraphKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        GraphKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_graphkey_free(ptr, 0);\n    }\n    /**\n     * Create a new graph key from a view key.\n     *\n     * @param {ViewKey} view_key View key\n     * @returns {GraphKey} Graph key\n     * @param {ViewKey} view_key\n     * @returns {GraphKey}\n     */\n    static from_view_key(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.graphkey_from_view_key(view_key.__wbg_ptr);\n        return GraphKey.__wrap(ret);\n    }\n    /**\n     * Create a new graph key from a string representation of a graph key\n     *\n     * @param {string} graph_key String representation of a graph key\n     * @returns {GraphKey} Graph key\n     * @param {string} graph_key\n     * @returns {GraphKey}\n     */\n    static from_string(graph_key) {\n        const ptr0 = passStringToWasm0(graph_key, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.graphkey_from_string(ptr0, len0);\n        return GraphKey.__wrap(ret);\n    }\n    /**\n     * Get a string representation of a graph key\n     *\n     * @returns {string} String representation of a graph key\n     * @returns {string}\n     */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.graphkey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the sk_tag of the graph key. Used to determine ownership of records.\n     * @returns {Field}\n     */\n    sk_tag() {\n        const ret = wasm.field_clone(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n}\n\nconst GroupFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_group_free(ptr >>> 0, 1));\n/**\n * Elliptic curve element.\n */\nclass Group {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Group.prototype);\n        obj.__wbg_ptr = ptr;\n        GroupFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        GroupFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_group_free(ptr, 0);\n    }\n    /**\n     * Creates a group object from a string representation of a group element.\n     * @param {string} group\n     * @returns {Group}\n     */\n    static fromString(group) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(group, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.group_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the string representation of the group element.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.group_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a group element from a Uint8Array of left endian bytes.\n     * @param {Uint8Array} bytes\n     * @returns {Group}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.group_fromBytesLe(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Encode the group element as a Uint8Array of left endian bytes.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.group_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Reconstruct a group element from a boolean array representation.\n     * @param {Array<any>} bits\n     * @returns {Group}\n     */\n    static fromBitsLe(bits) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.group_fromBitsLe(retptr, addBorrowedObject(bits));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Get the left endian boolean array representation of the group element.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.address_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the field array representation of the group.\n     * @returns {Array<any>}\n     */\n    toFields() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.group_toFields(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the x-coordinate of the group element.\n     * @returns {Field}\n     */\n    toXCoordinate() {\n        const ret = wasm.group_toXCoordinate(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Create a plaintext element from a group element.\n     * @returns {Plaintext}\n     */\n    toPlaintext() {\n        const ret = wasm.group_toPlaintext(this.__wbg_ptr);\n        return Plaintext.__wrap(ret);\n    }\n    /**\n     * Clone the group element.\n     * @returns {Group}\n     */\n    clone() {\n        const ret = wasm.group_clone(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Generate a random group element.\n     * @returns {Group}\n     */\n    static random() {\n        const ret = wasm.group_random();\n        return Group.__wrap(ret);\n    }\n    /**\n     * Add two group elements.\n     * @param {Group} other\n     * @returns {Group}\n     */\n    add(other) {\n        _assertClass(other, Group);\n        const ret = wasm.group_add(this.__wbg_ptr, other.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Subtract two group elements (equivalently: add the inverse of an element).\n     * @param {Group} other\n     * @returns {Group}\n     */\n    subtract(other) {\n        _assertClass(other, Group);\n        const ret = wasm.group_subtract(this.__wbg_ptr, other.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Multiply a group element by a scalar element.\n     * @param {Scalar} scalar\n     * @returns {Group}\n     */\n    scalarMultiply(scalar) {\n        _assertClass(scalar, Scalar);\n        const ret = wasm.group_scalarMultiply(this.__wbg_ptr, scalar.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Double the group element.\n     * @returns {Group}\n     */\n    double() {\n        const ret = wasm.group_double(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Get the inverse of the group element. This is the reflection of the point about the axis\n     * of symmetry i.e. (x,y) -> (x, -y).\n     * @returns {Group}\n     */\n    inverse() {\n        const ret = wasm.group_inverse(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Check if one group element equals another.\n     * @param {Group} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        _assertClass(other, Group);\n        const ret = wasm.group_equals(this.__wbg_ptr, other.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get the group identity element under the group operation (i.e. the point at infinity.)\n     * @returns {Group}\n     */\n    static zero() {\n        const ret = wasm.group_zero();\n        return Group.__wrap(ret);\n    }\n    /**\n     * Get the generator of the group.\n     * @returns {Group}\n     */\n    static generator() {\n        const ret = wasm.group_generator();\n        return Group.__wrap(ret);\n    }\n}\n\nconst KeyPairFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_keypair_free(ptr >>> 0, 1));\n/**\n * Key pair object containing both the function proving and verifying keys\n */\nclass KeyPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(KeyPair.prototype);\n        obj.__wbg_ptr = ptr;\n        KeyPairFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        KeyPairFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_keypair_free(ptr, 0);\n    }\n    /**\n     * Create new key pair from proving and verifying keys\n     *\n     * @param {ProvingKey} proving_key Proving key corresponding to a function in an Aleo program\n     * @param {VerifyingKey} verifying_key Verifying key corresponding to a function in an Aleo program\n     * @returns {KeyPair} Key pair object containing both the function proving and verifying keys\n     * @param {ProvingKey} proving_key\n     * @param {VerifyingKey} verifying_key\n     */\n    constructor(proving_key, verifying_key) {\n        _assertClass(proving_key, ProvingKey);\n        var ptr0 = proving_key.__destroy_into_raw();\n        _assertClass(verifying_key, VerifyingKey);\n        var ptr1 = verifying_key.__destroy_into_raw();\n        const ret = wasm.keypair_new(ptr0, ptr1);\n        this.__wbg_ptr = ret >>> 0;\n        KeyPairFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get the proving key. This method will remove the proving key from the key pair\n     *\n     * @returns {ProvingKey}\n     * @returns {ProvingKey}\n     */\n    provingKey() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.keypair_provingKey(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the verifying key. This method will remove the verifying key from the key pair\n     *\n     * @returns {VerifyingKey}\n     * @returns {VerifyingKey}\n     */\n    verifyingKey() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.keypair_verifyingKey(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VerifyingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst MetadataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_metadata_free(ptr >>> 0, 1));\n\nclass Metadata {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Metadata.prototype);\n        obj.__wbg_ptr = ptr;\n        MetadataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        MetadataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_metadata_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get name() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_metadata_name(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set name(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_metadata_name(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get locator() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_metadata_locator(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set locator(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_metadata_locator(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get prover() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_metadata_prover(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set prover(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_metadata_prover(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get verifier() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_metadata_verifier(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set verifier(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_metadata_verifier(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get verifyingKey() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_metadata_verifyingKey(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set verifyingKey(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_metadata_verifyingKey(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    static baseUrl() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadata_baseUrl(retptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static bond_public() {\n        const ret = wasm.metadata_bond_public();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static bond_validator() {\n        const ret = wasm.metadata_bond_validator();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static claim_unbond_public() {\n        const ret = wasm.metadata_claim_unbond_public();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static fee_private() {\n        const ret = wasm.metadata_fee_private();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static fee_public() {\n        const ret = wasm.metadata_fee_public();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static inclusion() {\n        const ret = wasm.metadata_inclusion();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static join() {\n        const ret = wasm.metadata_join();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static set_validator_state() {\n        const ret = wasm.metadata_set_validator_state();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static split() {\n        const ret = wasm.metadata_split();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static transfer_private() {\n        const ret = wasm.metadata_transfer_private();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static transfer_private_to_public() {\n        const ret = wasm.metadata_transfer_private_to_public();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static transfer_public() {\n        const ret = wasm.metadata_transfer_public();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static transfer_public_as_signer() {\n        const ret = wasm.metadata_transfer_public_as_signer();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static transfer_public_to_private() {\n        const ret = wasm.metadata_transfer_public_to_private();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static unbond_public() {\n        const ret = wasm.metadata_unbond_public();\n        return Metadata.__wrap(ret);\n    }\n}\n\nconst OfflineQueryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_offlinequery_free(ptr >>> 0, 1));\n/**\n * An offline query object used to insert the global state root and state paths needed to create\n * a valid inclusion proof offline.\n */\nclass OfflineQuery {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OfflineQuery.prototype);\n        obj.__wbg_ptr = ptr;\n        OfflineQueryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OfflineQueryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_offlinequery_free(ptr, 0);\n    }\n    /**\n     * Creates a new offline query object. The state root is required to be passed in as a string\n     * @param {number} block_height\n     * @param {string} state_root\n     */\n    constructor(block_height, state_root) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(state_root, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.offlinequery_new(retptr, block_height, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            OfflineQueryFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Add a new block height to the offline query object.\n     * @param {number} block_height\n     */\n    addBlockHeight(block_height) {\n        wasm.offlinequery_addBlockHeight(this.__wbg_ptr, block_height);\n    }\n    /**\n     * Add a new state path to the offline query object.\n     *\n     * @param {string} commitment: The commitment corresponding to a record inpout\n     * @param {string} state_path: The state path corresponding to the commitment\n     * @param {string} commitment\n     * @param {string} state_path\n     */\n    addStatePath(commitment, state_path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(commitment, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(state_path, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.offlinequery_addStatePath(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a json string representation of the offline query object\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.offlinequery_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create an offline query object from a json string representation\n     * @param {string} s\n     * @returns {OfflineQuery}\n     */\n    static fromString(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(s, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.offlinequery_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OfflineQuery.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst Pedersen128Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_pedersen128_free(ptr >>> 0, 1));\n\nclass Pedersen128 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Pedersen128.prototype);\n        obj.__wbg_ptr = ptr;\n        Pedersen128Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Pedersen128Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pedersen128_free(ptr, 0);\n    }\n    /**\n     * Create a Pedersen hasher for a given (up to) 128-bit input.\n     */\n    constructor() {\n        const ret = wasm.pedersen128_new();\n        this.__wbg_ptr = ret >>> 0;\n        Pedersen128Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a Pedersen hasher for a given (up to) 128-bit input with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {Pedersen128}\n     */\n    static setup(domain_separator) {\n        const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.pedersen128_setup(ptr0, len0);\n        return Pedersen128.__wrap(ret);\n    }\n    /**\n     * Returns the Pedersen hash for a given (up to) 128-bit input.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pedersen128_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a Pedersen commitment for the given (up to) 128-bit input and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.pedersen128_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a Pedersen commitment for the given (up to) 128-bit input and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.pedersen128_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst Pedersen64Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_pedersen64_free(ptr >>> 0, 1));\n\nclass Pedersen64 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Pedersen64.prototype);\n        obj.__wbg_ptr = ptr;\n        Pedersen64Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Pedersen64Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pedersen64_free(ptr, 0);\n    }\n    /**\n     * Create a Pedersen hasher for a given (up to) 64-bit input.\n     */\n    constructor() {\n        const ret = wasm.pedersen64_new();\n        this.__wbg_ptr = ret >>> 0;\n        Pedersen64Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a Pedersen64 hasher for a given (up to) 64-bit input with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {Pedersen64}\n     */\n    static setup(domain_separator) {\n        const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.pedersen64_setup(ptr0, len0);\n        return Pedersen64.__wrap(ret);\n    }\n    /**\n     * Returns the Pedersen hash for a given (up to) 64-bit input.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pedersen64_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a Pedersen commitment for the given (up to) 64-bit input and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.pedersen64_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a Pedersen commitment for the given (up to) 64-bit input and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.pedersen64_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst PlaintextFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_plaintext_free(ptr >>> 0, 1));\n/**\n * SnarkVM Plaintext object. Plaintext is a fundamental monadic type used to represent Aleo\n * primitive types (boolean, field, group, i8, i16, i32, i64, i128, u8, u16, u32, u64, u128,\n * scalar, and signature), struct types, and array types.\n *\n * In the context of a web or NodeJS application, this type is useful for turning an Aleo type into\n * a JS value, object, or array that might be necessary for performing computations within the\n * application.\n *\n * @example\n * // Get the bond state of an existing address.\n * const bondState = await fetch(https://api.explorer.provable.com/v1/mainnet/program/credits.aleo/mapping/bond_state/aleo12zlythl7htjdtjjjz3ahdj4vl6wk3zuzm37s80l86qpx8fyx95fqnxcn2f);\n * // Convert the bond state to a Plaintext object.\n * const bondStatePlaintext = Plaintext.fromString(bond_state);\n * // Convert the Plaintext object to a JS object.\n * const bondStateObject = bond_state_plaintext.toObject();\n * // Check if the bond state matches the expected object.\n * const expectedObject = { validator: \"aleo12zlythl7htjdtjjjz3ahdj4vl6wk3zuzm37s80l86qpx8fyx95fqnxcn2f\", microcredits: 100000000u64 };\n * assert( JSON.stringify(bondStateObject) === JSON.stringify(expectedObject) );\n */\nclass Plaintext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Plaintext.prototype);\n        obj.__wbg_ptr = ptr;\n        PlaintextFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PlaintextFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plaintext_free(ptr, 0);\n    }\n    /**\n     * Find plaintext member if the plaintext is a struct. Returns `null` if the plaintext is not\n     * a struct or the member does not exist.\n     *\n     * @param {string} name The name of the plaintext member to find.\n     *\n     * @returns {Plaintext} The plaintext member.\n     * @param {string} name\n     * @returns {Plaintext}\n     */\n    find(name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plaintext_find(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Encrypt a plaintext with an address and randomizer.\n     * @param {Address} address\n     * @param {Scalar} randomizer\n     * @returns {Ciphertext}\n     */\n    encrypt(address, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, Address);\n            _assertClass(randomizer, Scalar);\n            wasm.plaintext_encrypt(retptr, this.__wbg_ptr, address.__wbg_ptr, randomizer.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ciphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Encrypt a plaintext with a transition view key.\n     * @param {Field} transition_view_key\n     * @returns {Ciphertext}\n     */\n    encryptSymmetric(transition_view_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(transition_view_key, Field);\n            wasm.plaintext_encryptSymmetric(retptr, this.__wbg_ptr, transition_view_key.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ciphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Creates a plaintext object from a string representation of a plaintext.\n     *\n     * @param {string} plaintext The string representation of the plaintext.\n     *\n     * @returns {Plaintext} The plaintext object.\n     * @param {string} plaintext\n     * @returns {Plaintext}\n     */\n    static fromString(plaintext) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(plaintext, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plaintext_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a plaintext object from a series of bytes.\n     *\n     * @param {Uint8Array} bytes A left endian byte array representing the plaintext.\n     *\n     * @returns {Plaintext} The plaintext object.\n     * @param {Uint8Array} bytes\n     * @returns {Plaintext}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the left endian byte array representation of the plaintext.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a plaintext object from a series of bits represented as a boolean array.\n     *\n     * @param {Array} bits A left endian boolean array representing the bits plaintext.\n     *\n     * @returns {Plaintext} The plaintext object.\n     * @param {Array<any>} bits\n     * @returns {Plaintext}\n     */\n    static fromBitsLe(bits) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_fromBitsLe(retptr, addHeapObject(bits));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the left endian boolean array representation of the bits of the plaintext.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.plaintext_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get a plaintext object from an array of fields.\n     *\n     * @param {Array} fields An array of fields.\n     *\n     * @returns {Plaintext} The plaintext object.\n     * @param {Array<any>} fields\n     * @returns {Plaintext}\n     */\n    static fromFields(fields) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_fromFields(retptr, addHeapObject(fields));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the field array representation of the plaintext.\n     * @returns {Array<any>}\n     */\n    toFields() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_toFields(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the string representation of the plaintext.\n     *\n     * @returns {string} The string representation of the plaintext.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Gives the type of the plaintext.\n     *\n     * @returns {string} The type of the plaintext.\n     * @returns {string}\n     */\n    plaintextType() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_plaintextType(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Attempt to convert the plaintext to a JS object.\n     *\n     * @returns {Object} The JS object representation of the plaintext.\n     * @returns {any}\n     */\n    toObject() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_toObject(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst Poseidon2Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_poseidon2_free(ptr >>> 0, 1));\n\nclass Poseidon2 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Poseidon2.prototype);\n        obj.__wbg_ptr = ptr;\n        Poseidon2Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Poseidon2Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poseidon2_free(ptr, 0);\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 2.\n     */\n    constructor() {\n        const ret = wasm.poseidon2_new();\n        this.__wbg_ptr = ret >>> 0;\n        Poseidon2Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 2 and a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {Poseidon2}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poseidon2_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Poseidon2.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 2.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon2_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the extended Poseidon hash with an input rate of 2.\n     * @param {Array<any>} input\n     * @param {number} num_outputs\n     * @returns {Array<any>}\n     */\n    hashMany(input, num_outputs) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon2_hashMany(retptr, this.__wbg_ptr, addHeapObject(input), num_outputs);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 2 on the scalar field.\n     * @param {Array<any>} input\n     * @returns {Scalar}\n     */\n    hashToScalar(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon2_hashToScalar(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 2 on the affine curve.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon2_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst Poseidon4Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_poseidon4_free(ptr >>> 0, 1));\n\nclass Poseidon4 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Poseidon4.prototype);\n        obj.__wbg_ptr = ptr;\n        Poseidon4Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Poseidon4Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poseidon4_free(ptr, 0);\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 4.\n     */\n    constructor() {\n        const ret = wasm.poseidon4_new();\n        this.__wbg_ptr = ret >>> 0;\n        Poseidon4Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 4 and a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {Poseidon4}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poseidon4_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Poseidon4.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 4.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon4_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the extended Poseidon hash with an input rate of 4.\n     * @param {Array<any>} input\n     * @param {number} num_outputs\n     * @returns {Array<any>}\n     */\n    hashMany(input, num_outputs) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon4_hashMany(retptr, this.__wbg_ptr, addHeapObject(input), num_outputs);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 4 on the scalar field.\n     * @param {Array<any>} input\n     * @returns {Scalar}\n     */\n    hashToScalar(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon4_hashToScalar(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 4 on the affine curve.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon4_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst Poseidon8Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_poseidon8_free(ptr >>> 0, 1));\n\nclass Poseidon8 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Poseidon8.prototype);\n        obj.__wbg_ptr = ptr;\n        Poseidon8Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Poseidon8Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poseidon8_free(ptr, 0);\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 8.\n     */\n    constructor() {\n        const ret = wasm.poseidon8_new();\n        this.__wbg_ptr = ret >>> 0;\n        Poseidon8Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 8 and a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {Poseidon8}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poseidon8_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Poseidon8.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 8.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon8_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the extended Poseidon hash with an input rate of 8.\n     * @param {Array<any>} input\n     * @param {number} num_outputs\n     * @returns {Array<any>}\n     */\n    hashMany(input, num_outputs) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon8_hashMany(retptr, this.__wbg_ptr, addHeapObject(input), num_outputs);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 8 on the scalar field.\n     * @param {Array<any>} input\n     * @returns {Scalar}\n     */\n    hashToScalar(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon8_hashToScalar(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 8 on the affine curve.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon8_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst PrivateKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_privatekey_free(ptr >>> 0, 1));\n/**\n * Private key of an Aleo account\n */\nclass PrivateKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PrivateKey.prototype);\n        obj.__wbg_ptr = ptr;\n        PrivateKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PrivateKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekey_free(ptr, 0);\n    }\n    /**\n     * Generate a new private key using a cryptographically secure random number generator\n     *\n     * @returns {PrivateKey}\n     */\n    constructor() {\n        const ret = wasm.privatekey_new();\n        this.__wbg_ptr = ret >>> 0;\n        PrivateKeyFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get a private key from a series of unchecked bytes\n     *\n     * @param {Uint8Array} seed Unchecked 32 byte long Uint8Array acting as the seed for the private key\n     * @returns {PrivateKey}\n     * @param {Uint8Array} seed\n     * @returns {PrivateKey}\n     */\n    static from_seed_unchecked(seed) {\n        const ptr0 = passArray8ToWasm0(seed, wasm.__wbindgen_export_3);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_from_seed_unchecked(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n     * Get a private key from a string representation of a private key\n     *\n     * @param {string} seed String representation of a private key\n     * @returns {PrivateKey}\n     * @param {string} private_key\n     * @returns {PrivateKey}\n     */\n    static from_string(private_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(private_key, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_from_string(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a string representation of the private key. This function should be used very carefully\n     * as it exposes the private key plaintext\n     *\n     * @returns {string} String representation of a private key\n     * @returns {string}\n     */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the view key corresponding to the private key\n     *\n     * @returns {ViewKey}\n     * @returns {ViewKey}\n     */\n    to_view_key() {\n        const ret = wasm.privatekey_to_view_key(this.__wbg_ptr);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n     * Get the address corresponding to the private key\n     *\n     * @returns {Address}\n     * @returns {Address}\n     */\n    to_address() {\n        const ret = wasm.privatekey_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Sign a message with the private key\n     *\n     * @param {Uint8Array} Byte array representing a message signed by the address\n     * @returns {Signature} Signature generated by signing the message with the address\n     * @param {Uint8Array} message\n     * @returns {Signature}\n     */\n    sign(message) {\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_3);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_sign(this.__wbg_ptr, ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * Get a new randomly generated private key ciphertext using a secret. The secret is sensitive\n     * and will be needed to decrypt the private key later, so it should be stored securely\n     *\n     * @param {string} secret Secret used to encrypt the private key\n     * @returns {PrivateKeyCiphertext} Ciphertext representation of the private key\n     * @param {string} secret\n     * @returns {PrivateKeyCiphertext}\n     */\n    static newEncrypted(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_newEncrypted(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Encrypt an existing private key with a secret. The secret is sensitive and will be needed to\n     * decrypt the private key later, so it should be stored securely\n     *\n     * @param {string} secret Secret used to encrypt the private key\n     * @returns {PrivateKeyCiphertext} Ciphertext representation of the private key\n     * @param {string} secret\n     * @returns {PrivateKeyCiphertext}\n     */\n    toCiphertext(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_toCiphertext(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get private key from a private key ciphertext and secret originally used to encrypt it\n     *\n     * @param {PrivateKeyCiphertext} ciphertext Ciphertext representation of the private key\n     * @param {string} secret Secret originally used to encrypt the private key\n     * @returns {PrivateKey} Private key\n     * @param {PrivateKeyCiphertext} ciphertext\n     * @param {string} secret\n     * @returns {PrivateKey}\n     */\n    static fromPrivateKeyCiphertext(ciphertext, secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(ciphertext, PrivateKeyCiphertext);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_fromPrivateKeyCiphertext(retptr, ciphertext.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst PrivateKeyCiphertextFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_privatekeyciphertext_free(ptr >>> 0, 1));\n/**\n * Private Key in ciphertext form\n */\nclass PrivateKeyCiphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PrivateKeyCiphertext.prototype);\n        obj.__wbg_ptr = ptr;\n        PrivateKeyCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PrivateKeyCiphertextFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekeyciphertext_free(ptr, 0);\n    }\n    /**\n     * Encrypt a private key using a secret string. The secret is sensitive and will be needed to\n     * decrypt the private key later, so it should be stored securely\n     *\n     * @param {PrivateKey} private_key Private key to encrypt\n     * @param {string} secret Secret to encrypt the private key with\n     * @returns {PrivateKeyCiphertext} Private key ciphertext\n     * @param {PrivateKey} private_key\n     * @param {string} secret\n     * @returns {PrivateKeyCiphertext}\n     */\n    static encryptPrivateKey(private_key, secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(private_key, PrivateKey);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_toCiphertext(retptr, private_key.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Decrypts a private ciphertext using a secret string. This must be the same secret used to\n     * encrypt the private key\n     *\n     * @param {string} secret Secret used to encrypt the private key\n     * @returns {PrivateKey} Private key\n     * @param {string} secret\n     * @returns {PrivateKey}\n     */\n    decryptToPrivateKey(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_decryptToPrivateKey(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the ciphertext string\n     *\n     * @returns {string} Ciphertext string\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Creates a PrivateKeyCiphertext from a string\n     *\n     * @param {string} ciphertext Ciphertext string\n     * @returns {PrivateKeyCiphertext} Private key ciphertext\n     * @param {string} ciphertext\n     * @returns {PrivateKeyCiphertext}\n     */\n    static fromString(ciphertext) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst ProgramFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_program_free(ptr >>> 0, 1));\n/**\n * Webassembly Representation of an Aleo program\n */\nclass Program {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Program.prototype);\n        obj.__wbg_ptr = ptr;\n        ProgramFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ProgramFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_program_free(ptr, 0);\n    }\n    /**\n     * Create a program from a program string\n     *\n     * @param {string} program Aleo program source code\n     * @returns {Program} Program object\n     * @param {string} program\n     * @returns {Program}\n     */\n    static fromString(program) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Program.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a string representation of the program\n     *\n     * @returns {string} String containing the program source code\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Determine if a function is present in the program\n     *\n     * @param {string} functionName Name of the function to check for\n     * @returns {boolean} True if the program is valid, false otherwise\n     * @param {string} function_name\n     * @returns {boolean}\n     */\n    hasFunction(function_name) {\n        const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.program_hasFunction(this.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n     * Get javascript array of functions names in the program\n     *\n     * @returns {Array} Array of all function names present in the program\n     *\n     * @example\n     * const expected_functions = [\n     *   \"mint\",\n     *   \"transfer_private\",\n     *   \"transfer_private_to_public\",\n     *   \"transfer_public\",\n     *   \"transfer_public_to_private\",\n     *   \"join\",\n     *   \"split\",\n     *   \"fee\"\n     * ]\n     *\n     * const credits_program = aleo_wasm.Program.getCreditsProgram();\n     * const credits_functions = credits_program.getFunctions();\n     * console.log(credits_functions === expected_functions); // Output should be \"true\"\n     * @returns {Array<any>}\n     */\n    getFunctions() {\n        const ret = wasm.program_getFunctions(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get a javascript object representation of the function inputs and types. This can be used\n     * to generate a web form to capture user inputs for an execution of a function.\n     *\n     * @param {string} function_name Name of the function to get inputs for\n     * @returns {Array} Array of function inputs\n     *\n     * @example\n     * const expected_inputs = [\n     *     {\n     *       type:\"record\",\n     *       visibility:\"private\",\n     *       record:\"credits\",\n     *       members:[\n     *         {\n     *           name:\"microcredits\",\n     *           type:\"u64\",\n     *           visibility:\"private\"\n     *         }\n     *       ],\n     *       register:\"r0\"\n     *     },\n     *     {\n     *       type:\"address\",\n     *       visibility:\"private\",\n     *       register:\"r1\"\n     *     },\n     *     {\n     *       type:\"u64\",\n     *       visibility:\"private\",\n     *       register:\"r2\"\n     *     }\n     * ];\n     *\n     * const credits_program = aleo_wasm.Program.getCreditsProgram();\n     * const transfer_function_inputs = credits_program.getFunctionInputs(\"transfer_private\");\n     * console.log(transfer_function_inputs === expected_inputs); // Output should be \"true\"\n     * @param {string} function_name\n     * @returns {Array<any>}\n     */\n    getFunctionInputs(function_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getFunctionInputs(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a the list of a program's mappings and the names/types of their keys and values.\n     *\n     * @returns {Array} - An array of objects representing the mappings in the program\n     * @example\n     * const expected_mappings = [\n     *    {\n     *       name: \"account\",\n     *       key_name: \"owner\",\n     *       key_type: \"address\",\n     *       value_name: \"microcredits\",\n     *       value_type: \"u64\"\n     *    }\n     * ]\n     *\n     * const credits_program = aleo_wasm.Program.getCreditsProgram();\n     * const credits_mappings = credits_program.getMappings();\n     * console.log(credits_mappings === expected_mappings); // Output should be \"true\"\n     * @returns {Array<any>}\n     */\n    getMappings() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_getMappings(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a javascript object representation of a program record and its types\n     *\n     * @param {string} record_name Name of the record to get members for\n     * @returns {Object} Object containing the record name, type, and members\n     *\n     * @example\n     *\n     * const expected_record = {\n     *     type: \"record\",\n     *     record: \"Credits\",\n     *     members: [\n     *       {\n     *         name: \"owner\",\n     *         type: \"address\",\n     *         visibility: \"private\"\n     *       },\n     *       {\n     *         name: \"microcredits\",\n     *         type: \"u64\",\n     *         visibility: \"private\"\n     *       }\n     *     ];\n     *  };\n     *\n     * const credits_program = aleo_wasm.Program.getCreditsProgram();\n     * const credits_record = credits_program.getRecordMembers(\"Credits\");\n     * console.log(credits_record === expected_record); // Output should be \"true\"\n     * @param {string} record_name\n     * @returns {object}\n     */\n    getRecordMembers(record_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getRecordMembers(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a javascript object representation of a program struct and its types\n     *\n     * @param {string} struct_name Name of the struct to get members for\n     * @returns {Array} Array containing the struct members\n     *\n     * @example\n     *\n     * const STRUCT_PROGRAM = \"program token_issue.aleo;\n     *\n     * struct token_metadata:\n     *     network as u32;\n     *     version as u32;\n     *\n     * struct token:\n     *     token_id as u32;\n     *     metadata as token_metadata;\n     *\n     * function no_op:\n     *    input r0 as u64;\n     *    output r0 as u64;\"\n     *\n     * const expected_struct_members = [\n     *    {\n     *      name: \"token_id\",\n     *      type: \"u32\",\n     *    },\n     *    {\n     *      name: \"metadata\",\n     *      type: \"struct\",\n     *      struct_id: \"token_metadata\",\n     *      members: [\n     *       {\n     *         name: \"network\",\n     *         type: \"u32\",\n     *       }\n     *       {\n     *         name: \"version\",\n     *         type: \"u32\",\n     *       }\n     *     ]\n     *   }\n     * ];\n     *\n     * const program = aleo_wasm.Program.fromString(STRUCT_PROGRAM);\n     * const struct_members = program.getStructMembers(\"token\");\n     * console.log(struct_members === expected_struct_members); // Output should be \"true\"\n     * @param {string} struct_name\n     * @returns {Array<any>}\n     */\n    getStructMembers(struct_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(struct_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getStructMembers(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the credits.aleo program\n     *\n     * @returns {Program} The credits.aleo program\n     * @returns {Program}\n     */\n    static getCreditsProgram() {\n        const ret = wasm.program_getCreditsProgram();\n        return Program.__wrap(ret);\n    }\n    /**\n     * Get the id of the program\n     *\n     * @returns {string} The id of the program\n     * @returns {string}\n     */\n    id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_id(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get a unique address of the program\n     *\n     * @returns {Address} The address of the program\n     * @returns {Address}\n     */\n    address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_address(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Determine equality with another program\n     *\n     * @param {Program} other The other program to compare\n     * @returns {boolean} True if the programs are equal, false otherwise\n     * @param {Program} other\n     * @returns {boolean}\n     */\n    isEqual(other) {\n        _assertClass(other, Program);\n        const ret = wasm.program_isEqual(this.__wbg_ptr, other.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get program_imports\n     *\n     * @returns {Array} The program imports\n     *\n     * @example\n     *\n     * const DOUBLE_TEST = \"import multiply_test.aleo;\n     *\n     * program double_test.aleo;\n     *\n     * function double_it:\n     *     input r0 as u32.private;\n     *     call multiply_test.aleo/multiply 2u32 r0 into r1;\n     *     output r1 as u32.private;\";\n     *\n     * const expected_imports = [\n     *    \"multiply_test.aleo\"\n     * ];\n     *\n     * const program = aleo_wasm.Program.fromString(DOUBLE_TEST_PROGRAM);\n     * const imports = program.getImports();\n     * console.log(imports === expected_imports); // Output should be \"true\"\n     * @returns {Array<any>}\n     */\n    getImports() {\n        const ret = wasm.program_getImports(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n\nconst ProgramManagerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_programmanager_free(ptr >>> 0, 1));\n\nclass ProgramManager {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ProgramManagerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_programmanager_free(ptr, 0);\n    }\n    /**\n     * Deploy an Aleo program\n     *\n     * @param private_key The private key of the sender\n     * @param program The source code of the program being deployed\n     * @param imports A javascript object holding the source code of any imported programs in the\n     * form \\{\"program_name1\": \"program_source_code\", \"program_name2\": \"program_source_code\", ..\\}.\n     * Note that all imported programs must be deployed on chain before the main program in order\n     * for the deployment to succeed\n     * @param priority_fee_credits The optional priority fee to be paid for the transaction\n     * @param fee_record The record to spend the fee from\n     * @param url The url of the Aleo network node to send the transaction to\n     * @param imports (optional) Provide a list of imports to use for the program deployment in the\n     * form of a javascript object where the keys are a string of the program name and the values\n     * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n     * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n     * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n     * @returns {Transaction}\n     * @param {PrivateKey} private_key\n     * @param {string} program\n     * @param {number} priority_fee_credits\n     * @param {RecordPlaintext | null} [fee_record]\n     * @param {string | null} [url]\n     * @param {object | null} [imports]\n     * @param {ProvingKey | null} [fee_proving_key]\n     * @param {VerifyingKey | null} [fee_verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<Transaction>}\n     */\n    static buildDeploymentTransaction(private_key, program, priority_fee_credits, fee_record, url, imports, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        let ptr1 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr1 = fee_record.__destroy_into_raw();\n        }\n        var ptr2 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len2 = WASM_VECTOR_LEN;\n        let ptr3 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr3 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr4 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr4 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr5 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildDeploymentTransaction(private_key.__wbg_ptr, ptr0, len0, priority_fee_credits, ptr1, ptr2, len2, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr3, ptr4, ptr5);\n        return takeObject(ret);\n    }\n    /**\n     * Estimate the fee for a program deployment\n     *\n     * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n     *\n     * @param program The source code of the program being deployed\n     * @param imports (optional) Provide a list of imports to use for the deployment fee estimation\n     * in the form of a javascript object where the keys are a string of the program name and the values\n     * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n     * @returns {u64}\n     * @param {string} program\n     * @param {object | null} [imports]\n     * @returns {Promise<bigint>}\n     */\n    static estimateDeploymentFee(program, imports) {\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.programmanager_estimateDeploymentFee(ptr0, len0, isLikeNone(imports) ? 0 : addHeapObject(imports));\n        return takeObject(ret);\n    }\n    /**\n     * Estimate the component of the deployment cost which comes from the fee for the program name.\n     * Note that this cost does not represent the entire cost of deployment. It is additional to\n     * the cost of the size (in bytes) of the deployment.\n     *\n     * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n     *\n     * @param name The name of the program to be deployed\n     * @returns {u64}\n     * @param {string} name\n     * @returns {bigint}\n     */\n    static estimateProgramNameCost(name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.programmanager_estimateProgramNameCost(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getBigInt64(retptr + 8 * 0, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return BigInt.asUintN(64, r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Execute an arbitrary function locally\n     *\n     * @param {PrivateKey} private_key The private key of the sender\n     * @param {string} program The source code of the program being executed\n     * @param {string} function The name of the function to execute\n     * @param {Array} inputs A javascript array of inputs to the function\n     * @param {boolean} prove_execution If true, the execution will be proven and an execution object\n     * containing the proof and the encrypted inputs and outputs needed to verify the proof offline\n     * will be returned.\n     * @param {boolean} cache Cache the proving and verifying keys in the Execution response.\n     * If this is set to 'true' the keys synthesized will be stored in the Execution Response\n     * and the `ProvingKey` and `VerifyingKey` can be retrieved from the response via the `.getKeys()`\n     * method.\n     * @param {Object | undefined} imports (optional) Provide a list of imports to use for the function execution in the\n     * form of a javascript object where the keys are a string of the program name and the values\n     * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n     * @param {ProvingKey | undefined} proving_key (optional) Provide a verifying key to use for the function execution\n     * @param {VerifyingKey | undefined} verifying_key (optional) Provide a verifying key to use for the function execution\n     * @param {PrivateKey} private_key\n     * @param {string} program\n     * @param {string} _function\n     * @param {Array<any>} inputs\n     * @param {boolean} prove_execution\n     * @param {boolean} cache\n     * @param {object | null} [imports]\n     * @param {ProvingKey | null} [proving_key]\n     * @param {VerifyingKey | null} [verifying_key]\n     * @param {string | null} [url]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<ExecutionResponse>}\n     */\n    static executeFunctionOffline(private_key, program, _function, inputs, prove_execution, cache, imports, proving_key, verifying_key, url, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(proving_key)) {\n            _assertClass(proving_key, ProvingKey);\n            ptr2 = proving_key.__destroy_into_raw();\n        }\n        let ptr3 = 0;\n        if (!isLikeNone(verifying_key)) {\n            _assertClass(verifying_key, VerifyingKey);\n            ptr3 = verifying_key.__destroy_into_raw();\n        }\n        var ptr4 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len4 = WASM_VECTOR_LEN;\n        let ptr5 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr5 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_executeFunctionOffline(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), prove_execution, cache, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr2, ptr3, ptr4, len4, ptr5);\n        return takeObject(ret);\n    }\n    /**\n     * Execute Aleo function and create an Aleo execution transaction\n     *\n     * @param private_key The private key of the sender\n     * @param program The source code of the program being executed\n     * @param function The name of the function to execute\n     * @param inputs A javascript array of inputs to the function\n     * @param priority_fee_credits The optional priority fee to be paid for the transaction\n     * @param fee_record The record to spend the fee from\n     * @param url The url of the Aleo network node to send the transaction to\n     * If this is set to 'true' the keys synthesized (or passed in as optional parameters via the\n     * `proving_key` and `verifying_key` arguments) will be stored in the ProgramManager's memory\n     * and used for subsequent transactions. If this is set to 'false' the proving and verifying\n     * keys will be deallocated from memory after the transaction is executed.\n     * @param imports (optional) Provide a list of imports to use for the function execution in the\n     * form of a javascript object where the keys are a string of the program name and the values\n     * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n     * @param proving_key (optional) Provide a verifying key to use for the function execution\n     * @param verifying_key (optional) Provide a verifying key to use for the function execution\n     * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n     * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n     * @returns {Transaction}\n     * @param {PrivateKey} private_key\n     * @param {string} program\n     * @param {string} _function\n     * @param {Array<any>} inputs\n     * @param {number} priority_fee_credits\n     * @param {RecordPlaintext | null} [fee_record]\n     * @param {string | null} [url]\n     * @param {object | null} [imports]\n     * @param {ProvingKey | null} [proving_key]\n     * @param {VerifyingKey | null} [verifying_key]\n     * @param {ProvingKey | null} [fee_proving_key]\n     * @param {VerifyingKey | null} [fee_verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<Transaction>}\n     */\n    static buildExecutionTransaction(private_key, program, _function, inputs, priority_fee_credits, fee_record, url, imports, proving_key, verifying_key, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr2 = fee_record.__destroy_into_raw();\n        }\n        var ptr3 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len3 = WASM_VECTOR_LEN;\n        let ptr4 = 0;\n        if (!isLikeNone(proving_key)) {\n            _assertClass(proving_key, ProvingKey);\n            ptr4 = proving_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(verifying_key)) {\n            _assertClass(verifying_key, VerifyingKey);\n            ptr5 = verifying_key.__destroy_into_raw();\n        }\n        let ptr6 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr6 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr7 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr8 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildExecutionTransaction(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), priority_fee_credits, ptr2, ptr3, len3, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr4, ptr5, ptr6, ptr7, ptr8);\n        return takeObject(ret);\n    }\n    /**\n     * Estimate Fee for Aleo function execution. Note if \"cache\" is set to true, the proving and\n     * verifying keys will be stored in the ProgramManager's memory and used for subsequent\n     * program executions.\n     *\n     * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n     *\n     * @param private_key The private key of the sender\n     * @param program The source code of the program to estimate the execution fee for\n     * @param function The name of the function to execute\n     * @param inputs A javascript array of inputs to the function\n     * @param url The url of the Aleo network node to send the transaction to\n     * @param imports (optional) Provide a list of imports to use for the fee estimation in the\n     * form of a javascript object where the keys are a string of the program name and the values\n     * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n     * @param proving_key (optional) Provide a verifying key to use for the fee estimation\n     * @param verifying_key (optional) Provide a verifying key to use for the fee estimation\n     * @returns {u64} Fee in microcredits\n     * @param {PrivateKey} private_key\n     * @param {string} program\n     * @param {string} _function\n     * @param {Array<any>} inputs\n     * @param {string | null} [url]\n     * @param {object | null} [imports]\n     * @param {ProvingKey | null} [proving_key]\n     * @param {VerifyingKey | null} [verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<bigint>}\n     */\n    static estimateExecutionFee(private_key, program, _function, inputs, url, imports, proving_key, verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len2 = WASM_VECTOR_LEN;\n        let ptr3 = 0;\n        if (!isLikeNone(proving_key)) {\n            _assertClass(proving_key, ProvingKey);\n            ptr3 = proving_key.__destroy_into_raw();\n        }\n        let ptr4 = 0;\n        if (!isLikeNone(verifying_key)) {\n            _assertClass(verifying_key, VerifyingKey);\n            ptr4 = verifying_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr5 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_estimateExecutionFee(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), ptr2, len2, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr3, ptr4, ptr5);\n        return takeObject(ret);\n    }\n    /**\n     * Estimate the finalize fee component for executing a function. This fee is additional to the\n     * size of the execution of the program in bytes. If the function does not have a finalize\n     * step, then the finalize fee is 0.\n     *\n     * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n     *\n     * @param program The program containing the function to estimate the finalize fee for\n     * @param function The function to estimate the finalize fee for\n     * @returns {u64} Fee in microcredits\n     * @param {string} program\n     * @param {string} _function\n     * @returns {bigint}\n     */\n    static estimateFinalizeFee(program, _function) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.programmanager_estimateFinalizeFee(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getBigInt64(retptr + 8 * 0, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return BigInt.asUintN(64, r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Join two records together to create a new record with an amount of credits equal to the sum\n     * of the credits of the two original records\n     *\n     * @param private_key The private key of the sender\n     * @param record_1 The first record to combine\n     * @param record_2 The second record to combine\n     * @param priority_fee_credits The opptional priority fee to be paid for the transaction\n     * @param fee_record The record to spend the fee from\n     * @param url The url of the Aleo network node to send the transaction to\n     * @param join_proving_key (optional) Provide a proving key to use for the join function\n     * @param join_verifying_key (optional) Provide a verifying key to use for the join function\n     * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n     * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n     * @returns {Transaction} Transaction object\n     * @param {PrivateKey} private_key\n     * @param {RecordPlaintext} record_1\n     * @param {RecordPlaintext} record_2\n     * @param {number} priority_fee_credits\n     * @param {RecordPlaintext | null} [fee_record]\n     * @param {string | null} [url]\n     * @param {ProvingKey | null} [join_proving_key]\n     * @param {VerifyingKey | null} [join_verifying_key]\n     * @param {ProvingKey | null} [fee_proving_key]\n     * @param {VerifyingKey | null} [fee_verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<Transaction>}\n     */\n    static buildJoinTransaction(private_key, record_1, record_2, priority_fee_credits, fee_record, url, join_proving_key, join_verifying_key, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        _assertClass(record_1, RecordPlaintext);\n        var ptr0 = record_1.__destroy_into_raw();\n        _assertClass(record_2, RecordPlaintext);\n        var ptr1 = record_2.__destroy_into_raw();\n        let ptr2 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr2 = fee_record.__destroy_into_raw();\n        }\n        var ptr3 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len3 = WASM_VECTOR_LEN;\n        let ptr4 = 0;\n        if (!isLikeNone(join_proving_key)) {\n            _assertClass(join_proving_key, ProvingKey);\n            ptr4 = join_proving_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(join_verifying_key)) {\n            _assertClass(join_verifying_key, VerifyingKey);\n            ptr5 = join_verifying_key.__destroy_into_raw();\n        }\n        let ptr6 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr6 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr7 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr8 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildJoinTransaction(private_key.__wbg_ptr, ptr0, ptr1, priority_fee_credits, ptr2, ptr3, len3, ptr4, ptr5, ptr6, ptr7, ptr8);\n        return takeObject(ret);\n    }\n    /**\n     * Split an Aleo credits record into two separate records. This function does not require a fee.\n     *\n     * @param private_key The private key of the sender\n     * @param split_amount The amount of the credit split. This amount will be subtracted from the\n     * value of the record and two new records will be created with the split amount and the remainder\n     * @param amount_record The record to split\n     * @param url The url of the Aleo network node to send the transaction to\n     * @param split_proving_key (optional) Provide a proving key to use for the split function\n     * @param split_verifying_key (optional) Provide a verifying key to use for the split function\n     * @returns {Transaction} Transaction object\n     * @param {PrivateKey} private_key\n     * @param {number} split_amount\n     * @param {RecordPlaintext} amount_record\n     * @param {string | null} [url]\n     * @param {ProvingKey | null} [split_proving_key]\n     * @param {VerifyingKey | null} [split_verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<Transaction>}\n     */\n    static buildSplitTransaction(private_key, split_amount, amount_record, url, split_proving_key, split_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        _assertClass(amount_record, RecordPlaintext);\n        var ptr0 = amount_record.__destroy_into_raw();\n        var ptr1 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(split_proving_key)) {\n            _assertClass(split_proving_key, ProvingKey);\n            ptr2 = split_proving_key.__destroy_into_raw();\n        }\n        let ptr3 = 0;\n        if (!isLikeNone(split_verifying_key)) {\n            _assertClass(split_verifying_key, VerifyingKey);\n            ptr3 = split_verifying_key.__destroy_into_raw();\n        }\n        let ptr4 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr4 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildSplitTransaction(private_key.__wbg_ptr, split_amount, ptr0, ptr1, len1, ptr2, ptr3, ptr4);\n        return takeObject(ret);\n    }\n    /**\n     * Send credits from one Aleo account to another\n     *\n     * @param private_key The private key of the sender\n     * @param amount_credits The amount of credits to send\n     * @param recipient The recipient of the transaction\n     * @param transfer_type The type of the transfer (options: \"private\", \"public\", \"private_to_public\", \"public_to_private\")\n     * @param amount_record The record to fund the amount from\n     * @param priority_fee_credits The optional priority fee to be paid for the transaction\n     * @param fee_record The record to spend the fee from\n     * @param url The url of the Aleo network node to send the transaction to\n     * @param transfer_verifying_key (optional) Provide a verifying key to use for the transfer\n     * function\n     * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n     * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n     * @returns {Transaction}\n     * @param {PrivateKey} private_key\n     * @param {number} amount_credits\n     * @param {string} recipient\n     * @param {string} transfer_type\n     * @param {RecordPlaintext | null | undefined} amount_record\n     * @param {number} priority_fee_credits\n     * @param {RecordPlaintext | null} [fee_record]\n     * @param {string | null} [url]\n     * @param {ProvingKey | null} [transfer_proving_key]\n     * @param {VerifyingKey | null} [transfer_verifying_key]\n     * @param {ProvingKey | null} [fee_proving_key]\n     * @param {VerifyingKey | null} [fee_verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<Transaction>}\n     */\n    static buildTransferTransaction(private_key, amount_credits, recipient, transfer_type, amount_record, priority_fee_credits, fee_record, url, transfer_proving_key, transfer_verifying_key, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(recipient, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(transfer_type, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(amount_record)) {\n            _assertClass(amount_record, RecordPlaintext);\n            ptr2 = amount_record.__destroy_into_raw();\n        }\n        let ptr3 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr3 = fee_record.__destroy_into_raw();\n        }\n        var ptr4 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len4 = WASM_VECTOR_LEN;\n        let ptr5 = 0;\n        if (!isLikeNone(transfer_proving_key)) {\n            _assertClass(transfer_proving_key, ProvingKey);\n            ptr5 = transfer_proving_key.__destroy_into_raw();\n        }\n        let ptr6 = 0;\n        if (!isLikeNone(transfer_verifying_key)) {\n            _assertClass(transfer_verifying_key, VerifyingKey);\n            ptr6 = transfer_verifying_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr7 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr8 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr9 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr9 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildTransferTransaction(private_key.__wbg_ptr, amount_credits, ptr0, len0, ptr1, len1, ptr2, priority_fee_credits, ptr3, ptr4, len4, ptr5, ptr6, ptr7, ptr8, ptr9);\n        return takeObject(ret);\n    }\n    /**\n     * Synthesize proving and verifying keys for a program\n     *\n     * @param program {string} The program source code of the program to synthesize keys for\n     * @param function_id {string} The function to synthesize keys for\n     * @param inputs {Array} The inputs to the function\n     * @param imports {Object | undefined} The imports for the program\n     * @param {PrivateKey} private_key\n     * @param {string} program\n     * @param {string} function_id\n     * @param {Array<any>} inputs\n     * @param {object | null} [imports]\n     * @returns {Promise<KeyPair>}\n     */\n    static synthesizeKeyPair(private_key, program, function_id, inputs, imports) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(function_id, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.programmanager_synthesizeKeyPair(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), isLikeNone(imports) ? 0 : addHeapObject(imports));\n        return takeObject(ret);\n    }\n}\n\nconst ProvingKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_provingkey_free(ptr >>> 0, 1));\n/**\n * Proving key for a function within an Aleo program\n */\nclass ProvingKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ProvingKey.prototype);\n        obj.__wbg_ptr = ptr;\n        ProvingKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ProvingKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_provingkey_free(ptr, 0);\n    }\n    /**\n     * Verify if the proving key is for the bond_public function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"bond_public_proving_key.bin\");\n     * provingKey.isBondPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the bond_public function, false if otherwise\n     * @returns {boolean}\n     */\n    isBondPublicProver() {\n        const ret = wasm.provingkey_isBondPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the bond_validator function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"bond_validator_proving_key.bin\");\n     * provingKey.isBondPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the bond_validator function, false if otherwise\n     * @returns {boolean}\n     */\n    isBondValidatorProver() {\n        const ret = wasm.provingkey_isBondValidatorProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the claim_unbond function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"claim_unbond_proving_key.bin\");\n     * provingKey.isClaimUnbondProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the claim_unbond function, false if otherwise\n     * @returns {boolean}\n     */\n    isClaimUnbondPublicProver() {\n        const ret = wasm.provingkey_isClaimUnbondPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the fee_private function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"fee_private_proving_key.bin\");\n     * provingKey.isFeePrivateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the fee_private function, false if otherwise\n     * @returns {boolean}\n     */\n    isFeePrivateProver() {\n        const ret = wasm.provingkey_isFeePrivateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the fee_public function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"fee_public_proving_key.bin\");\n     * provingKey.isFeePublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the fee_public function, false if otherwise\n     * @returns {boolean}\n     */\n    isFeePublicProver() {\n        const ret = wasm.provingkey_isFeePublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the inclusion function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"inclusion_proving_key.bin\");\n     * provingKey.isInclusionProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the inclusion function, false if otherwise\n     * @returns {boolean}\n     */\n    isInclusionProver() {\n        const ret = wasm.provingkey_isInclusionProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the join function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"join_proving_key.bin\");\n     * provingKey.isJoinProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the join function, false if otherwise\n     * @returns {boolean}\n     */\n    isJoinProver() {\n        const ret = wasm.provingkey_isJoinProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the set_validator_state function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"set_validator_set_proving_key.bin\");\n     * provingKey.isSetValidatorStateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the set_validator_state function, false if otherwise\n     * @returns {boolean}\n     */\n    isSetValidatorStateProver() {\n        const ret = wasm.provingkey_isSetValidatorStateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the split function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"split_proving_key.bin\");\n     * provingKey.isSplitProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the split function, false if otherwise\n     * @returns {boolean}\n     */\n    isSplitProver() {\n        const ret = wasm.provingkey_isSplitProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the transfer_private function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"transfer_private_proving_key.bin\");\n     * provingKey.isTransferPrivateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the transfer_private function, false if otherwise\n     * @returns {boolean}\n     */\n    isTransferPrivateProver() {\n        const ret = wasm.provingkey_isTransferPrivateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the transfer_private_to_public function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"transfer_private_to_public_proving_key.bin\");\n     * provingKey.isTransferPrivateToPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the transfer_private_to_public function, false if otherwise\n     * @returns {boolean}\n     */\n    isTransferPrivateToPublicProver() {\n        const ret = wasm.provingkey_isTransferPrivateToPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the transfer_public function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"transfer_public_proving_key.bin\");\n     * provingKey.isTransferPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the transfer_public function, false if otherwise\n     * @returns {boolean}\n     */\n    isTransferPublicProver() {\n        const ret = wasm.provingkey_isTransferPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the transfer_public_as_signer function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"transfer_public_as_signer_proving_key.bin\");\n     * provingKey.isTransferPublicAsSignerProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the transfer_public function, false if otherwise\n     * @returns {boolean}\n     */\n    isTransferPublicAsSignerProver() {\n        const ret = wasm.provingkey_isTransferPublicAsSignerProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the transfer_public_to_private function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"transfer_public_to_private_proving_key.bin\");\n     * provingKey.isTransferPublicToPrivateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the transfer_public_to_private function, false if otherwise\n     * @returns {boolean}\n     */\n    isTransferPublicToPrivateProver() {\n        const ret = wasm.provingkey_isTransferPublicToPrivateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the unbond_public function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"unbond_public.bin\");\n     * provingKey.isUnbondPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the unbond_public_prover function, false if otherwise\n     * @returns {boolean}\n     */\n    isUnbondPublicProver() {\n        const ret = wasm.provingkey_isUnbondPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Return the checksum of the proving key\n     *\n     * @returns {string} Checksum of the proving key\n     * @returns {string}\n     */\n    checksum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.provingkey_checksum(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a copy of the proving key\n     *\n     * @returns {ProvingKey} A copy of the proving key\n     * @returns {ProvingKey}\n     */\n    copy() {\n        const ret = wasm.provingkey_copy(this.__wbg_ptr);\n        return ProvingKey.__wrap(ret);\n    }\n    /**\n     * Construct a new proving key from a byte array\n     *\n     * @param {Uint8Array} bytes Byte array representation of a proving key\n     * @returns {ProvingKey}\n     * @param {Uint8Array} bytes\n     * @returns {ProvingKey}\n     */\n    static fromBytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export_3);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.provingkey_fromBytes(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Create a proving key from string\n     *\n     * @param {string} String representation of the proving key\n     * @param {string} string\n     * @returns {ProvingKey}\n     */\n    static fromString(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(string, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.provingkey_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Return the byte representation of a proving key\n     *\n     * @returns {Uint8Array} Byte array representation of a proving key\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.provingkey_toBytes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_2(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a string representation of the proving key\n     *\n     * @returns {string} String representation of the proving key\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.provingkey_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst RecordCiphertextFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_recordciphertext_free(ptr >>> 0, 1));\n/**\n * Encrypted Aleo record\n */\nclass RecordCiphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RecordCiphertext.prototype);\n        obj.__wbg_ptr = ptr;\n        RecordCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RecordCiphertextFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_recordciphertext_free(ptr, 0);\n    }\n    /**\n     * Create a record ciphertext from a string\n     *\n     * @param {string} record String representation of a record ciphertext\n     * @returns {RecordCiphertext} Record ciphertext\n     * @param {string} record\n     * @returns {RecordCiphertext}\n     */\n    static fromString(record) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Return the string reprensentation of the record ciphertext\n     *\n     * @returns {string} String representation of the record ciphertext\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Decrypt the record ciphertext into plaintext using the view key. The record will only\n     * decrypt if the record was encrypted by the account corresponding to the view key\n     *\n     * @param {ViewKey} view_key View key used to decrypt the ciphertext\n     * @returns {RecordPlaintext} Record plaintext object\n     * @param {ViewKey} view_key\n     * @returns {RecordPlaintext}\n     */\n    decrypt(view_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(view_key, ViewKey);\n            wasm.recordciphertext_decrypt(retptr, this.__wbg_ptr, view_key.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordPlaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Determines if the account corresponding to the view key is the owner of the record\n     *\n     * @param {ViewKey} view_key View key used to decrypt the ciphertext\n     * @returns {boolean}\n     * @param {ViewKey} view_key\n     * @returns {boolean}\n     */\n    isOwner(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.recordciphertext_isOwner(this.__wbg_ptr, view_key.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get the tag of the record using the graph key.\n     *\n     * @param {GraphKey} graph key of the account associatd with the record.\n     * @param {Field} commitment of the record.\n     *\n     * @returns {Field} tag of the record.\n     * @param {GraphKey} graph_key\n     * @param {Field} commitment\n     * @returns {Field}\n     */\n    static tag(graph_key, commitment) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(graph_key, GraphKey);\n            _assertClass(commitment, Field);\n            var ptr0 = commitment.__destroy_into_raw();\n            wasm.recordciphertext_tag(retptr, graph_key.__wbg_ptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a record ciphertext object from a series of bytes.\n     *\n     * @param {Uint8Array} bytes A left endian byte array representing the record ciphertext.\n     *\n     * @returns {RecordCiphertext}\n     * @param {Uint8Array} bytes\n     * @returns {RecordCiphertext}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordciphertext_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the left endian byte array representation of the record ciphertext.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordciphertext_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the left endian boolean array representation of the record ciphertext bits.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.recordciphertext_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the field array representation of the record ciphertext.\n     * @returns {Array<any>}\n     */\n    toFields() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordciphertext_toFields(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst RecordPlaintextFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_recordplaintext_free(ptr >>> 0, 1));\n/**\n * Plaintext representation of an Aleo record\n */\nclass RecordPlaintext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RecordPlaintext.prototype);\n        obj.__wbg_ptr = ptr;\n        RecordPlaintextFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RecordPlaintextFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_recordplaintext_free(ptr, 0);\n    }\n    /**\n     * @param {string} program_id\n     * @param {string} record_name\n     * @returns {Field}\n     */\n    commitment(program_id, record_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(record_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_commitment(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Return a record plaintext from a string.\n     *\n     * @param {string} record String representation of a plaintext representation of an Aleo record\n     * @returns {RecordPlaintext} Record plaintext\n     * @param {string} record\n     * @returns {RecordPlaintext}\n     */\n    static fromString(record) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordPlaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string} input\n     * @returns {Plaintext}\n     */\n    getMember(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_getMember(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the owner of the record.\n     * @returns {Address}\n     */\n    owner() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_owner(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a representation of a record as a javascript object for usage in client side\n     * computations. Note that this is not a reversible operation and exists for the convenience\n     * of discovering and using properties of the record.\n     *\n     * The conversion guide is as follows:\n     * - u8, u16, u32, i8, i16 i32 --> Number\n     * - u64, u128, i64, i128 --> BigInt\n     * - Address, Field, Group, Scalar --> String.\n     *\n     * Address, Field, Group, and Scalar will all be converted to their bech32 string\n     * representation. These string representations can be converted back to their respective wasm\n     * types using the fromString method on the Address, Field, Group, and Scalar objects in this\n     * library.\n     *\n     * @example\n     * # Create a wasm record from a record string.\n     * let record_plaintext_wasm = RecordPlainext.from_string(\"{\n     *   owner: aleo1kh5t7m30djl0ecdn4f5vuzp7dx0tcwh7ncquqjkm4matj2p2zqpqm6at48.private,\n     *   metadata: {\n     *     player1: aleo1kh5t7m30djl0ecdn4f5vuzp7dx0tcwh7ncquqjkm4matj2p2zqpqm6at48.private,\n     *     player2: aleo1dreuxnmg9cny8ee9v2u0wr4v4affnwm09u2pytfwz0f2en2shgqsdsfjn6.private,\n     *     nonce: 660310649780728486489183263981322848354071976582883879926426319832534836534field.private\n     *   },\n     *   id: 1953278585719525811355617404139099418855053112960441725284031425961000152405field.private,\n     *   positions: 50794271u64.private,\n     *   attempts: 0u64.private,\n     *   hits: 0u64.private,\n     *   _nonce: 5668100912391182624073500093436664635767788874314097667746354181784048204413group.public\n     * }\");\n     *\n     * let expected_object = {\n     *   owner: \"aleo1kh5t7m30djl0ecdn4f5vuzp7dx0tcwh7ncquqjkm4matj2p2zqpqm6at48\",\n     *   metadata: {\n     *     player1: \"aleo1kh5t7m30djl0ecdn4f5vuzp7dx0tcwh7ncquqjkm4matj2p2zqpqm6at48\",\n     *     player2: \"aleo1dreuxnmg9cny8ee9v2u0wr4v4affnwm09u2pytfwz0f2en2shgqsdsfjn6\",\n     *     nonce: \"660310649780728486489183263981322848354071976582883879926426319832534836534field\"\n     *   },\n     *   id: \"1953278585719525811355617404139099418855053112960441725284031425961000152405field\",\n     *   positions: 50794271,\n     *   attempts: 0,\n     *   hits: 0,\n     *   _nonce: \"5668100912391182624073500093436664635767788874314097667746354181784048204413group\"\n     * };\n     *\n     * # Create the expected object\n     * let record_plaintext_object = record_plaintext_wasm.to_js_object();\n     * assert(JSON.stringify(record_plaintext_object) == JSON.stringify(expected_object));\n     *\n     * @returns {Object} Javascript object representation of the record\n     * @returns {object}\n     */\n    toJsObject() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_toJsObject(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the record plaintext string\n     *\n     * @returns {string} String representation of the record plaintext\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get a record plaintext object from a series of bytes.\n     *\n     * @param {Uint8Array} bytes A left endian byte array representing the record plaintext.\n     *\n     * @returns {RecordPlaintext} The record plaintext.\n     * @param {Uint8Array} bytes\n     * @returns {RecordPlaintext}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordPlaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the left endian byte array representation of the record plaintext.\n     *\n     * @returns {Uint8Array} Byte array representation of the record plaintext.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the left endian boolean array representation of the record plaintext bits.\n     *\n     * @returns {Array} Boolean array representation of the record plaintext bits.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.recordplaintext_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the field array representation of the record plaintext.\n     * @returns {Array<any>}\n     */\n    toFields() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_toFields(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the amount of microcredits in the record\n     *\n     * @returns {u64} Amount of microcredits in the record\n     * @returns {bigint}\n     */\n    microcredits() {\n        const ret = wasm.recordplaintext_microcredits(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * Returns the nonce of the record. This can be used to uniquely identify a record.\n     *\n     * @returns {string} Nonce of the record\n     * @returns {string}\n     */\n    nonce() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_nonce(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Attempt to get the serial number of a record to determine whether or not is has been spent\n     *\n     * @param {PrivateKey} private_key Private key of the account that owns the record\n     * @param {string} program_id Program ID of the program that the record is associated with\n     * @param {string} record_name Name of the record\n     *\n     * @returns {string} Serial number of the record\n     * @param {PrivateKey} private_key\n     * @param {string} program_id\n     * @param {string} record_name\n     * @returns {string}\n     */\n    serialNumberString(private_key, program_id, record_name) {\n        let deferred4_0;\n        let deferred4_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(private_key, PrivateKey);\n            const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(record_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_serialNumberString(retptr, this.__wbg_ptr, private_key.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr3 = r0;\n            var len3 = r1;\n            if (r3) {\n                ptr3 = 0; len3 = 0;\n                throw takeObject(r2);\n            }\n            deferred4_0 = ptr3;\n            deferred4_1 = len3;\n            return getStringFromWasm0(ptr3, len3);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred4_0, deferred4_1, 1);\n        }\n    }\n    /**\n     * Get the tag of the record using the graph key.\n     * @param {GraphKey} graph_key\n     * @param {Field} commitment\n     * @returns {Field}\n     */\n    tag(graph_key, commitment) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(graph_key, GraphKey);\n            _assertClass(commitment, Field);\n            var ptr0 = commitment.__destroy_into_raw();\n            wasm.recordplaintext_tag(retptr, this.__wbg_ptr, graph_key.__wbg_ptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst ScalarFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_scalar_free(ptr >>> 0, 1));\n/**\n * Scalar field element.\n */\nclass Scalar {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Scalar.prototype);\n        obj.__wbg_ptr = ptr;\n        ScalarFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ScalarFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scalar_free(ptr, 0);\n    }\n    /**\n     * Creates a scalar object from a string representation of a scalar element.\n     * @param {string} group\n     * @returns {Scalar}\n     */\n    static fromString(group) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(group, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scalar_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the string representation of the scalar element.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scalar_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a scalar element from a Uint8Array of left endian bytes.\n     * @param {Uint8Array} bytes\n     * @returns {Scalar}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scalar_fromBytesLe(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Encode the scalar element as a Uint8Array of left endian bytes.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scalar_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Reconstruct a scalar element from a boolean array representation.\n     * @param {Array<any>} bits\n     * @returns {Scalar}\n     */\n    static fromBitsLe(bits) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scalar_fromBitsLe(retptr, addBorrowedObject(bits));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Get the left endian boolean array representation of the scalar element.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.scalar_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Create a plaintext element from a scalar element.\n     * @returns {Plaintext}\n     */\n    toPlaintext() {\n        const ret = wasm.scalar_toPlaintext(this.__wbg_ptr);\n        return Plaintext.__wrap(ret);\n    }\n    /**\n     * Clone the scalar element.\n     * @returns {Scalar}\n     */\n    clone() {\n        const ret = wasm.field_clone(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Generate a random scalar element.\n     * @returns {Scalar}\n     */\n    static random() {\n        const ret = wasm.scalar_random();\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Add two scalar elements.\n     * @param {Scalar} other\n     * @returns {Scalar}\n     */\n    add(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.scalar_add(this.__wbg_ptr, other.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Subtract two scalar elements.\n     * @param {Scalar} other\n     * @returns {Scalar}\n     */\n    subtract(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.scalar_subtract(this.__wbg_ptr, other.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Multiply two scalar elements.\n     * @param {Scalar} other\n     * @returns {Scalar}\n     */\n    multiply(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.scalar_multiply(this.__wbg_ptr, other.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Divide two scalar elements.\n     * @param {Scalar} other\n     * @returns {Scalar}\n     */\n    divide(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.scalar_divide(this.__wbg_ptr, other.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Double the scalar element.\n     * @returns {Scalar}\n     */\n    double() {\n        const ret = wasm.scalar_double(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Power of a scalar element.\n     * @param {Scalar} other\n     * @returns {Scalar}\n     */\n    pow(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.scalar_pow(this.__wbg_ptr, other.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Invert the scalar element.\n     * @returns {Scalar}\n     */\n    inverse() {\n        const ret = wasm.scalar_inverse(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Get the multiplicative identity of the scalar field.\n     * @returns {Scalar}\n     */\n    static one() {\n        const ret = wasm.scalar_one();\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Get the additive identity of the scalar field.\n     * @returns {Scalar}\n     */\n    static zero() {\n        const ret = wasm.field_zero();\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Check if one scalar element equals another.\n     * @param {Scalar} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.field_equals(this.__wbg_ptr, other.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst SignatureFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signature_free(ptr >>> 0, 1));\n/**\n * Cryptographic signature of a message signed by an Aleo account\n */\nclass Signature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Signature.prototype);\n        obj.__wbg_ptr = ptr;\n        SignatureFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SignatureFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signature_free(ptr, 0);\n    }\n    /**\n     * Sign a message with a private key\n     *\n     * @param {PrivateKey} private_key The private key to sign the message with\n     * @param {Uint8Array} message Byte representation of the message to sign\n     * @returns {Signature} Signature of the message\n     * @param {PrivateKey} private_key\n     * @param {Uint8Array} message\n     * @returns {Signature}\n     */\n    static sign(private_key, message) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_3);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_sign(private_key.__wbg_ptr, ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * Get an address from a signature.\n     *\n     * @returns {Address} Address object\n     * @returns {Address}\n     */\n    to_address() {\n        const ret = wasm.signature_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Get the challenge of a signature.\n     * @returns {Scalar}\n     */\n    challenge() {\n        const ret = wasm.field_clone(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Get the response of a signature.\n     * @returns {Scalar}\n     */\n    response() {\n        const ret = wasm.signature_response(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Verify a signature of a message with an address\n     *\n     * @param {Address} address The address to verify the signature with\n     * @param {Uint8Array} message Byte representation of the message to verify\n     * @returns {boolean} True if the signature is valid, false otherwise\n     * @param {Address} address\n     * @param {Uint8Array} message\n     * @returns {boolean}\n     */\n    verify(address, message) {\n        _assertClass(address, Address);\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_3);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_verify(this.__wbg_ptr, address.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n     * Get a signature from a series of bytes.\n     *\n     * @param {Uint8Array} bytes A left endian byte array representing the signature.\n     *\n     * @returns {Signature} The signature object.\n     * @param {Uint8Array} bytes\n     * @returns {Signature}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Signature.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the left endian byte array representation of the signature.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a signature from a series of bits represented as a boolean array.\n     *\n     * @param {Array} bits A left endian boolean array representing the bits of the signature.\n     *\n     * @returns {Signature} The signature object.\n     * @param {Array<any>} bits\n     * @returns {Signature}\n     */\n    static fromBitsLe(bits) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_fromBitsLe(retptr, addHeapObject(bits));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Signature.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the left endian boolean array representation of the bits of the signature.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.signature_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the field array representation of the signature.\n     * @returns {Array<any>}\n     */\n    toFields() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_toFields(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a signature from a string representation of a signature\n     *\n     * @param {string} signature String representation of a signature\n     * @returns {Signature} Signature\n     * @param {string} signature\n     * @returns {Signature}\n     */\n    static from_string(signature) {\n        const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_from_string(ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * Get a string representation of a signature\n     *\n     * @returns {string} String representation of a signature\n     * @returns {string}\n     */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_to_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the plaintext representation of the signature.\n     * @returns {Plaintext}\n     */\n    toPlaintext() {\n        const ret = wasm.signature_toPlaintext(this.__wbg_ptr);\n        return Plaintext.__wrap(ret);\n    }\n}\n\nconst TransactionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transaction_free(ptr >>> 0, 1));\n/**\n * Webassembly Representation of an Aleo transaction\n *\n * This object is created when generating an on-chain function deployment or execution and is the\n * object that should be submitted to the Aleo Network in order to deploy or execute a function.\n */\nclass Transaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Transaction.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr, 0);\n    }\n    /**\n     * Create a transaction from a string\n     *\n     * @param {string} transaction String representation of a transaction\n     * @returns {Transaction}\n     * @param {string} transaction\n     * @returns {Transaction}\n     */\n    static fromString(transaction) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(transaction, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transaction_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Create a transaction from a Uint8Array of left endian bytes.\n     *\n     * @param {Uint8Array} Uint8Array of left endian bytes encoding a Transaction.\n     * @returns {Transaction}\n     * @param {Uint8Array} bytes\n     * @returns {Transaction}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the transaction as a string. If you want to submit this transaction to the Aleo Network\n     * this function will create the string that should be submitted in the `POST` data.\n     *\n     * @returns {string} String representation of the transaction\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the transaction as a Uint8Array of left endian bytes.\n     *\n     * @returns {Uint8Array} Uint8Array representation of the transaction\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns true if the transaction contains the given serial number.\n     *\n     * @param {boolean} True if the transaction contains the given serial number.\n     * @param {Field} serial_number\n     * @returns {boolean}\n     */\n    constainsSerialNumber(serial_number) {\n        _assertClass(serial_number, Field);\n        const ret = wasm.transaction_constainsSerialNumber(this.__wbg_ptr, serial_number.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Returns true if the transaction contains the given commitment.\n     *\n     * @param {boolean} True if the transaction contains the given commitment.\n     * @param {Field} commitment\n     * @returns {boolean}\n     */\n    constainsCommitment(commitment) {\n        _assertClass(commitment, Field);\n        const ret = wasm.transaction_constainsCommitment(this.__wbg_ptr, commitment.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Find a record in the transaction by the record's commitment.\n     * @param {Field} commitment\n     * @returns {RecordCiphertext | undefined}\n     */\n    findRecord(commitment) {\n        _assertClass(commitment, Field);\n        const ret = wasm.transaction_findRecord(this.__wbg_ptr, commitment.__wbg_ptr);\n        return ret === 0 ? undefined : RecordCiphertext.__wrap(ret);\n    }\n    /**\n     * Returns the transaction's base fee.\n     * @returns {bigint}\n     */\n    baseFeeAmount() {\n        const ret = wasm.transaction_baseFeeAmount(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * Returns the transaction's total fee.\n     * @returns {bigint}\n     */\n    feeAmount() {\n        const ret = wasm.transaction_feeAmount(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * Returns the transaction's priority fee.\n     *\n     * returns {bigint} The transaction's priority fee.\n     * @returns {bigint}\n     */\n    priorityFeeAmount() {\n        const ret = wasm.transaction_priorityFeeAmount(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * Returns true if the transaction is a deployment transaction.\n     *\n     * @returns {boolean} True if the transaction is a deployment transaction\n     * @returns {boolean}\n     */\n    isDeploy() {\n        const ret = wasm.transaction_isDeploy(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Returns true if the transaction is an execution transaction.\n     *\n     * @returns {boolean} True if the transaction is an execution transaction\n     * @returns {boolean}\n     */\n    isExecute() {\n        const ret = wasm.transaction_isExecute(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Returns true if the transaction is a fee transaction.\n     *\n     * @returns {boolean} True if the transaction is a fee transaction\n     * @returns {boolean}\n     */\n    isFee() {\n        const ret = wasm.transaction_isFee(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Returns the program deployed within the transaction if the transaction is a deployment\n     * transaction.\n     *\n     * @returns {Program | undefined} The program deployed within the transaction.\n     * @returns {Program | undefined}\n     */\n    deployedProgram() {\n        const ret = wasm.transaction_deployedProgram(this.__wbg_ptr);\n        return ret === 0 ? undefined : Program.__wrap(ret);\n    }\n    /**\n     * Returns the execution within the transaction (if present).\n     *\n     * @returns {Execution | undefined} The execution within the transaction.\n     * @returns {Execution | undefined}\n     */\n    execution() {\n        const ret = wasm.transaction_execution(this.__wbg_ptr);\n        return ret === 0 ? undefined : Execution.__wrap(ret);\n    }\n    /**\n     * Get the record plaintext present in a transaction owned by a specific view key.\n     *\n     * @param {ViewKey} view_key View key used to decrypt the ciphertext\n     *\n     * @returns {Array<RecordPlaintext>} Array of record plaintext objects\n     * @param {ViewKey} view_key\n     * @returns {Array<any>}\n     */\n    ownedRecords(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.transaction_ownedRecords(this.__wbg_ptr, view_key.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the records present in a transaction and their commitments.\n     *\n     * @returns {Array<{commitment: Field, record: RecordCiphertext}>} Array of record ciphertext objects\n     * @returns {Array<any>}\n     */\n    records() {\n        const ret = wasm.transaction_records(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get a summary of the transaction within a javascript object.\n     *\n     * If the transaction is an execution transaction, this function will return a list of the\n     * transitions and their inputs and outputs.\n     *\n     * If the transaction is a deployment transaction, this function will return the program id and\n     * a list of the functions and their verifying keys, constraint, and variable counts.\n     *\n     * @param {boolean} convert_to_js If true the inputs and outputs will be converted to JS objects,\n     * if false the inputs and outputs will be in wasm format.\n     *\n     * @returns {Object} Transaction summary\n     * @param {boolean} convert_to_js\n     * @returns {object}\n     */\n    summary(convert_to_js) {\n        const ret = wasm.transaction_summary(this.__wbg_ptr, convert_to_js);\n        return takeObject(ret);\n    }\n    /**\n     * Get the id of the transaction. This is the merkle root of the transaction's inclusion proof.\n     *\n     * This value can be used to query the status of the transaction on the Aleo Network to see\n     * if it was successful. If successful, the transaction will be included in a block and this\n     * value can be used to lookup the transaction data on-chain.\n     *\n     * @returns {string} TransactionId\n     * @returns {string}\n     */\n    id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_id(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the\n     * Get the type of the transaction (will return \"deploy\" or \"execute\")\n     *\n     * @returns {string} Transaction type\n     * @returns {string}\n     */\n    transactionType() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_transactionType(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the transitions in a transaction.\n     *\n     * @returns {Array<Transition>} Array of transition objects\n     * @returns {Array<any>}\n     */\n    transitions() {\n        const ret = wasm.transaction_transitions(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the verifying keys in a transaction.\n     *\n     * @returns {Array<Object>} Array of verifying keys.\n     * @returns {Array<any>}\n     */\n    verifyingKeys() {\n        const ret = wasm.transaction_verifyingKeys(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n\nconst TransitionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transition_free(ptr >>> 0, 1));\n\nclass Transition {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Transition.prototype);\n        obj.__wbg_ptr = ptr;\n        TransitionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransitionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transition_free(ptr, 0);\n    }\n    /**\n     * Get the transition ID\n     *\n     * @returns {string} The transition ID\n     * @returns {string}\n     */\n    id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_id(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a transition from a string\n     *\n     * @param {string} transition String representation of a transition\n     * @returns {Transition}\n     * @param {string} transition\n     * @returns {Transition}\n     */\n    static fromString(transition) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(transition, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transition_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transition.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Create a transition from a Uint8Array of left endian bytes.\n     *\n     * @param {Uint8Array} Uint8Array of left endian bytes encoding a Transition.\n     * @returns {Transition}\n     * @param {Uint8Array} bytes\n     * @returns {Transition}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transition.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the transition as a string. If you want to submit this transition to the Aleo Network\n     * this function will create the string that should be submitted in the `POST` data.\n     *\n     * @returns {string} String representation of the transition\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the transition as a Uint8Array of left endian bytes.\n     *\n     * @returns {Uint8Array} Uint8Array representation of the transition\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the program ID of the transition.\n     * @returns {string}\n     */\n    programId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_programId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the function name of the transition.\n     * @returns {string}\n     */\n    functionName() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_functionName(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns true if the transition contains the given commitment.\n     *\n     * @param {boolean} True if the transition contains the given commitment.\n     * @param {Field} commitment\n     * @returns {boolean}\n     */\n    containsCommitment(commitment) {\n        _assertClass(commitment, Field);\n        const ret = wasm.transition_containsCommitment(this.__wbg_ptr, commitment.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Check if the transition contains a serial number.\n     *\n     * @param {Field} serial_number The serial number to check for\n     *\n     * @returns {bool} True if the transition contains a serial number, false otherwise\n     * @param {Field} serial_number\n     * @returns {boolean}\n     */\n    containsSerialNumber(serial_number) {\n        _assertClass(serial_number, Field);\n        const ret = wasm.transition_containsSerialNumber(this.__wbg_ptr, serial_number.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Find a record in the transition by the record's commitment.\n     * @param {Field} commitment\n     * @returns {RecordCiphertext | undefined}\n     */\n    findRecord(commitment) {\n        _assertClass(commitment, Field);\n        const ret = wasm.transition_findRecord(this.__wbg_ptr, commitment.__wbg_ptr);\n        return ret === 0 ? undefined : RecordCiphertext.__wrap(ret);\n    }\n    /**\n     * Get the record plaintext present in a transition owned by a specific view key.\n     *\n     * @param {ViewKey} view_key The view key of the record owner.\n     *\n     * @returns {Array<RecordPlaintext>} Array of record plaintext objects\n     * @param {ViewKey} view_key\n     * @returns {Array<any>}\n     */\n    ownedRecords(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.transition_ownedRecords(this.__wbg_ptr, view_key.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the records present in a transition and their commitments.\n     *\n     * @returns {Array<{commitment: Field, record: RecordCiphertext}>} Array of record ciphertext objects\n     * @returns {Array<any>}\n     */\n    records() {\n        const ret = wasm.transition_records(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the inputs of the transition.\n     *\n     * @param {bool} convert_to_js If true the inputs will be converted to JS objects, if false\n     * the inputs will be in wasm format.\n     *\n     * @returns {Array} Array of inputs\n     * @param {boolean} convert_to_js\n     * @returns {Array<any>}\n     */\n    inputs(convert_to_js) {\n        const ret = wasm.transition_inputs(this.__wbg_ptr, convert_to_js);\n        return takeObject(ret);\n    }\n    /**\n     * Get the outputs of the transition.\n     *\n     * @param {bool} convert_to_js If true the outputs will be converted to JS objects, if false\n     * the outputs will be in wasm format.\n     *\n     * @returns {Array} Array of outputs\n     * @param {boolean} convert_to_js\n     * @returns {Array<any>}\n     */\n    outputs(convert_to_js) {\n        const ret = wasm.transition_outputs(this.__wbg_ptr, convert_to_js);\n        return takeObject(ret);\n    }\n    /**\n     * Get the transition public key of the transition.\n     * @returns {Group}\n     */\n    tpk() {\n        const ret = wasm.address_toGroup(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Get the transition view key of the transition.\n     * @param {ViewKey} view_key\n     * @returns {Field}\n     */\n    tvk(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.transition_tvk(this.__wbg_ptr, view_key.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Get the transition commitment of the transition.\n     * @returns {Field}\n     */\n    tcm() {\n        const ret = wasm.transition_tcm(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Get the transition signer commitment of the transition.\n     * @returns {Field}\n     */\n    scm() {\n        const ret = wasm.transition_scm(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n}\n\nconst VerifyingKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_verifyingkey_free(ptr >>> 0, 1));\n/**\n * Verifying key for a function within an Aleo program\n */\nclass VerifyingKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VerifyingKey.prototype);\n        obj.__wbg_ptr = ptr;\n        VerifyingKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        VerifyingKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_verifyingkey_free(ptr, 0);\n    }\n    /**\n     * Returns the verifying key for the bond_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the bond_public function\n     * @returns {VerifyingKey}\n     */\n    static bondPublicVerifier() {\n        const ret = wasm.verifyingkey_bondPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the bond_validator function\n     *\n     * @returns {VerifyingKey} Verifying key for the bond_validator function\n     * @returns {VerifyingKey}\n     */\n    static bondValidatorVerifier() {\n        const ret = wasm.verifyingkey_bondValidatorVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the claim_delegator function\n     *\n     * @returns {VerifyingKey} Verifying key for the claim_unbond_public function\n     * @returns {VerifyingKey}\n     */\n    static claimUnbondPublicVerifier() {\n        const ret = wasm.verifyingkey_claimUnbondPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the fee_private function\n     *\n     * @returns {VerifyingKey} Verifying key for the fee_private function\n     * @returns {VerifyingKey}\n     */\n    static feePrivateVerifier() {\n        const ret = wasm.verifyingkey_feePrivateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the fee_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the fee_public function\n     * @returns {VerifyingKey}\n     */\n    static feePublicVerifier() {\n        const ret = wasm.verifyingkey_feePublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the inclusion function\n     *\n     * @returns {VerifyingKey} Verifying key for the inclusion function\n     * @returns {VerifyingKey}\n     */\n    static inclusionVerifier() {\n        const ret = wasm.verifyingkey_inclusionVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the join function\n     *\n     * @returns {VerifyingKey} Verifying key for the join function\n     * @returns {VerifyingKey}\n     */\n    static joinVerifier() {\n        const ret = wasm.verifyingkey_joinVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the set_validator_state function\n     *\n     * @returns {VerifyingKey} Verifying key for the set_validator_state function\n     * @returns {VerifyingKey}\n     */\n    static setValidatorStateVerifier() {\n        const ret = wasm.verifyingkey_setValidatorStateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the split function\n     *\n     * @returns {VerifyingKey} Verifying key for the split function\n     * @returns {VerifyingKey}\n     */\n    static splitVerifier() {\n        const ret = wasm.verifyingkey_splitVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the transfer_private function\n     *\n     * @returns {VerifyingKey} Verifying key for the transfer_private function\n     * @returns {VerifyingKey}\n     */\n    static transferPrivateVerifier() {\n        const ret = wasm.verifyingkey_transferPrivateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the transfer_private_to_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the transfer_private_to_public function\n     * @returns {VerifyingKey}\n     */\n    static transferPrivateToPublicVerifier() {\n        const ret = wasm.verifyingkey_transferPrivateToPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the transfer_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the transfer_public function\n     * @returns {VerifyingKey}\n     */\n    static transferPublicVerifier() {\n        const ret = wasm.verifyingkey_transferPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the transfer_public_as_signer function\n     *\n     * @returns {VerifyingKey} Verifying key for the transfer_public_as_signer function\n     * @returns {VerifyingKey}\n     */\n    static transferPublicAsSignerVerifier() {\n        const ret = wasm.verifyingkey_transferPublicAsSignerVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the transfer_public_to_private function\n     *\n     * @returns {VerifyingKey} Verifying key for the transfer_public_to_private function\n     * @returns {VerifyingKey}\n     */\n    static transferPublicToPrivateVerifier() {\n        const ret = wasm.verifyingkey_transferPublicToPrivateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the unbond_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the unbond_public function\n     * @returns {VerifyingKey}\n     */\n    static unbondPublicVerifier() {\n        const ret = wasm.verifyingkey_unbondPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the bond_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the bond_public function\n     * @returns {boolean}\n     */\n    isBondPublicVerifier() {\n        const ret = wasm.verifyingkey_isBondPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Returns the verifying key for the bond_validator function\n     *\n     * @returns {VerifyingKey} Verifying key for the bond_validator function\n     * @returns {boolean}\n     */\n    isBondValidatorVerifier() {\n        const ret = wasm.verifyingkey_isBondValidatorVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the claim_delegator function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isClaimUnbondPublicVerifier() {\n        const ret = wasm.verifyingkey_isClaimUnbondPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the fee_private function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isFeePrivateVerifier() {\n        const ret = wasm.verifyingkey_isFeePrivateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the fee_public function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isFeePublicVerifier() {\n        const ret = wasm.verifyingkey_isFeePublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the inclusion function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isInclusionVerifier() {\n        const ret = wasm.verifyingkey_isInclusionVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the join function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isJoinVerifier() {\n        const ret = wasm.verifyingkey_isJoinVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the set_validator_state function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isSetValidatorStateVerifier() {\n        const ret = wasm.verifyingkey_isSetValidatorStateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the split function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isSplitVerifier() {\n        const ret = wasm.verifyingkey_isSplitVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the transfer_private function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isTransferPrivateVerifier() {\n        const ret = wasm.verifyingkey_isTransferPrivateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the transfer_private_to_public function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isTransferPrivateToPublicVerifier() {\n        const ret = wasm.verifyingkey_isTransferPrivateToPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the transfer_public function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isTransferPublicVerifier() {\n        const ret = wasm.verifyingkey_isTransferPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the transfer_public_as_signer function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isTransferPublicAsSignerVerifier() {\n        const ret = wasm.verifyingkey_isTransferPublicAsSignerVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the transfer_public_to_private function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isTransferPublicToPrivateVerifier() {\n        const ret = wasm.verifyingkey_isTransferPublicToPrivateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the unbond_public function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isUnbondPublicVerifier() {\n        const ret = wasm.verifyingkey_isUnbondPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get the checksum of the verifying key\n     *\n     * @returns {string} Checksum of the verifying key\n     * @returns {string}\n     */\n    checksum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.verifyingkey_checksum(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a copy of the verifying key\n     *\n     * @returns {VerifyingKey} A copy of the verifying key\n     * @returns {VerifyingKey}\n     */\n    copy() {\n        const ret = wasm.verifyingkey_copy(this.__wbg_ptr);\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Construct a new verifying key from a byte array\n     *\n     * @param {Uint8Array} bytes Byte representation of a verifying key\n     * @returns {VerifyingKey}\n     * @param {Uint8Array} bytes\n     * @returns {VerifyingKey}\n     */\n    static fromBytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export_3);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.verifyingkey_fromBytes(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VerifyingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Create a verifying key from string\n     *\n     * @param {String} string String representation of a verifying key\n     * @returns {VerifyingKey}\n     * @param {string} string\n     * @returns {VerifyingKey}\n     */\n    static fromString(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(string, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.verifyingkey_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VerifyingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Create a byte array from a verifying key\n     *\n     * @returns {Uint8Array} Byte representation of a verifying key\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.verifyingkey_toBytes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_2(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a string representation of the verifying key\n     *\n     * @returns {String} String representation of the verifying key\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.verifyingkey_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst ViewKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_viewkey_free(ptr >>> 0, 1));\n\nclass ViewKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ViewKey.prototype);\n        obj.__wbg_ptr = ptr;\n        ViewKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ViewKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_viewkey_free(ptr, 0);\n    }\n    /**\n     * Create a new view key from a private key\n     *\n     * @param {PrivateKey} private_key Private key\n     * @returns {ViewKey} View key\n     * @param {PrivateKey} private_key\n     * @returns {ViewKey}\n     */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.privatekey_to_view_key(private_key.__wbg_ptr);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n     * Create a new view key from a string representation of a view key\n     *\n     * @param {string} view_key String representation of a view key\n     * @returns {ViewKey} View key\n     * @param {string} view_key\n     * @returns {ViewKey}\n     */\n    static from_string(view_key) {\n        const ptr0 = passStringToWasm0(view_key, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.viewkey_from_string(ptr0, len0);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n     * Get a string representation of a view key\n     *\n     * @returns {string} String representation of a view key\n     * @returns {string}\n     */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.viewkey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the address corresponding to a view key\n     *\n     * @returns {Address} Address\n     * @returns {Address}\n     */\n    to_address() {\n        const ret = wasm.address_from_view_key(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Get the underlying scalar of a view key.\n     * @returns {Scalar}\n     */\n    to_scalar() {\n        const ret = wasm.field_clone(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Decrypt a record ciphertext with a view key\n     *\n     * @param {string} ciphertext String representation of a record ciphertext\n     * @returns {string} String representation of a record plaintext\n     * @param {string} ciphertext\n     * @returns {string}\n     */\n    decrypt(ciphertext) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.viewkey_decrypt(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred3_0, deferred3_1, 1);\n        }\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_abort_775ef1d17fc65868 = function(arg0) {\n        getObject(arg0).abort();\n    };\n    imports.wbg.__wbg_address_new = function(arg0) {\n        const ret = Address.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_append_8c7dd8d641a5f01b = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_arrayBuffer_d1b44c4390db422f = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).arrayBuffer();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_async_9ff6d9e405f13772 = function(arg0) {\n        const ret = getObject(arg0).async;\n        return ret;\n    };\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_672a4d21634d4a24 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_ciphertext_new = function(arg0) {\n        const ret = Ciphertext.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_crypto_ed58b8e10a292839 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_data_432d9c3df2630942 = function(arg0) {\n        const ret = getObject(arg0).data;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_done_769e5ede4b31c67b = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_export_2(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_executionresponse_new = function(arg0) {\n        const ret = ExecutionResponse.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetch_509096533071c657 = function(arg0, arg1) {\n        const ret = getObject(arg0).fetch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetch_f1856afdb49415d1 = function(arg0) {\n        const ret = fetch(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_field_new = function(arg0) {\n        const ret = Field.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_field_unwrap = function(arg0) {\n        const ret = Field.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_get_67b2ba62fc30de12 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_group_new = function(arg0) {\n        const ret = Group.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_has_a5ea9117f258a0ec = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.has(getObject(arg0), getObject(arg1));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_headers_9cb51cfd2ac780a4 = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_Response_f2cc20d9f7dfd644 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Response;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_9a24c88df860dc65 = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_keypair_new = function(arg0) {\n        const ret = KeyPair.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_log_4a8c9f48971e8bbe = function(arg0, arg1) {\n        console.log(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_018dcc2d6c8c2f6a = function() { return handleError(function () {\n        const ret = new Headers();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_23a2665fac83c611 = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wbg_adapter_524(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            const ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbg_new_405e22f390576ce2 = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_78feb108b6472713 = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_86231e225ca6b962 = function() { return handleError(function () {\n        const ret = new XMLHttpRequest();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_b1a33e5095abf678 = function() { return handleError(function (arg0, arg1) {\n        const ret = new Worker(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_e25e5aab09ff45db = function() { return handleError(function () {\n        const ret = new AbortController();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_e9a4a67dbababe57 = function(arg0) {\n        const ret = new Int32Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_c4c419ef0bc8a1f8 = function(arg0) {\n        const ret = new Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithstrandinit_06c535e0a867c635 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_25feadfc0913fea9 = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_next_6574e1a8a62d1055 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_node_02999533c4ea02e3 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_of_4a05197bfc89556f = function(arg0, arg1, arg2) {\n        const ret = Array.of(getObject(arg0), getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_open_13a598ea50d82926 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5) {\n        getObject(arg0).open(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4), arg5 !== 0);\n    }, arguments) };\n    imports.wbg.__wbg_overrideMimeType_36ce5eeae20aff9f = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).overrideMimeType(getStringFromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_plaintext_new = function(arg0) {\n        const ret = Plaintext.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_postMessage_6edafa8f7b9c2f52 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).postMessage(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_process_5c1d670bc53614b8 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {\n        const ret = getObject(arg0).push(getObject(arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_queueMicrotask_97d92b4fcc8a61c5 = function(arg0) {\n        queueMicrotask(getObject(arg0));\n    };\n    imports.wbg.__wbg_queueMicrotask_d3219def82552485 = function(arg0) {\n        const ret = getObject(arg0).queueMicrotask;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).randomFillSync(takeObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_recordciphertext_new = function(arg0) {\n        const ret = RecordCiphertext.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_recordplaintext_new = function(arg0) {\n        const ret = RecordPlaintext.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_79b1e9274cde3c87 = function() { return handleError(function () {\n        const ret = module.require;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_resolve_4851785c9c5f573d = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_responseText_ad050aa7f8afec9f = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg1).responseText;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    }, arguments) };\n    imports.wbg.__wbg_response_49e10f8ee7f418db = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).response;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_send_40a47636ff90f64d = function() { return handleError(function (arg0) {\n        getObject(arg0).send();\n    }, arguments) };\n    imports.wbg.__wbg_set_37837023f3d740e8 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_bb8cecf6a62b9f46 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_setbody_5923b78a95eedf29 = function(arg0, arg1) {\n        getObject(arg0).body = getObject(arg1);\n    };\n    imports.wbg.__wbg_setcredentials_c3a22f1cd105a2c6 = function(arg0, arg1) {\n        getObject(arg0).credentials = __wbindgen_enum_RequestCredentials[arg1];\n    };\n    imports.wbg.__wbg_setheaders_834c0bdb6a8949ad = function(arg0, arg1) {\n        getObject(arg0).headers = getObject(arg1);\n    };\n    imports.wbg.__wbg_setmethod_3c5280fe5d890842 = function(arg0, arg1, arg2) {\n        getObject(arg0).method = getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_setmode_5dc300b865044b65 = function(arg0, arg1) {\n        getObject(arg0).mode = __wbindgen_enum_RequestMode[arg1];\n    };\n    imports.wbg.__wbg_setonmessage_5a885b16bdc6dca6 = function(arg0, arg1) {\n        getObject(arg0).onmessage = getObject(arg1);\n    };\n    imports.wbg.__wbg_setsignal_75b21ef3a81de905 = function(arg0, arg1) {\n        getObject(arg0).signal = getObject(arg1);\n    };\n    imports.wbg.__wbg_signal_aaf9ad74119f20a4 = function(arg0) {\n        const ret = getObject(arg0).signal;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_signature_new = function(arg0) {\n        const ret = Signature.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_spawnWorker_ea0d99567d890697 = function(arg0, arg1, arg2, arg3) {\n        const ret = spawnWorker(getObject(arg0), getObject(arg1), getObject(arg2), arg3 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {\n        const ret = typeof global === 'undefined' ? null : global;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {\n        const ret = typeof globalThis === 'undefined' ? null : globalThis;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {\n        const ret = typeof self === 'undefined' ? null : self;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {\n        const ret = typeof window === 'undefined' ? null : window;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_status_12bcf88a8ff51470 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_status_f6360336ca686bf0 = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_stringify_f7ed6987935b4a24 = function() { return handleError(function (arg0) {\n        const ret = JSON.stringify(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_44b73946d2fb3e7d = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_48b406749878a531 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transaction_new = function(arg0) {\n        const ret = Transaction.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transition_new = function(arg0) {\n        const ret = Transition.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_url_ae10c34ca209681d = function(arg0, arg1) {\n        const ret = getObject(arg1).url;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_value_dab73d3d5d4abaaf = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_verifyingkey_new = function(arg0) {\n        const ret = VerifyingKey.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_c71aa1626a93e0a1 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_waitAsync_61f0a081053dd3c2 = function(arg0, arg1, arg2) {\n        const ret = Atomics.waitAsync(getObject(arg0), arg1 >>> 0, arg2);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_waitAsync_7ce6c8a047c752c3 = function() {\n        const ret = Atomics.waitAsync;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_i128 = function(arg0, arg1) {\n        const ret = arg0 << BigInt(64) | BigInt.asUintN(64, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_u128 = function(arg0, arg1) {\n        const ret = BigInt.asUintN(64, arg0) << BigInt(64) | BigInt.asUintN(64, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbindgen_closure_wrapper6080 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 519, __wbg_adapter_40);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6086 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 519, __wbg_adapter_40);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_link_9579f016b4522a24 = function(arg0) {\n        const val = `onmessage = function (ev) {\n            let [ia, index, value] = ev.data;\n            ia = new Int32Array(ia.buffer);\n            let result = Atomics.wait(ia, index, value);\n            postMessage(result);\n        };\n        `;\n        const ret = typeof URL.createObjectURL === 'undefined' ? \"data:application/javascript,\" + encodeURIComponent(val) : URL.createObjectURL(new Blob([val], { type: \"text/javascript\" }));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_module = function() {\n        const ret = __wbg_init.__wbindgen_wasm_module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_rethrow = function(arg0) {\n        throw takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n    imports.wbg.memory = memory || new WebAssembly.Memory({initial:22,maximum:65536,shared:true});\n}\n\nfunction __wbg_finalize_init(instance, module, thread_stack_size) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n    if (typeof thread_stack_size !== 'undefined' && (typeof thread_stack_size !== 'number' || thread_stack_size === 0 || thread_stack_size % 65536 !== 0)) { throw 'invalid stack size' }\n    wasm.__wbindgen_start(thread_stack_size);\n    return wasm;\n}\n\nfunction initSync(module, memory) {\n    if (wasm !== undefined) return wasm;\n\n    let thread_stack_size;\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module, memory, thread_stack_size} = module);\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead');\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports, memory);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module, thread_stack_size);\n}\n\nasync function __wbg_init(module_or_path, memory) {\n    if (wasm !== undefined) return wasm;\n\n    let thread_stack_size;\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path, memory, thread_stack_size} = module_or_path);\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead');\n        }\n    }\n\n\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports, memory);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module, thread_stack_size);\n}\n\nvar exports = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Address: Address,\n    BHP1024: BHP1024,\n    BHP256: BHP256,\n    BHP512: BHP512,\n    BHP768: BHP768,\n    Ciphertext: Ciphertext,\n    ComputeKey: ComputeKey,\n    Execution: Execution,\n    ExecutionResponse: ExecutionResponse,\n    Field: Field,\n    GraphKey: GraphKey,\n    Group: Group,\n    KeyPair: KeyPair,\n    Metadata: Metadata,\n    OfflineQuery: OfflineQuery,\n    Pedersen128: Pedersen128,\n    Pedersen64: Pedersen64,\n    Plaintext: Plaintext,\n    Poseidon2: Poseidon2,\n    Poseidon4: Poseidon4,\n    Poseidon8: Poseidon8,\n    PrivateKey: PrivateKey,\n    PrivateKeyCiphertext: PrivateKeyCiphertext,\n    Program: Program,\n    ProgramManager: ProgramManager,\n    ProvingKey: ProvingKey,\n    RecordCiphertext: RecordCiphertext,\n    RecordPlaintext: RecordPlaintext,\n    Scalar: Scalar,\n    Signature: Signature,\n    Transaction: Transaction,\n    Transition: Transition,\n    VerifyingKey: VerifyingKey,\n    ViewKey: ViewKey,\n    default: __wbg_init,\n    initSync: initSync,\n    initThreadPool: initThreadPool,\n    runRayonThread: runRayonThread,\n    verifyFunctionExecution: verifyFunctionExecution\n});\n\nexport { Address as A, BHP1024 as B, Ciphertext as C, Execution as E, Field as F, GraphKey as G, KeyPair as K, Metadata as M, OfflineQuery as O, Pedersen128 as P, RecordCiphertext as R, Scalar as S, Transaction as T, VerifyingKey as V, __wbg_init as _, BHP256 as a, BHP512 as b, BHP768 as c, ComputeKey as d, ExecutionResponse as e, Group as f, Pedersen64 as g, Plaintext as h, initThreadPool as i, Poseidon2 as j, Poseidon4 as k, Poseidon8 as l, PrivateKey as m, PrivateKeyCiphertext as n, Program as o, ProgramManager as p, ProvingKey as q, runRayonThread as r, RecordPlaintext as s, Signature as t, Transition as u, verifyFunctionExecution as v, ViewKey as w, initSync as x, exports as y };\n//# sourceMappingURL=index.js.map\n","import { _ as __wbg_init } from './index.js';\nexport { A as Address, B as BHP1024, a as BHP256, b as BHP512, c as BHP768, C as Ciphertext, d as ComputeKey, E as Execution, e as ExecutionResponse, F as Field, G as GraphKey, f as Group, K as KeyPair, M as Metadata, O as OfflineQuery, P as Pedersen128, g as Pedersen64, h as Plaintext, j as Poseidon2, k as Poseidon4, l as Poseidon8, m as PrivateKey, n as PrivateKeyCiphertext, o as Program, p as ProgramManager, q as ProvingKey, R as RecordCiphertext, s as RecordPlaintext, S as Scalar, t as Signature, T as Transaction, u as Transition, V as VerifyingKey, w as ViewKey, x as initSync, i as initThreadPool, r as runRayonThread, v as verifyFunctionExecution } from './index.js';\n\nconst module = new URL(\"aleo_wasm.wasm\", import.meta.url);\n                \n                    await __wbg_init({ module_or_path: module });\n//# sourceMappingURL=aleo_wasm.js.map\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously \\_()_/\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnt happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n"],"names":["Account","_privateKey","_viewKey","_computeKey","_address","constructor","params","this","privateKeyFromParams","e","console","error","Error","ViewKey","from_private_key","ComputeKey","Address","fromCiphertext","ciphertext","password","PrivateKeyCiphertext","fromString","PrivateKey","fromPrivateKeyCiphertext","privateKey","to_string","seed","from_seed_unchecked","from_string","viewKey","computeKey","address","clone","toString","encryptAccount","toCiphertext","decryptRecord","decrypt","decryptRecords","ciphertexts","map","ownsRecordCiphertext","isOwner","RecordCiphertext","sign","message","verify","signature","NetworkRecordProvider","account","networkClient","setAccount","findCreditsRecords","microcredits","unspent","nonces","searchParameters","maxAmount","startHeight","endHeight","Array","isArray","every","item","getLatestHeight","logAndThrow","findRecords","findCreditsRecord","records","log","length","findRecord","amounts","programs","parseJSON","json","JSON","parse","key","value","context","Number","isInteger","BigInt","source","async","get","url","options","response","fetch","ok","status","post","method","AleoNetworkClient","host","headers","getAccount","setHost","fetchData","fetchRaw","text","maxMicrocredits","start","end","resolvedPrivateKey","latestHeight","failures","totalRecordValue","to_view_key","blockHeight","blocks","getBlockRange","i","transactions","j","confirmedTransaction","type","transaction","execution","transitions","k","transition","includes","program","outputs","l","output","record","recordPlaintext","nonce","serialNumber","serialNumberString","getTransitionId","push","amounts_found","warn","findUnspentRecords","getBlock","getBlockByHash","blockHash","getDeploymentTransactionIDForProgram","Program","id","replace","getDeploymentTransactionForProgram","transaction_id","getTransaction","getDeploymentTransactionObjectForProgram","getTransactionObject","getLatestBlock","getLatestCommittee","getCommitteeByBlockHeight","getLatestBlockHash","String","getProgram","programId","getProgramObject","inputProgram","getProgramImports","imports","importList","getImports","import_id","hasOwnProperty","programSource","nestedImports","getProgramImportNames","getProgramMappingNames","getProgramMappingValue","mappingName","keyString","Plaintext","getProgramMappingPlaintext","getPublicBalance","addressString","balanceStr","parseInt","getStateRoot","transactionId","getConfirmedTransaction","Transaction","getTransactions","getTransactionsByBlockHash","height","header","metadata","getTransactionsInMempool","inputOrOutputID","submitTransaction","transaction_string","body","Object","assign","submitSolution","solution","waitForTransactionConfirmation","checkInterval","timeout","startTime","Date","now","Promise","resolve","reject","interval","setInterval","clearInterval","KEY_STORE","Metadata","baseUrl","convert","verifyingKey","VerifyingKey","name","locator","prover","verifier","CREDITS_PROGRAM_KEYS","bond_public","bond_validator","claim_unbond_public","fee_private","fee_public","inclusion","join","set_validator_state","split","transfer_private","transfer_private_to_public","transfer_public","transfer_public_as_signer","transfer_public_to_private","unbond_public","getKey","PRIVATE_TRANSFER_TYPES","Set","VALID_TRANSFER_TYPES","PRIVATE_TRANSFER","PRIVATE_TO_PUBLIC_TRANSFER","PUBLIC_TRANSFER","PUBLIC_TRANSFER_AS_SIGNER","PUBLIC_TO_PRIVATE_TRANSFER","AleoKeyProviderParams","proverUri","verifierUri","cacheKey","AleoKeyProvider","cache","cacheOption","keyUris","fetchBytes","data","arrayBuffer","Uint8Array","Map","useCache","clearCache","clear","cacheKeys","keyId","keys","provingKey","set","toBytes","containsKeys","has","deleteKeys","delete","getKeys","debug","provingKeyBytes","verifyingKeyBytes","ProvingKey","fromBytes","functionKeys","proverUrl","verifierUrl","fetchCreditsKeys","fetchRemoteKeys","getVerifyingKey","fetchProvingKey","keyPair","verifying_key","proving_key","bondPublicKeys","bondValidatorKeys","claimUnbondPublicKeys","transferKeys","visibility","joinKeys","splitKeys","feePrivateKeys","feePublicKeys","inner","unBondPublicKeys","ProgramManager","keyProvider","recordProvider","checkFee","feeAmount","balance","setKeyProvider","setRecordProvider","buildDeploymentTransaction","priorityFee","privateFee","recordSearchParams","feeRecord","programObject","feeKeys","deploymentPrivateKey","getCreditsRecord","undefined","feeProvingKey","feeVerifyingKey","ProgramManager$1","deploy","tx","feeAddress","buildExecutionTransaction","programName","functionName","inputs","keySearchParams","offlineQuery","executionPrivateKey","execute","run","function_name","proveExecution","executeFunctionOffline","recordOne","recordTwo","joinProvingKey","joinVerifyingKey","RecordPlaintext","buildJoinTransaction","splitAmount","amountRecord","splitProvingKey","splitVerifyingKey","buildSplitTransaction","synthesizeKeys","function_id","synthesizeKeyPair","buildTransferTransaction","amount","recipient","transferType","validateTransferType","transferProvingKey","transferVerifyingKey","requiresAmountRecord","buildTransferPublicTransaction","buildTransferPublicAsSignerTransaction","transfer","buildBondPublicTransaction","validator_address","withdrawal_address","scaledAmount","Math","trunc","creditsProgram","additionalOptions","executeOptions","bondPublic","buildBondValidatorTransaction","commission","adjustedCommission","bondValidator","buildUnbondPublicTransaction","staker_address","unbondPublic","buildClaimUnbondPublicTransaction","claimUnbondPublic","buildSetValidatorStateTransaction","validator_state","setValidatorState","verifyExecution","executionResponse","getExecution","getFunctionId","verifyFunctionExecution","createProgramFromSource","getCreditsProgram","verifyProgram","spawnWorker","module","memory","worker","Worker","addEventListener","event","setTimeout","unref","capture","once","postMessage","wasm","heap","fill","getObject","idx","heap_next","addHeapObject","obj","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","decode","cachedUint8ArrayMemory0","getUint8ArrayMemory0","buffer","getStringFromWasm0","ptr","len","slice","handleError","f","args","apply","__wbindgen_export_1","dropObject","takeObject","ret","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encode","encodeString","arg","view","buf","read","written","passStringToWasm0","malloc","realloc","subarray","mem","offset","code","charCodeAt","isLikeNone","x","cachedDataViewMemory0","getDataViewMemory0","DataView","CLOSURE_DTORS","FinalizationRegistry","register","unregister","state","__wbindgen_export_5","dtor","a","b","makeMutClosure","arg0","arg1","cnt","real","original","_assertClass","instance","klass","passArray8ToWasm0","retptr","__wbindgen_add_to_stack_pointer","Execution","ptr0","__wbindgen_export_3","__wbindgen_export_4","len0","__wbg_ptr","r0","getInt32","r1","getArrayU8FromWasm0","stack_pointer","addBorrowedObject","__wbg_adapter_40","arg2","__wbindgen_export_6","__wbg_adapter_524","arg3","__wbindgen_export_7","__wbindgen_enum_RequestCredentials","__wbindgen_enum_RequestMode","AddressFinalization","__wbg_address_free","__wrap","create","prototype","__destroy_into_raw","free","private_key","address_from_private_key","from_view_key","view_key","address_from_view_key","from_compute_key","compute_key","address_from_compute_key","fromBytesLe","bytes","address_fromBytesLe","toBytesLe","address_toBytesLe","fromBitsLe","bits","address_fromBitsLe","toBitsLe","address_toBitsLe","fromFields","fields","address_fromFields","toFields","address_toFields","fromGroup","group","Group","address_fromGroup","toGroup","address_toGroup","address_from_string","deferred1_0","deferred1_1","address_to_string","__wbindgen_export_2","toPlaintext","address_toPlaintext","Signature","address_verify","__wbg_bhp1024_free","__wbg_bhp256_free","__wbg_bhp512_free","__wbg_bhp768_free","CiphertextFinalization","__wbg_ciphertext_free","Ciphertext","ptr1","ciphertext_decrypt","decryptWithTransitionInfo","transition_public_key","index","ptr2","len2","ptr3","len3","ciphertext_decryptWithTransitionInfo","decryptWithTransitionViewKey","transition_view_key","Field","len1","ciphertext_decryptWithTransitionViewKey","decryptSymmetric","ciphertext_decryptSymmetric","ciphertext_fromBytesLe","ciphertext_toBytes","ciphertext_fromBitsLe","ciphertext_toBitsLe","ciphertext_fromFields","ciphertext_toFields","ciphertext_fromString","ciphertext_toString","ComputeKeyFinalization","__wbg_computekey_free","computekey_from_private_key","sk_prf","computekey_sk_prf","Scalar","pk_sig","pr_sig","computekey_pr_sig","ExecutionFinalization","__wbg_execution_free","execution_toString","execution_fromString","globalStateRoot","execution_globalStateRoot","proof","execution_proof","execution_transitions","ExecutionResponseFinalization","__wbg_executionresponse_free","ExecutionResponse","getOutputs","executionresponse_getOutputs","executionresponse_getExecution","executionresponse_getKeys","KeyPair","getProvingKey","executionresponse_getProvingKey","executionresponse_getVerifyingKey","executionresponse_getFunctionId","executionresponse_getProgram","FieldFinalization","__wbg_field_free","__unwrap","jsValue","field","field_fromString","field_toString","field_fromBytesLe","field_toBytesLe","field_fromBitsLe","field_toBitsLe","field_toPlaintext","field_clone","random","field_random","add","other","field_add","subtract","field_subtract","multiply","field_multiply","divide","field_divide","pow","field_pow","inverse","field_inverse","zero","field_zero","one","field_one","double","field_double","equals","field_equals","GraphKeyFinalization","__wbg_graphkey_free","GraphKey","graphkey_from_view_key","graph_key","graphkey_from_string","graphkey_to_string","sk_tag","GroupFinalization","__wbg_group_free","group_fromString","group_toString","group_fromBytesLe","group_toBytesLe","group_fromBitsLe","group_toFields","toXCoordinate","group_toXCoordinate","group_toPlaintext","group_clone","group_random","group_add","group_subtract","scalarMultiply","scalar","group_scalarMultiply","group_double","group_inverse","group_equals","group_zero","generator","group_generator","KeyPairFinalization","__wbg_keypair_free","keypair_new","keypair_provingKey","keypair_verifyingKey","MetadataFinalization","__wbg_metadata_free","__wbg_get_metadata_name","__wbg_set_metadata_name","__wbg_get_metadata_locator","__wbg_set_metadata_locator","__wbg_get_metadata_prover","__wbg_set_metadata_prover","__wbg_get_metadata_verifier","__wbg_set_metadata_verifier","__wbg_get_metadata_verifyingKey","__wbg_set_metadata_verifyingKey","metadata_baseUrl","metadata_bond_public","metadata_bond_validator","metadata_claim_unbond_public","metadata_fee_private","metadata_fee_public","metadata_inclusion","metadata_join","metadata_set_validator_state","metadata_split","metadata_transfer_private","metadata_transfer_private_to_public","metadata_transfer_public","metadata_transfer_public_as_signer","metadata_transfer_public_to_private","metadata_unbond_public","OfflineQueryFinalization","__wbg_offlinequery_free","OfflineQuery","block_height","state_root","offlinequery_new","addBlockHeight","offlinequery_addBlockHeight","addStatePath","commitment","state_path","offlinequery_addStatePath","offlinequery_toString","s","offlinequery_fromString","__wbg_pedersen128_free","__wbg_pedersen64_free","PlaintextFinalization","__wbg_plaintext_free","find","plaintext_find","encrypt","randomizer","plaintext_encrypt","encryptSymmetric","plaintext_encryptSymmetric","plaintext","plaintext_fromString","plaintext_fromBytesLe","plaintext_toBytesLe","plaintext_fromBitsLe","plaintext_toBitsLe","plaintext_fromFields","plaintext_toFields","plaintext_toString","plaintextType","plaintext_plaintextType","toObject","plaintext_toObject","__wbg_poseidon2_free","__wbg_poseidon4_free","__wbg_poseidon8_free","PrivateKeyFinalization","__wbg_privatekey_free","privatekey_new","privatekey_from_seed_unchecked","privatekey_from_string","privatekey_to_string","privatekey_to_view_key","to_address","privatekey_to_address","privatekey_sign","newEncrypted","secret","privatekey_newEncrypted","privatekey_toCiphertext","privatekey_fromPrivateKeyCiphertext","PrivateKeyCiphertextFinalization","__wbg_privatekeyciphertext_free","encryptPrivateKey","decryptToPrivateKey","privatekeyciphertext_decryptToPrivateKey","privatekeyciphertext_fromString","ProgramFinalization","__wbg_program_free","program_fromString","program_toString","hasFunction","program_hasFunction","getFunctions","program_getFunctions","getFunctionInputs","program_getFunctionInputs","getMappings","program_getMappings","getRecordMembers","record_name","program_getRecordMembers","getStructMembers","struct_name","program_getStructMembers","program_getCreditsProgram","program_id","program_address","isEqual","program_isEqual","program_getImports","ProgramManagerFinalization","__wbg_programmanager_free","priority_fee_credits","fee_record","fee_proving_key","fee_verifying_key","offline_query","ptr4","ptr5","programmanager_buildDeploymentTransaction","estimateDeploymentFee","programmanager_estimateDeploymentFee","estimateProgramNameCost","programmanager_estimateProgramNameCost","getBigInt64","r2","asUintN","_function","prove_execution","len4","programmanager_executeFunctionOffline","ptr6","ptr7","ptr8","programmanager_buildExecutionTransaction","estimateExecutionFee","programmanager_estimateExecutionFee","estimateFinalizeFee","programmanager_estimateFinalizeFee","record_1","record_2","join_proving_key","join_verifying_key","programmanager_buildJoinTransaction","split_amount","amount_record","split_proving_key","split_verifying_key","programmanager_buildSplitTransaction","amount_credits","transfer_type","transfer_proving_key","transfer_verifying_key","ptr9","programmanager_buildTransferTransaction","programmanager_synthesizeKeyPair","ProvingKeyFinalization","__wbg_provingkey_free","isBondPublicProver","provingkey_isBondPublicProver","isBondValidatorProver","provingkey_isBondValidatorProver","isClaimUnbondPublicProver","provingkey_isClaimUnbondPublicProver","isFeePrivateProver","provingkey_isFeePrivateProver","isFeePublicProver","provingkey_isFeePublicProver","isInclusionProver","provingkey_isInclusionProver","isJoinProver","provingkey_isJoinProver","isSetValidatorStateProver","provingkey_isSetValidatorStateProver","isSplitProver","provingkey_isSplitProver","isTransferPrivateProver","provingkey_isTransferPrivateProver","isTransferPrivateToPublicProver","provingkey_isTransferPrivateToPublicProver","isTransferPublicProver","provingkey_isTransferPublicProver","isTransferPublicAsSignerProver","provingkey_isTransferPublicAsSignerProver","isTransferPublicToPrivateProver","provingkey_isTransferPublicToPrivateProver","isUnbondPublicProver","provingkey_isUnbondPublicProver","checksum","provingkey_checksum","copy","provingkey_copy","provingkey_fromBytes","string","provingkey_fromString","provingkey_toBytes","v1","provingkey_toString","RecordCiphertextFinalization","__wbg_recordciphertext_free","recordciphertext_fromString","recordciphertext_toString","recordciphertext_decrypt","recordciphertext_isOwner","tag","recordciphertext_tag","recordciphertext_fromBytesLe","recordciphertext_toBytesLe","recordciphertext_toBitsLe","recordciphertext_toFields","RecordPlaintextFinalization","__wbg_recordplaintext_free","recordplaintext_commitment","recordplaintext_fromString","getMember","input","recordplaintext_getMember","owner","recordplaintext_owner","toJsObject","recordplaintext_toJsObject","recordplaintext_toString","recordplaintext_fromBytesLe","recordplaintext_toBytesLe","recordplaintext_toBitsLe","recordplaintext_toFields","recordplaintext_microcredits","recordplaintext_nonce","deferred4_0","deferred4_1","recordplaintext_serialNumberString","r3","recordplaintext_tag","ScalarFinalization","__wbg_scalar_free","scalar_fromString","scalar_toString","scalar_fromBytesLe","scalar_toBytesLe","scalar_fromBitsLe","scalar_toBitsLe","scalar_toPlaintext","scalar_random","scalar_add","scalar_subtract","scalar_multiply","scalar_divide","scalar_double","scalar_pow","scalar_inverse","scalar_one","SignatureFinalization","__wbg_signature_free","signature_to_address","challenge","signature_response","signature_verify","signature_fromBytesLe","signature_toBytesLe","signature_fromBitsLe","signature_toBitsLe","signature_toFields","signature_from_string","signature_to_string","signature_toPlaintext","TransactionFinalization","__wbg_transaction_free","transaction_fromString","transaction_fromBytesLe","transaction_toString","transaction_toBytesLe","constainsSerialNumber","serial_number","transaction_constainsSerialNumber","constainsCommitment","transaction_constainsCommitment","transaction_findRecord","baseFeeAmount","transaction_baseFeeAmount","transaction_feeAmount","priorityFeeAmount","transaction_priorityFeeAmount","isDeploy","transaction_isDeploy","isExecute","transaction_isExecute","isFee","transaction_isFee","deployedProgram","transaction_deployedProgram","transaction_execution","ownedRecords","transaction_ownedRecords","transaction_records","summary","convert_to_js","transaction_summary","transactionType","transaction_transactionType","transaction_transitions","verifyingKeys","transaction_verifyingKeys","TransitionFinalization","__wbg_transition_free","Transition","transition_id","transition_fromString","transition_fromBytesLe","transition_toString","transition_toBytesLe","transition_programId","transition_functionName","containsCommitment","transition_containsCommitment","containsSerialNumber","transition_containsSerialNumber","transition_findRecord","transition_ownedRecords","transition_records","transition_inputs","transition_outputs","tpk","tvk","transition_tvk","tcm","transition_tcm","scm","transition_scm","VerifyingKeyFinalization","__wbg_verifyingkey_free","bondPublicVerifier","verifyingkey_bondPublicVerifier","bondValidatorVerifier","verifyingkey_bondValidatorVerifier","claimUnbondPublicVerifier","verifyingkey_claimUnbondPublicVerifier","feePrivateVerifier","verifyingkey_feePrivateVerifier","feePublicVerifier","verifyingkey_feePublicVerifier","inclusionVerifier","verifyingkey_inclusionVerifier","joinVerifier","verifyingkey_joinVerifier","setValidatorStateVerifier","verifyingkey_setValidatorStateVerifier","splitVerifier","verifyingkey_splitVerifier","transferPrivateVerifier","verifyingkey_transferPrivateVerifier","transferPrivateToPublicVerifier","verifyingkey_transferPrivateToPublicVerifier","transferPublicVerifier","verifyingkey_transferPublicVerifier","transferPublicAsSignerVerifier","verifyingkey_transferPublicAsSignerVerifier","transferPublicToPrivateVerifier","verifyingkey_transferPublicToPrivateVerifier","unbondPublicVerifier","verifyingkey_unbondPublicVerifier","isBondPublicVerifier","verifyingkey_isBondPublicVerifier","isBondValidatorVerifier","verifyingkey_isBondValidatorVerifier","isClaimUnbondPublicVerifier","verifyingkey_isClaimUnbondPublicVerifier","isFeePrivateVerifier","verifyingkey_isFeePrivateVerifier","isFeePublicVerifier","verifyingkey_isFeePublicVerifier","isInclusionVerifier","verifyingkey_isInclusionVerifier","isJoinVerifier","verifyingkey_isJoinVerifier","isSetValidatorStateVerifier","verifyingkey_isSetValidatorStateVerifier","isSplitVerifier","verifyingkey_isSplitVerifier","isTransferPrivateVerifier","verifyingkey_isTransferPrivateVerifier","isTransferPrivateToPublicVerifier","verifyingkey_isTransferPrivateToPublicVerifier","isTransferPublicVerifier","verifyingkey_isTransferPublicVerifier","isTransferPublicAsSignerVerifier","verifyingkey_isTransferPublicAsSignerVerifier","isTransferPublicToPrivateVerifier","verifyingkey_isTransferPublicToPrivateVerifier","isUnbondPublicVerifier","verifyingkey_isUnbondPublicVerifier","verifyingkey_checksum","verifyingkey_copy","verifyingkey_fromBytes","verifyingkey_fromString","verifyingkey_toBytes","verifyingkey_toString","ViewKeyFinalization","__wbg_viewkey_free","viewkey_from_string","viewkey_to_string","to_scalar","deferred3_0","deferred3_1","viewkey_decrypt","__wbg_load","Response","WebAssembly","instantiateStreaming","instantiate","Instance","__wbg_get_imports","wbg","__wbg_abort_775ef1d17fc65868","abort","__wbg_address_new","__wbg_append_8c7dd8d641a5f01b","arg4","append","arguments","__wbg_arrayBuffer_d1b44c4390db422f","__wbg_async_9ff6d9e405f13772","__wbg_buffer_609cc3eee51ed158","__wbg_call_672a4d21634d4a24","call","__wbg_call_7cccdd69e0791ae2","__wbg_ciphertext_new","__wbg_crypto_ed58b8e10a292839","crypto","__wbg_data_432d9c3df2630942","__wbg_done_769e5ede4b31c67b","done","__wbg_error_7534b8e9a36f1ab4","deferred0_0","deferred0_1","__wbg_executionresponse_new","__wbg_fetch_509096533071c657","__wbg_fetch_f1856afdb49415d1","__wbg_field_new","__wbg_field_unwrap","__wbg_getRandomValues_bcb4912f16000dc4","getRandomValues","__wbg_get_67b2ba62fc30de12","Reflect","__wbg_get_b9b93047fe3cf45b","__wbg_group_new","__wbg_has_a5ea9117f258a0ec","__wbg_headers_9cb51cfd2ac780a4","__wbg_instanceof_Response_f2cc20d9f7dfd644","result","_","__wbg_iterator_9a24c88df860dc65","Symbol","iterator","__wbg_keypair_new","__wbg_length_a446193dc22c12f8","__wbg_length_e2d2a49132c1b256","__wbg_log_4a8c9f48971e8bbe","__wbg_msCrypto_0a36e2ec3a343d26","msCrypto","__wbg_new_018dcc2d6c8c2f6a","Headers","__wbg_new_23a2665fac83c611","state0","cb0","__wbg_new_405e22f390576ce2","__wbg_new_78feb108b6472713","__wbg_new_86231e225ca6b962","XMLHttpRequest","__wbg_new_8a6f238a6ece86ea","__wbg_new_a12002a7f91c75be","__wbg_new_b1a33e5095abf678","__wbg_new_e25e5aab09ff45db","AbortController","__wbg_new_e9a4a67dbababe57","Int32Array","__wbg_newnoargs_105ed471475aaf50","Function","__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a","__wbg_newwithlength_a381634e90c276d4","__wbg_newwithlength_c4c419ef0bc8a1f8","__wbg_newwithstrandinit_06c535e0a867c635","Request","__wbg_next_25feadfc0913fea9","next","__wbg_next_6574e1a8a62d1055","__wbg_node_02999533c4ea02e3","node","__wbg_of_4a05197bfc89556f","of","__wbg_open_13a598ea50d82926","arg5","open","__wbg_overrideMimeType_36ce5eeae20aff9f","overrideMimeType","__wbg_plaintext_new","__wbg_postMessage_6edafa8f7b9c2f52","__wbg_process_5c1d670bc53614b8","process","__wbg_push_737cfc8c1432c2c6","__wbg_queueMicrotask_97d92b4fcc8a61c5","queueMicrotask","__wbg_queueMicrotask_d3219def82552485","__wbg_randomFillSync_ab2cfe79ebbf2740","randomFillSync","__wbg_recordciphertext_new","__wbg_recordplaintext_new","__wbg_require_79b1e9274cde3c87","require","__wbg_resolve_4851785c9c5f573d","__wbg_responseText_ad050aa7f8afec9f","responseText","setInt32","__wbg_response_49e10f8ee7f418db","__wbg_send_40a47636ff90f64d","send","__wbg_set_37837023f3d740e8","__wbg_set_65595bdd868b3009","__wbg_set_bb8cecf6a62b9f46","__wbg_setbody_5923b78a95eedf29","__wbg_setcredentials_c3a22f1cd105a2c6","credentials","__wbg_setheaders_834c0bdb6a8949ad","__wbg_setmethod_3c5280fe5d890842","__wbg_setmode_5dc300b865044b65","mode","__wbg_setonmessage_5a885b16bdc6dca6","onmessage","__wbg_setsignal_75b21ef3a81de905","signal","__wbg_signal_aaf9ad74119f20a4","__wbg_signature_new","__wbg_spawnWorker_ea0d99567d890697","__wbg_stack_0ed75d68575b0f3c","stack","__wbg_static_accessor_GLOBAL_88a902d13a557d07","global","__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0","globalThis","__wbg_static_accessor_SELF_37c5d418e4bf5819","self","__wbg_static_accessor_WINDOW_5de37043a91a9c40","window","__wbg_status_12bcf88a8ff51470","__wbg_status_f6360336ca686bf0","__wbg_stringify_f7ed6987935b4a24","stringify","__wbg_subarray_aa9065fa9dc5df96","__wbg_then_44b73946d2fb3e7d","then","__wbg_then_48b406749878a531","__wbg_transaction_new","__wbg_transition_new","__wbg_url_ae10c34ca209681d","__wbg_value_cd1ffa7b1ab794f1","__wbg_value_dab73d3d5d4abaaf","__wbg_verifyingkey_new","__wbg_versions_c71aa1626a93e0a1","versions","__wbg_waitAsync_61f0a081053dd3c2","Atomics","waitAsync","__wbg_waitAsync_7ce6c8a047c752c3","__wbindgen_bigint_from_i128","__wbindgen_bigint_from_i64","__wbindgen_bigint_from_u128","__wbindgen_bigint_from_u64","__wbindgen_boolean_get","v","__wbindgen_cb_drop","__wbindgen_closure_wrapper6080","__wbindgen_closure_wrapper6086","__wbindgen_is_function","__wbindgen_is_object","val","__wbindgen_is_string","__wbindgen_is_undefined","__wbindgen_link_9579f016b4522a24","URL","createObjectURL","encodeURIComponent","Blob","__wbindgen_memory","__wbindgen_module","__wbg_init","__wbindgen_wasm_module","__wbindgen_number_new","__wbindgen_object_clone_ref","__wbindgen_object_drop_ref","__wbindgen_rethrow","__wbindgen_string_get","__wbindgen_string_new","__wbindgen_throw","__wbg_init_memory","Memory","initial","maximum","shared","__wbg_finalize_init","thread_stack_size","exports","__wbindgen_start","module_or_path","getPrototypeOf","module$1","num_threads","initThreadPool","proxyMarker","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","proxyTransferHandler","canHandle","serialize","port1","port2","MessageChannel","expose","deserialize","port","ep","target","pendingListeners","ev","resolver","createProxy","wrap","transferHandlers","serialized","isError","allowedOrigins","callback","origin","allowedOrigin","RegExp","test","isAllowedOrigin","path","argumentList","fromWireValue","returnValue","parent","reduce","prop","rawValue","proxy","transfers","transferCache","catch","wireValue","transferables","toWireValue","removeEventListener","closeEndPoint","TypeError","endpoint","isMessagePort","close","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","newCount","isProxyReleased","Proxy","_target","unregisterProxy","r","p","bind","_thisArg","rawArgumentList","last","processArguments","construct","registerProxy","processed","arr","concat","handler","serializedValue","msg","floor","MAX_SAFE_INTEGER"],"sourceRoot":""}